<p>파이썬으로 알고리즘 문제를 풀 때 알아두면 좋은 팁.<br>파이썬은 강력한 기본기능들을 가지고 있어 코딩테스트에서 깡패임.<br>계속 업데이트할 것.</p>
<hr>
<h2>리스트 관련</h2>
<ul>
<li><code>list.append(item)</code> - 아이템 추가. $O(1)$</li>
<li><code>list.sort()</code> - 리스트를 정렬한다. $O(NlogN)$</li>
<li><code>list.reverse()</code>- 리스트를 뒤집는다. $O(N)$</li>
<li><code>list.pop(idx)</code> - 인덱스의 아이템을 꺼내서 반환. pop(0) 하면 popleft 처럼 사용가능.</li>
<li><code>list.insert(i, item)</code> - 아이템을 삽입. $O(N)$</li>
<li><code>list.count(item)</code> - 리스트 내의 아이템 갯수 세기. $O(N)$</li>
<li><code>list.remove(item)</code> - 아이템 하나 제거. $O(N)$</li>
<li><code>list[::-1]</code> -역순으로 출력할때</li>
<li><code>list.copy()</code> - 리스트를 복사한다.</li>
<li><code>list.extend()</code> - iterable 을 모두 쪼개서 집어넣는다.</li>
<li><code>list.index(item)</code> - item 의 인덱스를 반환한다.</li>
<li><code>&#39;\n&#39;.join(str)</code> - 한 줄 씩 줄바꿔 출력</li>
<li>빈 리스트에 * 연산하면 아무것도 안됨. 초기화 값을 넣어놔야함.</li>
</ul>
<h2>문자열 관련</h2>
<ul>
<li><code>+</code>, <code>*</code> 연산 가능.</li>
<li>인덱싱, 슬라이싱 가능</li>
<li>문자 변경 불가</li>
<li><code>str.strip(_)</code> - 기준 문자를 모두 삭제</li>
<li><code>str.split(_)</code> - 문자열을 기준 문자로 쪼갠다.</li>
<li>&#39;&#39;.join(list) - 리스트를 문자열로 합칠 때. 단, 리스트 원소들은 문자열이어야 한다.</li>
<li><code>str.upper()</code> - 대문자화</li>
<li><code>str.lower()</code> - 소문자화</li>
<li><code>str.caplitalize()</code> - 첫 문자만 대문자, 나머지는 소문자화. 숫자는 무시</li>
<li><code>str.replace(&#39;from&#39;, &#39;to&#39;)</code> - from 에 해당하는 문자열을 모두 to 로 바꾸고 반환을 한다.</li>
<li><code>str.isalpha()</code> - str 이 영어 알파벳으로만 이루어졌는지 체크한다. 아스키코드를 쓰지않아도 된다.</li>
</ul>
<h2>딕셔너리 관련</h2>
<ul>
<li>해쉬테이블을 사용하므로 검색/수정이 상수시간이다. 순서가 없다. 정말 빠르다!</li>
<li>key 와 value 만 따로 리스트로 만들 수 있다.</li>
<li>반복문에선 딕셔너리 자체를 돌리면 key 값으로 순회한다.</li>
<li><code>for k, v in dict.items()</code> 로 루프 돌리기</li>
<li>정렬할 때 sorted 사용하는데 정렬기준을 key, value 등으로 람다식으로 정해줄 수 있다.</li>
<li><code>sorted(dict.items, key=lambda x:x\[1\])</code></li>
<li>인덱스 정렬 때 딕셔너리 정렬이 유용하다.</li>
<li>key 가 있는지 없는지 검사하는덴 <code>not in</code> 을 쓴다.</li>
<li>가끔 value 로 key 를 찾아야하는 경우가 있는데, 이 때는 dict.items() 를 iterate 한다. 단, value 가 중복될 수 있다는 것을 인지하고 있어야 한다.</li>
<li>컴프리헨션으로 딕셔너리를 만들 수 있다.</li>
<li><code>{key:value for i in list}</code></li>
<li>딕셔너리 key 값을 정수형으로도 설정할 수 있다!</li>
</ul>
<h2>defaultdict</h2>
<ul>
<li>collections 모듈에 포함됨.</li>
<li>등록되지 않은 key 에 대해서 원하는 자료형으로 초기화 할 수 있다.</li>
<li><code>dic = defaultdict(list)</code> 이면 임의의 key 에 대해서 리스트로 초기화 됨.</li>
</ul>
<h2>집합 관련</h2>
<ul>
<li>순서가 없어서 인덱싱 불가. 추가/삭제가 빠르다.</li>
<li>값이 등장했는지, 값이 존재하는지 등을 체크할 때 유용함.</li>
<li>중복제거에 유용함. 특히 순열의 결과에서 후처리 할 때 좋음.</li>
<li><code>set.add(item)</code></li>
<li><code>set.remove(item)</code></li>
<li><code>set(a+b)</code> - a 와 b 의 합집합.</li>
<li><code>set(set | set)</code>, <code>set(set &amp; set)</code> - 각각 합집합, 교집합</li>
<li>집합에는 리스트 자체를 원소로 가질 수 없다.</li>
<li>인덱스가 없어서 빠르다!!</li>
<li>set 도 딕셔너리처럼 정렬이 된다. 굳이 리스트로 바꿀 필요는 없다.</li>
</ul>
<h2>스택</h2>
<ul>
<li>리스트로 스택을 사용할 수 있다.</li>
<li>append : push</li>
<li>pop: pop</li>
</ul>
<h2>큐</h2>
<ul>
<li>collection 모듈의 deque 클래스 사용</li>
<li>deque 로도 스택을 쓸 수 있다. 더 빠르다.</li>
<li>deque 는 정렬이 안된다.</li>
<li>append : enqueue</li>
<li>popleft : dequeue</li>
<li>스택과 큐는 빠르다!!!</li>
</ul>
<h2>deque</h2>
<ul>
<li>list 보다 빠르다.</li>
<li>스택, 큐를 구현할 때 항상 deque 를 쓰는것이 좋다.</li>
<li>인덱스가 없어서 스택, 큐로 사용한다.</li>
<li>인덱스가 없기 때문에 정렬은 불가능한 듯 하다.</li>
</ul>
<h2>힙</h2>
<ul>
<li>우선순위 큐.</li>
<li><code>import heapq</code></li>
<li>자동으로 정렬이 된다.</li>
<li>파이썬은 기본적으로 오름차순(min heap) 지원</li>
<li>리스트형식으로 사용 가능.(시퀀스 자료구조)</li>
<li><code>heapq.heappush(heap, item)</code></li>
<li><code>heapq.heappop(heap)</code></li>
</ul>
<h2>입력 관련</h2>
<ul>
<li>일반적으로 <code>list(map(int, input.split()))</code></li>
<li>빠른 입력을 위해 <code>sys.stdin.readline().rstrip()</code></li>
</ul>
<h2>itertools</h2>
<ul>
<li>순열, 조합 경우의 수를 반환해준다.</li>
<li>탐색 문제에서 경우의 수를 다 돌 때 매우 유용하다.</li>
<li>숫자 뿐 아니라 딕셔너리 key 도 조합해서 반환해주므로 딕셔너리 다루는데 편리하다.</li>
</ul>
<h2>내장함수</h2>
<ul>
<li><code>sum(contatiner)</code> - 총합</li>
<li><code>min(contatiner)</code>, <code>max(contatiner)</code> - 최대/최소</li>
<li><code>eval(str)</code> - 문자열 형식의 식을 계산</li>
<li><code>sorted(container)</code> - 정렬한 후 결과를 반환, 정렬 순서를 lambda 로 설정 가능.<ul>
<li>심지어 나누기 등 연산의 결과를 정렬의 기준으로 삼을 수도 있다.</li>
</ul>
</li>
<li><code>in</code> 연산 - iteratable 데이터에 특정 데이터가 있는지 확인.<ul>
<li>인덱스 기반 데이터는 $O(N)$, 해시 기반은 $O(1)$</li>
</ul>
</li>
</ul>
<h2>그리디</h2>
<ul>
<li>항상 가장 최대/최소의 값만 선택해서 답을 찾는 알고리즘</li>
<li>항상 최대값만 찾아도 해가 도출되는 타당성이 필요함.</li>
</ul>
<h2>재귀</h2>
<ul>
<li>함수스택과 동일한 과정</li>
<li>점화식을 적용하면 유용</li>
</ul>
<h2>그래프</h2>
<ul>
<li>노드, 엣지의 개념을 인접행렬이나 인접리스트로 표현한다.</li>
<li>2 차원 리스트로 구현한다.</li>
<li>노드를 인덱스로 접근하는 경우가 많다.</li>
<li>1 부터 시작 시, 첫 노드는 비워둔다.</li>
<li>좌표공간도 그래프다. 노드 당 엣지가 상하좌우 4 개인 그래프.</li>
</ul>
<h2>람다식</h2>
<ul>
<li>1 회용 함수 만드는 문법.</li>
<li>값을 적절히 변형할 때, 굳이 따로 함수를 만들 필요는 없을 때 유용.</li>
<li>lambda 매개변수 : 식 (인자들) 로 주로 쓴디ㅏ.</li>
<li>람다함수 자체를 변수에 넣어 사용가능</li>
</ul>
<h2>안정 정렬</h2>
<ul>
<li>정렬할 때 순서가 유지되는 정렬.</li>
<li>기본적으로 버블 정렬, 삽입 정렬, 병합 정렬은 안정 정렬이다.</li>
<li>파이썬에서 <code>sort(key=lambda x:x[0])</code> 처럼 하면 안정 정렬이 지원되는 듯.</li>
</ul>
<h2>기타</h2>
<ul>
<li><code>str()</code>, <code>int()</code> 등 내장된 캐스팅 함수로 간편히 형변환 가능. 문자열과 큰 정수형의 캐스팅은 아주 유용하다.</li>
<li>큰 수를 표현할 때 <code>1e9</code> 등으로 나타낸다. <em>INF</em> 를 설정할 때 쓰인다. 단, 실수형이므로 <code>int()</code> 로 캐스팅이 필요하다.</li>
<li>몫은 <code>//</code>, 나머지는 <code>%</code> 연산으로 구한다. // 은 바로 배치 단위로 나눠 인덱스에 설정하는데 유용하게 사용된다.</li>
<li><code>divmod(n)</code> - 아예 몫과 나머지를 함께 구할 수 있다.</li>
<li>거듭제곱은 <code>**</code>, 제곱근은 <code>** 0.5</code> 연산</li>
<li>다차원 배열은 반복문 표현식으로 초기화하면 편리하다.</li>
<li><code>in</code>, <code>not in</code> 연산자는 활용도가 높다.</li>
<li><code>math.ceil(n)</code> - 천장함수. 올림</li>
<li><code>math.floor(n)</code> - 바닥함수. 내림</li>
<li>str 을 받아서 리스트로 만들 때 map 함수가 더 간편함.</li>
<li><code>zip(a, b)</code> - 크기가 같은 자료를 묶어서 iterate 할 수 있도록 한다.</li>
<li><code>list.copy()</code> 는 list[:] 과 같다.</li>
<li><code>del list[a:b]</code> - 객체를 삭제하는 파이썬 내장함수. 여러개 원소를 삭제할 수도 있으며, 모든 객체에 적용된다.</li>
<li>0, 빈 자료구조, None 등은 조건문에서 False 이다.</li>
<li><code>float(&#39;inf&#39;)</code> 는 파이썬에서 무한을 나타낼 때 쓴다.</li>
<li>pypy 로 제출하면 python 보다 더 빠를 수도 있다. 하지만 메모리를 더 먹는다.</li>
<li>파이썬은 1 초당 20,000,000 번 연산 한다고 생각한다.</li>
<li><code>exit(0)</code> - 파이썬 스크립트에서 프로그램 걍 종료.</li>
<li><code>max</code>, <code>min</code> 함수에도 key 를 lambda 함수로 줘서 탐색할 수 있다!</li>
</ul>
<h2>전역 변수</h2>
<ul>
<li>함수 안에서 읽을 수는 있지만, 수정은 불가능하다.</li>
<li>global 로 전역변수임을 명시하면 수정이 가능하다.</li>
<li>함수 안에서 중복 선언하면 그냥 지역변수로 된다.</li>
<li>주의할 것은, 전역에 선언된 배열이나 객체는 함수 안에서 원소에 접근하여 수정할 수 있다.</li>
<li>얕은 복사라서 그런 듯 한데, 삭제는 수정이라고 간주해서 불가능하다.</li>
</ul>
<p>진법 변환</p>
<ul>
<li>파이썬은 아주 간단하게 진법변환을 할 수 있다.</li>
<li><code>bin(number)</code> - 2 진법 변환값 반환</li>
<li><code>int(0bxxxx)</code>, <code>int(&#39;0bxxxx&#39;, 2)</code> - 2 진수를 10 진수 변환값을 반환</li>
</ul>
<h2>에러관련</h2>
<ul>
<li>파이썬은 컴파일 에러가 안뜨므로 오타 주의해야함. 런타임에러시 오타도 확인해야 함.</li>
<li>출력크기 초과가 뜰 때는 print 명령을 다 지웠는지 확인한다.</li>
<li>백준에서 반환만 하고 출력을 안할 경우를 의심.</li>
</ul>
<h2>아스키코드</h2>
<ul>
<li><p>48 - 0</p>
</li>
<li><p>65 - A</p>
</li>
<li><p>97 - a</p>
</li>
</ul>
