<h1>13 강</h1>
<p>DP 핵심 유형 문제</p>
<h2>LCS</h2>
<ul>
<li>난이도 - 하</li>
<li>유형 - DP, LCS</li>
<li>핵심<br>글자를 하나씩 늘려가며(부분 문제) 끝 글자를 비교한다.<br>같으면 테이블의 대각선에서 1 을 더한값을, 아니면 위, 왼 쪽중 큰값을 대입한다.</li>
<li>비고<br>많이 출제되는 유형 중 하나.<br>LIS 와 비슷해서 직접 테이블을 그리고 하나씩 비교했다.<br>정석풀이와 정확히 동일하게 풀었다.<br>하지만 끝 글자를 비교해도 되는지에 대해 의문이 들었고 점화식을 완벽히 세울 수가 없었다.<br>아직 아리송하다.</li>
</ul>
<pre><code># LCS
a = input()
b = input()
cache = [[0] * (len(a)+1) for _ in range(len(a)+1)]

for i in range(len(a)):
    for j in range(len(b)):
        if a[i] == b[j]:
            cache[i+1][j+1] = cache[i][j] + 1
        else:
            cache[i+1][j+1] = max(cache[i+1][j], cache[i][j+1])

print(cache[len(a)][len(b)])</code></pre><h2>기타리스트</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - DP</p>
</li>
<li><p>핵심</p>
<ul>
<li>모든 볼륨에 대해 연주 가능 여부 계산</li>
<li>2 차원 캐시 테이블을 만든다.</li>
</ul>
</li>
<li><p>비고<br>배낭 문제와 유사함.<br>곡을 하나씩 연주한다니까 부분 최소 문제(한 곡) 로 자연스럽게 나눌 수 있다.<br>볼륨이 타겟이므로 볼륨을 최소에서 최대까지 늘리며 검사한다.<br><code>cahce[문제대상][타겟]</code> 으로 2 차원 테이블 형식 문제다.<br>이 문제는 볼륨 연주 가능/불가능 문제로 바꾼다.</p>
<p>어렵다.<br>아이디어 생각하기도 어렵고 점화식 작성도 어렵다..</p>
</li>
</ul>
<pre><code># 기타리스트
n, s, m = list(map(int, input().split()))
arr = list(map(int, input().split()))
cache = [[0] * (m+1) for _ in range(n+1)]
cache[0][s] = True

for i in range(1, n+1):
    for j in range(m+1):
        if cache[i-1][j] == 0:
            continue

        if j - arr[i-1] &gt;= 0:
            cache[i][j-arr[i-1]] = True

        if j + arr[i-1] &lt;= m:
            cache[i][j+arr[i-1]] = True


result = -1
for i in range(m, -1, -1):
    if cache[n][i] == 1:
        result = i
        break
print(result)</code></pre><h2>가장 높은 탑 쌓기</h2>
<ul>
<li>난이도 - 상</li>
<li>유형 - DP</li>
<li>핵심<br>LIS 변형문제<br>N 제곱으로 푼다.<br>테이블을 역추적해야 하고 중간 정보를 저장해놔야 한다.<br>무게나 너비로 정렬한다.</li>
<li>비고<br>고심 끝에 솔루션을 구했다.<br>테이블을 구하고, 부분 문제 아이디어를 생각해내고, 점화식을 작성했다.<br>하지만 마지막 역추적하는 로직에서 좌절했다.<br>이전에 공부한 LIS 의 변형인것 같았다. 즉 n^2 복잡도에다 1 차원 테이블 형태.<br>하지만 강사가 푼 솔루션은 정렬을 했다. 왜?<br>시간을 들여 내 힘으로 풀었을 때 싱크가 맞지 않으면 오히려 힘이 빠진다.<br>그냥 강의에 따라야겠다.<br>역추적하는 과정까지는 좀 힘들다. 다음에 하자.</li>
</ul>
<pre><code># 가장 높은 탑 쌓기
n = int(input())

array = []
array.append((0, 0, 0, 0))
for i in range(1, n + 1):
    area, height, weight = map(int, input().split())
    array.append((i, area, height, weight))

# 무게를 기준으로 정렬합니다.
#array.sort(key=lambda data: data[3])

dp = [0] * (n + 1)
for i in range(1, n + 1):
    for j in range(0, i):
        if array[i][1] &gt; array[j][1]:
            dp[i] = max(dp[i], dp[j] + array[i][2])

max_value = max(dp)
index = n
result = []
while index != 0:
    if max_value == dp[index]:
        result.append(array[index][0])
        max_value -= array[index][2]
    index -= 1
result.reverse()

print(len(result))
[print(i) for i in result]</code></pre>