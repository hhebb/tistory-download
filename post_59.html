<h2>출처</h2>
<p>프로그래머스</p>
<h2>난이도</h2>
<p>프로그래머스 level 2, 카카오 2018 블라인드 채용 3 차 문제</p>
<h2>유형</h2>
<p>정렬<br>구현</p>
<h2>특이사항</h2>
<p>로직 단계를 잘 나눠야 함.</p>
<h2>총평</h2>
<p>그다지 어렵진 않았음.<br>숫자의 등장을 잘 체크하고 걸러줘야 오답이 나지 않는다.</p>
<pre><code>def solution(files):
    answer = []
    original_key = {}
    chunks = {}

    # 마지막 출력을 위한 최초 들어온 키 저장
    for idx, file in enumerate(files):
        original_key[idx] = file

    # 정렬을 위한 전처리 과정
    for file_num, file in enumerate(files):
        file = file.upper()

        # 이름 걸러주기
        for idx, c in enumerate(file):
            if ord(c) &lt; 48 or ord(c) &gt;= 58:
                pass
            else:
                name = file[:idx]
                # 번호 걸러주기
                for i in range(idx, len(file)):
                    if ord(file[i]) &gt;= 48 and ord(file[i]) &lt; 58:
                        number = int(file[idx:i+1])
                    else:
                        break
                break

        # 청크에 넣어준다.
        if name in chunks:
            chunks[name].append((number, file_num))
        else:
            chunks[name] = [(number, file_num)]

    # 청크를 이름순으로 정렬해주기
    order_chunks = []
    sorted_name = sorted(chunks.keys())
    order_chunks = [chunks[name] for name in sorted_name]

    # 각 청크별로 숫자순으로 정렬해주기
    for idx, chunk in enumerate(order_chunks):
        res = sorted(chunk, key=lambda x:x[0])
        for r in range(len(res)):
            answer.append(original_key[res[r][1]])    
    return answer</code></pre>