<h1>탐색</h1>
<p>binary search 역시 분할 정복 전략을 사용한다.<br>중복되지 않는 작업을 잘게 쪼개며 알고리즘을 수행하다.<br>역시 visualgo 보다 코드를 보는 것이 편하다.</p>
<h2>이진 탐색</h2>
<ul>
<li>개념 - 정렬된 데이터에서 특정 데이터를 찾을 때, 중간 지점에 있는 것과 비교하여 매 스텝마다 절반을 버리며 찾는다.</li>
<li>비고 - 반드시 정렬된 형태의 데이터가 입력으로 주어져야 한다.</li>
</ul>
<pre><code># 이 코드는 틀렸다. 다음에 수정하기
def bin_search(arr, n):
    if len(arr) == 0:                        # 남겨진 데이터의 길이가 0 이면 결국 찾는 것이 없다는 뜻으로, 실패를 반환
        return False

    mid = int(len(arr)/2)                    # 절반 지점을 찍는다.
    if arr[mid] == n:                        # 그 지점이 찾는 것이라면 성공.
        return True
    elif arr[mid] &lt; n:                        # 그 지점이 찾는 것보다 작으면 왼쪽 절반은 버린다.
        left = mid
        right = len(arr)
    else:                                    # 그 지점이 찾는 것보다 크면 오른쪽 절반은 버린다.
        left = 0
        right = mid

    return bin_search(arr[left:right], n)    # 남겨진 데이터를 대상으로 다시 탐색한다.</code></pre><h2>이진 탐색 2</h2>
<ul>
<li>분할정복 이진탐색을 재귀가 아닌 반복문으로 구현함.<br>매 스텝마다 절반의 리스트를 전달하는 대신, left, right 변수만 조작해주면 반복문으로 쉽게 구현 가능하다.<br>인덱스 때문에 에러가 많이 날 수도 있다.<br>mid 를 항상 <code>//</code> 연산으로 내림하므로 left 인덱스를 mid+1 로 처리해주는 팁이 있다.</li>
</ul>
<pre><code>def bin_search2(arr, n):
    left = 0
    right = len(arr)-1
    find = False
    while left &lt; right:
        print(left, right)
        mid = (right+left)//2
        if arr[mid] == n:
            find = True
            break
        if arr[mid] &lt; n:
            left = mid+1
        else:
            right = mid
    return find

arr = random.sample(range(50), 15)
arr.sort()
#arr = [5, 7, 8]
print(arr)
bin_search2(arr, 5)</code></pre>