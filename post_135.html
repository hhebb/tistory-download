<h1>구간 정보</h1>
<p>연속된 데이터의 정보를 효율적으로 구하는 기법들을 다룬다.<br>구간 합, 구간 최대/최소값 등을 구하는 데 효과적인 방법들이다.</p>
<h2>two pointer</h2>
<ul>
<li>개념<br>시작점과 끝점을 설정하고 하나씩 올리고 내리며 목표 값을 찾는다.</li>
<li>비고<br>처음부터 하나씩 다 더하는 무식한 방법은 $O(N^2)$ 이 걸리지만 이 방법은 $O(N)$ 의 시간복잡도를 가진다.</li>
</ul>
<pre><code>def two_pointer(arr, target):
    left = 0
    right = 0
    tmp = arr[0]
    find = 0
    while left &lt; len(arr) and right &lt; len(arr):
        if tmp == target:
            print(left, right)
            find += 1
            tmp -= arr[left]
            left += 1

        elif tmp &lt; target:
            right += 1
            if right &lt; len(arr):
                tmp += arr[right]
        else:
            tmp -= arr[left]
            left += 1

arr = [random.sample(range(10), 5)]
print(arr)
two_pointer([1,2,4,4,6,1,3,6], 10)</code></pre><h2>prefix sum</h2>
<ul>
<li>개념<br>특정 구간에 대한 구간연산 쿼리가 들어올 때마다 구간 합의 차 연산을 통해 쿼리에 대한 응답을 내는 기법.</li>
<li>비고<br>시간 복잡도는 $O(N+M)$, N = 데이터 갯수, M = 쿼리 횟수<br>아래는 접두사 합 결과를 구하는 로직만 있다.</li>
</ul>
<pre><code># 접두사 합
def prefix_sum(arr):
    prefix_arr = []
    sigma = 0
    for i in arr:
        sigma += i
        prefix_arr.append(sigma)
    return prefix_arr

prefix_sum([1,2,4,3])</code></pre><h2>segment tree</h2>
<ul>
<li><p>개념<br>prefix sum 처럼 구간의 정보를 저장한다.<br>이진 트리 형태로 정보를 저장한다.<br>쿼리와 값 수정에도 log 시간을 보장하도록 한다.</p>
</li>
<li><p>비고<br>시간 복잡도는 쿼리, 갱신에 모두 $O(logN)$<br>힙과 비슷하게 배열로 구현한다.<br>사이즈는 데이터의 갯수 * 4 개로 하는것이 편하다.<br>이러면 트리의 빈 곳이 생기는 데 그것은 그냥 무시한다.</p>
<p>init 에서 트리 초기화하며 mid 값을 설정할 때, 반으로 쪼개는 과정에서 내림 현상때문에 오른쪽이 항상 왼쪽보다 커지는 경우, ceil 함수를 씌워주면 편리하게 왼쪽을 더 크게 하여 쪼갤 수 있다.<br>이는 이진 탐색 등 절반씩 쪼개며 분할 정복하는 알고리즘 등에서도 유용하게 쓰일 수 있다.</p>
<p>노드를 추가하거나 삭제하는 과정은 트리를 다시 구성해야하므로 더 복잡한 과정이 필요한데 그까지는 고려하지 않는다.</p>
</li>
</ul>
<pre><code># segment tree
# 여기서는 구간 합을 저장하는 트리
import math

class segment_tree:
    def __init__(self, array):
        self.arr = array
        self.tree = [0] * len(self.arr) * 4
        self.init_tree(1, 0, len(self.arr))

    # 트리 초기화
    def init_tree(self, node, left, right):
        # leaf 노드 설정
        if left + 1 == right:
            self.tree[node] = self.arr[left]
        else:
            mid = math.ceil((left + right) // 2)
            self.tree[node] = self.init_tree(node*2, left, mid) + self.init_tree(node*2 + 1, mid, right)

        return self.tree[node]

    # 쿼리 함수
    # start, end - 찾고자하는 구간
    # node, left, right - 현재 노드의 구간 정보
    def query(self, node, start, end, left, right):
        # 찾고자하는 구간에 현재 노드 구간이 다 포함 되는 경우
        if start &lt;= left and end &gt;= right:
            return self.tree[node]
        # 하나도 포함되지 않는 경우
        elif start &gt;= right or end &lt;= left:
            return 0
        # 부분적으로 포함되는 경우
        else:
            mid = (left + right) // 2
            return self.query(node*2, start, end, left, mid) + self.query(node*2 + 1, start, end, mid, right)

    def update(self, target, val):
        self.arr[target] += val
        self._update(1, 0, len(self.arr), target, val)

    # target node 의 값을 val 만큼 증가시킬 때 업데이트
    def _update(self, node, left, right, target, val):
        if left &lt;= target &lt;= right:
            self.tree[node] += val
            if left + 1 == right:
                return
            else:
                mid = (left+right) // 2
                self._update(node*2, left, mid, target, val)
                self._update(node*2 + 1, mid, right, target, val)
#
arr = [3,0,2,0,0]
st = segment_tree(arr)
print(st.tree)
print(st.query(1, 2, 4, 0, len(arr)))
st.update(3, 10)
st.arr</code></pre><h2>fenwick tree</h2>
