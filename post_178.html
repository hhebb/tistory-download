<h1>문법</h1>
<h2>this 키워드</h2>
<ul>
<li>함수가 호촐될 때 기본 매개변수 arguments 객체와 this 를 암묵적으로 전달 받는다.</li>
<li>다른 언어처럼 인스턴스 자신을 가리키는 참조변수가 아니다.</li>
</ul>
<h2>함수 호출 방식</h2>
<ol>
<li>함수 호출<br /><code>func();</code></li>
<li>메서드 호출<br /><code>obj.func();</code></li>
<li>생성자 함수 호출<br /><code>var bar = new func();</code></li>
<li>apply, call, bind 호출<br /><code>func.all(bar)</code> 등..</li>
</ol>
<h2>전역 객체</h2>
<ul>
<li>모든 객체의 최상위 객체.</li>
<li>front 에서는 window</li>
<li>back 에서는 global 객체</li>
<li>전역 객체는 전역 스코프를 갖는 전역 변수를 프로퍼티로 소유한다.</li>
<li>글로벌 영역에 선언한 함수는 전역 변수 개념의 함수다.</li>
</ul>
<h2>함수 호출할 떄 this 바인딩</h2>
<ul>
<li>기본적으로 this 는 전역객체에 바인딩된다.</li>
<li>심지어 내부함수의 경우도, this 는 전역객체에 바인딩된다..</li>
<li>콜백함수의 경우에도 this 는 전역 객체에 바인딩된다.</li>
<li>이는 설계 결함이라고 한다..</li>
</ul>
<h2>this-전역 바인딩 회피</h2>
<ul>
<li>apply, call, bind 메서드<br />this 를 명시적으로 바인딩할 수 있다.</li>
</ul>
<h2>메서드 호출할 때 this 바인딩</h2>
<ul>
<li>함수가 객체의 프로퍼티 값이면 메서드로서 호출됨</li>
<li>이 때 this 는 메서드를 소유한 객체에 바인딩된다.</li>
<li>프로토타입 객체도 메서드를 가질 수 있는데 역시 this 는 해당 객체와 바인딩된다.</li>
</ul>
<h2>생성자 함수로 호출할 때 this 바인딩</h2>
<ul>
<li>빈 객체를 만들어 거기에다 바인딩한다.</li>
<li>this 를 명시하고 프로퍼티를 추가하면 그 새로 생성된 객체에 추가된다.</li>
</ul>
<h2>객체 리터럴 vs 생성자 함수</h2>
<ul>
<li>둘의 차이는 프로토타입 객체의 차이.</li>
<li>객체 리터럴 방식은 프로토타입 객체가 Object.prototype</li>
<li>생성자 함수 방식은 프로토타입 객체가 Function.prototype</li>
</ul>
<h2>생성자 함수에 new 를 안붙이고 호출할 경우</h2>
<ul>
<li>new 로 객체 생성안하면 함수의 this 는 전역 객체에 바인딩된다.</li>
<li>그리고 일반 호출하면 객체가 생성되지 않는다.</li>
<li>의도치않은 결과가 발생할 수 있다.</li>
</ul>
<h2>명시적 this 바인딩</h2>
<ul>
<li>apply / call / bind 메서드</li>
</ul>
<h2>실행 컨텍스트</h2>
<ul>
<li>js 의 동작 원리를 담고 있는 핵심 원리</li>
<li>실행 가능한 코드를 형상화하고 구분하는 추상적인 개념.. - 실행되기 위해 필요한 환경</li>
<li>실행가능 코드는 전역 코드, 함수 코드, eval 코드 등이 있다.</li>
</ul>
<h2>실행 컨텍스트 3 가지 객체</h2>
<ul>
<li>추상적인 개념이지만 객체의 형태</li>
<li>variable object, scope chain, thisvalue 프로퍼티를 가진다.</li>
</ul>
<h2>VO - 변수 객체</h2>
<ul>
<li>실행 컨텍스트가 생성되면 js 엔진은 실행에 필요한 정보들을 담을 객체를 생성한다.</li>
<li>이른 Variable Object 라고 하며 코드 실행 시 엔진이 참조하며, 코드에서 참조는 불가능함.</li>
<li>변수, 인수, 함수 선언 등을 담는다.</li>
<li>전역 코드 실행 시와 함수 코드 실행 시 VO 가 가리키는 값이 다르다.</li>
<li>함수 컨텍스트의 경우, arguments object 가 있다.</li>
</ul>
<h2>SC - 스코프 체인</h2>
<ul>
<li>일종의 리스트</li>
<li>가장 마지막에는 글로벌 객체가 있다.</li>
</ul>
<h2>실행 컨텍스트 생성 과정</h2>
<ul>
<li>실행 컨텍스트 진입 전 유일한 GO 가 생성된다. BOM, DOM 등이 설정되어 있다.</li>
</ul>
<h2>이것까지 알아야 하냐?</h2>
<ul>
<li>나중에 보자..</li>
</ul>
<h2>클로저</h2>
<ul>
<li>js 뿐 아니라 함수가 일급 객체로 취급되는 함수형 프로그래밍 언어에서 다 있는 중요한 개념.</li>
</ul>
<h2>렉시컬 스코프</h2>
<ul>
<li>함수를 호출할 떄가 아니라 함수를 어디에 선언했는가에 따라 스코프가 결정되는 스코핑.</li>
<li>내부함수는 외부함수의 변수를 참조할 수 있다.</li>
</ul>
<h2>외부함수, 내부함수 스코프, 클로져</h2>
<ul>
<li>만약 내부함수를 가지는 외부함수가 내부함수를 반환할 때.</li>
<li>그런데 내부함수에서 외부함수의 값을 사용할 때.</li>
<li>외부함수는 종료되었는데 외부함수의 변수는 내부함수를 통해 사용할 수가 있다..</li>
<li>이러한 함수를 클로져라고 한다.</li>
<li>클로저는 함수와 그 함수가 선언되었을 때 렉시컬 환경과의 조합이다.</li>
<li>즉 클로저는 렉시컬 스코프를 기억하고 그 환경에 접근할 수 있는 함수라는 것.</li>
<li>이 때 참조되는 외부 함수의 변수는 자유변수라고 한다.</li>
</ul>
<h2>클로저 활용</h2>
<ul>
<li>클로저는 생성될 때 환경을 기억해야 하므로 메모리 손해를 볼 수 있다.</li>
<li>하지만 기능이 강력해서 잘 쓰면 좋다.</li>
</ul>
<ol>
<li>상태 유지<br />가장 유용한 활용법<br />현재 상태 기억, 변경된 최신 상태 유지<br />전역 변수를 두는 것과 어떤 차이가 있냐라고 하면, 함수 내부 변수는 접근이 제한되므로 안정성이 좋다.</li>
<li>전역 변수 사용 억제<br />어디서나 접근하는 것을 막으면서 메모리가 기억하도록 한다.</li>
<li>정보 은닉<br />클로저를 이용해 private 키워드나, C# 의 프로퍼티를 흉내낼 수 있다.</li>
</ol>
<h2>객체 지향</h2>
<ul>
<li>js 도 엄연한 객체지향 언어.</li>
<li>프로토타입 기반은 클래스 기반 언어와 조금 다르다.</li>
<li>클래스는 속성을 바꿀 수 없지만 프로토타입 기반은 프로퍼티를 변경할 수 있다.</li>
<li>상속은 프로토타입 체인, 캡슐화는 클로저로 구현한다.</li>
</ul>
<h2>생성자 함수, 인스턴스</h2>
<ul>
<li>js 에서 생성자 함수는 new 를 통해 클래스처럼 객체를 만든다.</li>
</ul>
<h2>프로토타입</h2>
<ul>
<li>공통되는 부분은 프로토타입 객체에 담으면 된다.</li>
<li>객체 각각은 필요한 프로퍼티만 가지면 된다.</li>
</ul>
<h2>상속</h2>
<ul>
<li>js 는 프로토타입 방식인데 클래스 방식과 상속이 조금 다르다.</li>
<li>이는 객체가 다른 객체로 직접 상속된다는 특징이 있다.</li>
<li>js 는 클래스 처럼 상속하는 방식과 프로토타입으로 상속하는 방식을 선택할 수 있다.</li>
<li>수도 클래스 상속은 너무 복잡하고 단점이 많다.</li>
</ul>
<h2>프로토타입 상속</h2>
<ul>
<li>new 연산자가 필요없다.</li>
<li>간단하다.</li>
<li>생성자 링크도 파괴되지 않는다.</li>
<li>Object.create() 함수를 이용해 다른 객체로 직접 상속한다.</li>
<li>부모 함수 객체의 프로토타입을 필요로 한다.</li>
<li><code>var child = Object.create(Parent.prototype)</code></li>
</ul>