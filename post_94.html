<h1>2 강</h1>
<p>스택, 큐 분류에 해당하는 문제 3 개를 풀었다.<br />이정도는 5 분컷 하겠다는 기대를 가졌지만 생각보다 쉽지는 않았다.<br />그래도 이 강의에서 스택과 큐의 응용력을 길렀다.<br />매우 기초적인 자료구조임에도 불구하고 문제에 제대로 적용해본적이 없어서 조금 어려웠다.<br />이제 문제에 적극적으로 스택, 큐를 이용해 생각할 수 있도록 문제를 더 풀어보아야 한다.</p>
<ul>
<li>스택, 큐는 마지막 위치에 추가/제거 기능만 있으므로 라이트하다.<br />그래서 빠른 속도가 필요할 때 사용한다.<br />리스트에서 중간에 추가/제거를 반복하면 매우 느려지는데 이 때도 대신 사용하도록 스택, 큐를 짜맞출 수 있다.</li>
<li>스택, 큐를 처음부터 채우는 것과 조건에 따라 추가/ 제거 하는 방법이 있다.<br />난이도가 어려우려면 당연히 후자이며 스택, 큐로 장난을 친다. 그것에 익숙해져야 한다.</li>
</ul>
<h2>스택 수열</h2>
<ul>
<li>
<p>난이도 - 하</p>
</li>
<li>
<p>유형 - 스택, 그리디, 구현</p>
</li>
<li>
<p>핵심</p>
<ol start="3">
<li>최상위 원소를 다음 대기 수와 비교하는 것이 필요하므로 스택을 활용해야함을 인지</li>
<li>스택에 넣을 때 특정 수에 도달할 때까지 push 를 반복한다.</li>
<li>스택에서 원소를 연달아 빼낼 때 내림차순을 유지할 수 있는지 확인</li>
</ol>
</li>
<li>
<p>비고<br />일단 문제를 처음에 이해 못했다.<br />쉬워 보인다고 더욱 급하게 처리하려고 하다가 구체적인 풀이를 건너뛰었다.</p>
</li>
</ul>
<pre class="vim"><code>n = int(input())
count = 1                    # 집어넣을 수
result = []                    # 만들어진 수열
stack = []                    # 스택

for i in range(1, n+1):        
    data = int(input())
    while count &lt;= data:    # 집어넣을 수가 다음 입력 수 보다 작지 않을때까지 계속 스택에 쌓는다.
        result.append('+')
        stack.append(count)
        count += 1
    if stack[-1] == data:    # 최상단 원소가 입력 수와 같다면 pop 한다.
        result.append('-')
        stack.pop()
    else:                    # 그렇지 않으면 목표 수열을 만들 수 없다.
        print('NO')
        exit(0)
print('\n'.join(result))</code></pre>
<h2>프린터 큐</h2>
<ul>
<li>난이도 - 하</li>
<li>유형 - 큐, 구현, 그리디</li>
<li>핵심
<ol>
<li>문제 요구사항 그대로 구현한다.</li>
<li>큐에 단순한 숫자가 아닌 튜플 형태를 집어넣어 같은 우선순위의 문서의 id 를구별한다.</li>
</ol>
</li>
<li>비고<br />저번에 풀었던 문제임.<br />우선순위 중복때문에 반드시 우선순위와 최초 순서를 튜플과 같은 자료구조에 함께 관리해야한다.</li>
</ul>
<pre class="perl"><code>tc = int(input())
for _ in range(tc):
    n, m = map(int, input().split())
    prio = list(map(int, input().split()))
    prio = [(item, idx) for idx, item in enumerate(prio)] # 우선순위, 초기 위치
    q = prio

    order = 1
    while True:
        if q[0][0] == max(q)[0]:
            if q[0][1] == m:
                print(order)
                break
            q.pop(0)
            order += 1
        else:
            q.append(q.pop(0))</code></pre>
<h2>키로거</h2>
<ul>
<li>난이도 - 중</li>
<li>유형 - 스택, 구현, 그리디</li>
<li>핵심
<ol>
<li>문자열 크기가 백만이므로 시뮬레이션으로는 안된다.?</li>
<li>스택을 활용해 선형시간에 풀이.</li>
</ol>
</li>
<li>비고<br />쉽지 않았다. 시뮬레이션으로 풀었을 때 시간초과가 났을 때 의심한 것은 문자열을 계속 자르고 새로 만들고 중간에 pop, insert 하는 과정이다.<br />문자열의 크기가 100,000 정도로 매우 커서 조심해야 한다.<br />커서를 중간에 두고 스택을 2 개로 펼쳐서 왔다갔다 하는 방식을 쓴다.<br />이 아이디어에 착안하기 쉽지 않다.<br />커서의 움직임에 따라 총 횟수만큼 pop, push 만 해주면 된다.<br />pop, push 는 빠른 연산이므로 충분히 소화가능하다.<br />끝점과 처음점만 조작을 하도록 어떻게든 자료구조를 짜맞추는 연습을 한다면 아이디어 착안이 쉬워질듯 하다.</li>
</ul>
<pre class="vim"><code>tc = int(input())

for _ in range(tc):
    log = input()
    pw = []
    stack_left = []        # 왼쪽 스택
    stack_right = []    # 오른쪽 스택

    for c in log:
        if c == '&lt;':            # 왼쪽으로 커서 이동하면 왼쪽 스택에서 하나 빼서 오른쪽 스택에 넣는다.
            if len(stack_left) &gt; 0:
                stack_right.append(stack_left.pop())
        elif c == '&gt;':            # 오른쪽으로 커서 이동하면 오른쪽에서 하나 빼서 왼쪽 스택에 넣는다.
            if len(stack_right) &gt; 0:
                stack_left.append(stack_right.pop())
        elif c == '-':            # 삭제라면 왼쪽 스택에서 하나 뺀다.
            if len(stack_left) &gt; 0:
                stack_left.pop()
        else:                    # 문자면 왼쪽 스택에 하나 넣는다.
            stack_left.append(c)

    print(''.join(stack_left) + ''.join(stack_right[::-1]))</code></pre>