<h2>출처</h2>
<p>프로그래머스</p>
<h2>난이도</h2>
<p>프로그래머스 level 2, 2018 카카오 블라인드 채용 문제</p>
<h2>유형</h2>
<p>조합<br>구현</p>
<h2>특이사항</h2>
<p>까다로운 구현<br>여러 단계로 나누어진 로직<br>서브 루틴 작성의 압박</p>
<h2>총평</h2>
<p>항상 문제의 마지막 단계에서 애를 먹는다.<br>단순히 난이도라고 생각하는 대신, 이 지점에서의 문제점을 분석하고 다음번에는 어려움을 겪지 않도록 똑띠 머리 속에 박아두어야 함.<br>이 문제에서 이슈는 마지막이다.<br>다른 때에 풀었으면 또 달랐을 수도 있지만 이 문제를 처음 풀 때는, 미리 구해진 후보키의 리스트에 다음 후보키의 후보를 체크하는 로직이었다.<br>아이디어는 간단한데, set 에 리스트가 적용되지 않은 것을 알고 나서 직접 구현하기 위해 사고시간이 더욱 길어졌다.<br>문제의 막바지 단계에서 시간은 제법 흘러서 마음이 급하고, 정신력이 약간 소모되어서 실수에 취약해진다.<br>이 단계까지 능하게 도달할 수 있는 것이 곧 실력이고 여기에 닿지 못한 자는 틀릴 확률이 높아지게 되는 것이 당연하다.<br>지금 적으면서 생각하니 이 마지막 단계 로직은 이것만 떼어놓고 보면 어렵지 않다.<br>적당히 복잡하며, 약간의 계획만 있으면 금방 작성할 수 있다.<br>그러나 아직까지 지구력이 조금 부족하여 이 마지막 단계에서 정신력이 떨어지고 그 이후에 쭈욱 나락으로 떨어진다.<br>그러므로 결국 결론은 기본기, 기초 지구력의 문제다.<br>코드는 지구력에서 나온다.<br>문제를 많이 푸는 이유는 지구력 향상을 위함이다.<br>결국 풀긴 풀었으나 마지막 부분에서 시간을 70 퍼 이상을 소모하여 2 시간 가까이 소요됨.<br>포기할고 다음에 풀까 했지만 정상이 보이는 상황에서 그만둘 수 없었음.</p>
<pre><code>from itertools import combinations

def is_key(final_candid, cur_cand):
    for fin in final_candid:
        cand_copy = list(fin).copy()
        for i in cur_cand:
            if i in cand_copy:
                cand_copy.remove(i)

        if len(cand_copy) == 0:
            return False
        else:
            continue
    return True

def solution(relation):
    answer = 0
    keys = [i for i in range(len(relation[0]))]
    candid = []
    final_candid = []

    # 후보키들의 후보를 선정
    for i in range(1, len(relation) + 1):
        combi = combinations(keys, i)

        for com in combi:
            pool = []
            for idx, r in enumerate(relation):
                item = [r[c] for c in com]
                #print(pool)
                if item not in pool:
                    pool.append(item)
                else:
                    #print(&#39;중복! - &#39;, item)
                    break

                if idx == len(relation) - 1:
                    candid.append(com)

    # 후보 키 고르기
    # 첫 후보가 현재 후보키로 설정됨.
    cur_idx = 0
    cur_candid = candid[cur_idx]
    final_candid.append(cur_candid)

    # 모든 가능한 후보키들의 후보
    for cand in candid[1:]:
        if is_key(final_candid, cand):
            final_candid.append(cand)

    answer += 1
    answer = len(final_candid)
    return answer</code></pre>