<h1>문자열 매칭 알고리즘</h1>
<h2>단순 매칭</h2>
<ul>
<li>개념<br>문자열에서 원하는 패턴을 찾아내는 알고리즘<br>모든 경우를 다 탐색한다.</li>
<li>비고<br>무식하게 반복하므로 시간 복잡도는 $O(NM)$ 이다.<br>N 은 문자열, M 은 패턴</li>
</ul>
<pre><code># 단순 문자열 매칭 알고리즘
total_s = &#39;asdfgh&#39;
s = &#39;df&#39;

find = False
for i in range(len(total_s)):
    for j in range(len(s)):
        if i + j &lt; len(total_s):
            break
        if and total_s[i+j] != s[j]:
            break
        elif j == len(s)-1:
            find = True
</code></pre><h2>KMP 알고리즘</h2>
<ul>
<li>개념<br>단순 매칭 알고리즘을 개선한 것이다.<br>중복되는 정보를 이용하여 한 칸씩이 아닌 여러칸을 건너뛰는 전략을 이용.<br>이를 접두사 접미사를 이용하여 구현한다.</li>
<li>비고<br>시간 복잡도는 $O(N+M)$<br>실패 함수로 얻는 p table 이 중요한 개념이다.<br>p table 의 값은 인덱스이면서 접두사/접미사 공통 길이에 해당한다.<br>인덱스 2 개를 두고 한 문자씩 확인하는 방식이다.<br>주의할 것은, <code>p[i]</code> 의 길이는 문자열 길이보다는 작아야 한다.</li>
</ul>
<pre><code># KMP 
# 실패 함수
def get_p(s):
    # prefix 와 suffix 가 일치하는 최대 길이정보를 가지는 p table 을 반환한다.
    # j 는 길이이면서, 인덱스 번호이기도 하다!
    j = 0
    p_table = [0] * len(s)
    # 한 글자씩 확인하며 테이블에 길이만 채운다.
    for i in range(1, len(s)):
        # 불일치하면 j 옮겨주기
        while j &gt; 0 and s[i] != s[j]:
            j = p_table[j-1]

        if s[i] == s[j]:
            j += 1
            p_table[i] = j
    return p_table
get_p(&#39;aaaabd&#39;)


def KMP(h, s):
    table = get_p(s)
    print(table)
    j = 0
    for i in range(len(h)):
        # 불일치 발생 시 s 의 비교 인덱스를 옮겨준다.
        while j &gt; 0 and h[i] != s[j]:
            print(i,j)
            j = table[j-1]

        if h[i] == s[j]:
            if j == len(s)-1:
                print(&#39;find&#39;, i-len(s)+1)
                j = table[j]

            else:
                j += 1

KMP(&#39;ababacsabababc&#39;, &#39;abacbc&#39;)</code></pre><h2>Rabin-Karp 알고리즘</h2>
<ul>
<li>개념<br>문자열을 해싱하여 그 해시값을 비교하며 일치여부를 확인하는 알고리즘이다.</li>
<li>비고<br>문자열을 아스키 코드 등으로 바꾸어 자릿수마다 2 의 제곱을 하여 총합을 하면 그것은 거의 유일한 값으로 해시값으로 사용할 수 있는데 이것을 이용한다.<br>여러개의 문자를 하나의 해시값으로 대표하므로 하나씩 비교하지 않아 빠르다.$O(N)$<br>문자열은 연속되므로 매 스텝마다 맨 처음 문자, 맨 끝 문자만 조작해주면 해쉬 조작이 용이하다.<br>해쉬 기법은 탐색 등에 잘 활용된다.<br>해쉬 충돌날수도 있는데, 이를 해결하는 내용에 대한 포스팅 <a href="https://www.secmem.org/blog/2019/12/15/RabinKarpCollision/">해쉬 충돌 해결 -링크-</a></li>
</ul>
<pre><code># Rabin-Karp
def rabin_karp(h, s):
    # 해쉬 초기화
    hash_h = sum([ord(c)* 2**(len(s)-p-1) for p, c in enumerate(h[:len(s)])])
    hash_s = sum([ord(c)* 2**(len(s)-p-1) for p, c in enumerate(s)])
    power = 2 ** (len(s)-1)

    for i in range(len(h)-len(s)):        
        # 해쉬값이 같을 때 해쉬 충돌인지 아닌지 체크하여 일치여부 판단
        if hash_h == hash_s:
            find = True
            for j in range(len(s)):
                if h[i+j] != s[j]:
                    find = False
                    break
            if find:
                print(&#39;발견&#39;, i)

        # 해쉬 조작        
        hash_h = 2 * (hash_h - ord(h[i]) * power) + ord(h[i+len(s)])

rabin_karp(&#39;asssavsdadssava&#39;,&#39;sav&#39;)</code></pre>