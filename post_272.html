<h2>[4 장] - 컴퓨터 구조 접근방법</h2>
<h2>컴퓨터 디자인</h2>
<ul>
<li>프로그래머 관점<ul>
<li>컴퓨터 디자인은 <code>레지스터</code>와 <code>명령어</code> 디자인이 메인.</li>
<li>당연히 컴파일러도 함께 만들어야 한다.</li>
<li>CPU 자체의 표준은 없으므로 각자 디자인 가능.</li>
</ul>
</li>
<li>레지스터 디자인의 핵심<ol>
<li>레지스터는 몇 비트? - 보통 컴퓨터 비트와 통일시킨다.</li>
<li>레지스터는 몇 개? - 많을수록 좋긴 함.</li>
<li>레지스터 각각 무슨 용도로 사용? - ir, sp, lr, pc 등 특수 목적성 필요. </li>
</ol>
<ul>
<li>RAM, 디스크는 범용적이다.</li>
<li>레지스터 용도를 정해두면 처리속도가 빨라지고 명령어가 단순해짐.</li>
<li>ARM 은 핸드폰용 CPU 아키텍처.</li>
<li>특수 레지스터 이외에 일반 값 저장 레지스터 필요.</li>
</ul>
</li>
</ul>
<h2>명령어 구조 및 명령어 디자인</h2>
<ul>
<li>CPU 비트와 명령어의 비트 사이즈도 동일하게 셋팅하는것이 좋음.<ul>
<li>물론 레지스터의 크기도 동일하게.</li>
</ul>
</li>
<li>명령어는 연산을 위한 정보가 모두 담긴다.<ul>
<li>예약 비트 들</li>
<li>연산자 비트 - 결국 2 진수로 인코딩</li>
<li>저장소 비트 - 연산의 결과를 저장하는 곳. 보통 레지스터</li>
<li>피연산자들 비트 - 레지스터 혹은 숫자</li>
</ul>
</li>
<li>CISK - Complex<ul>
<li>명령어가 복잡한 구조</li>
<li>명령어 조합을 한다.</li>
</ul>
</li>
<li>RISK - Reduce<ul>
<li>명령어가 단순한 구조</li>
<li>F, D, E 한 클럭에 끝내서 연산속도가 빠르다.</li>
<li>파이프를 적용할 수 있다.</li>
<li>명령어 설계에 제약 사항이 뒤따른다.</li>
</ul>
</li>
</ul>
<h2>LOAD, STORE 명령어</h2>
<ul>
<li>LOAD<ul>
<li>명령어를 구성하기 위해 메모리에서 레지스터에서 꺼내온다.</li>
<li>LOAD dst src</li>
<li>LOAD r1, adress</li>
</ul>
</li>
<li>STORE<ul>
<li>연산결과를 레지스터에서 메모리로 옮겨 저장한다.</li>
<li>STORE src dst</li>
<li>STORE r1, adress</li>
</ul>
</li>
</ul>
<h2>LOAD, STORE 명렁어의 필요성</h2>
<ul>
<li>명령어의 제한 때문임. (RISK)<ul>
<li>명령어 피연산자에 메모리 주소를 접근할 수 없음.</li>
<li>피 연산자는 숫자 혹은 레지스터</li>
<li>명령어 단순화를 위한 어쩔 수 없는 요소.</li>
</ul>
</li>
<li>레지스터를 통해 모든 연산을 진행하기 위함임!</li>
</ul>
<h2>Direct 모드,  Indirect 모드</h2>
<ul>
<li>메모리 주소를 참조하는데 직접적이냐 간접적이냐</li>
<li>명령어에 주소 가리키는 데 할당된 비트가 적으면 direct 모드로는 불가능.</li>
<li>indirect 모드는 명령어에서 접근할 수 없는 메모리 주소를 2 중 과정을 거쳐 접근하게 한다.<ul>
<li>포인터의 개념이 쓰이는듯?</li>
<li>메모리에 어떠한 메모리의 주소를 저장한 후 그것을 통해 원래 값에 접근한다.</li>
</ul>
</li>
</ul>
