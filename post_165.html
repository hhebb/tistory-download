<h1>13 강</h1>
<h2>I/O</h2>
<ul>
<li>I/O mechanism</li>
<li>I.O services of OS</li>
<li>Dist Scheduling</li>
<li>RAID Architecture</li>
</ul>
<h2>I/O system (HW)</h2>
<ul>
<li>필요한 데이터는 결국 장치로부터 메모리에 저장되어 프로세서가 가져다 쓴다.</li>
<li>프로세서를 통해 I/O 가 메모리에 저장되고 그 데이터를 프로세서가 다시 사용한다?<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@NFZIf/btqMegXmT9t/adFA6eKsH8f6kQRGwhd9p1/img.png" ><p class="cap1">width="602" height="269" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>I/O 메커니즘</h2>
<ul>
<li>processor controlled memory access<br />polling<br />interrupt</li>
<li>direct memory access (DMA)</li>
</ul>
<h2>Polling (programmed I/O)</h2>
<ul>
<li>processor 가 주기적으로 I/O 장치의 상태 확인<br />모든 I/O 장치를 순환하며 확인<br />전송 준비 및 전송 상태</li>
<li>장점<br />단순하다.<br />I/O 장치가 빠르고 데이터 전송이 잦은 경우 효율적임.</li>
<li>단점<br />계속 일을 하기 때문에 때문에 프로세서의 부담이 크다.<br />I/O 장치가 느리면 오버헤드가 생긴다.</li>
</ul>
<h2>Interrupt</h2>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@J7JW9/btqMeFWUV7n/3jbWWawLhyUcHRgthqHttK/img.png" ><p class="cap1">width="495" height="108" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<ul>
<li>I/O 장치가 작업을 완료한 후 자신의 상태를 프로세서에게 전달<br />인터럽트 발생 시, 프로세서는 데이터 전송 수행</li>
<li>장점<br />polling 대비 오버헤드가 작다.<br />불규칙적인 요청처리에 적합.</li>
<li>단점<br />인터럽트 핸들링 오버헤드가 있음. 요청이 많을 때.</li>
</ul>
<h2>DMA</h2>
<ul>
<li>processor controlled memory access 방법<br />프로세서가 모든 데이터 전송을 처리해야 하는 단점이 있다.<br />매번 프로세서가 입출력 모듈과 통신해야 한다.<br />프로세서에게 오버헤드가 된다.</li>
<li>DMA<br />I/O 장치와 메모리 사이의 데이터 전송을 프로세서의 개입없이 수행.<br />프로세서의 오버헤드가 줄어든다.<br />메모리가 입출력 모듈과 직접 연결되어 프로세서를 경유하지 않을 수 있다.<br />제어기를 추가로 두어야 한다.<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@IT2ZE/btqMdjADQpk/rjk7WQeXu0pCAwKTFwqX1k/img.png" ><p class="cap1">width="602" height="207" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>DMA 작동</h2>
<ul>
<li>프로세서는 데이터 전송의 시작/종료만 관여<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://kage.tistory.com/image/2" ><p class="cap1">width="602" height="405" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>I/O services of OS</h2>
<p>커널 안에 입출력 서브시스템이 있음.</p>
<ul>
<li>I/O scheduling<br />입출력 요청에 대한 처리 순서를 결정<br />시스템의 전반적인 성능 향상<br />프로세서의 요구에 대한 공평한 처리<br />disk I/O 스케쥴링 등.</li>
<li>error handling<br />입출력 중 발생하는 오류 처리<br />disk access fail, 네트워크 통신 에러 등.</li>
<li>I/O 장치 정보 관리</li>
<li>Buffering<br />I/O 장치와 프로그램 사이에 전송되는 데이터를 버퍼에 임시 저장.<br />전송 속도(or 처리 단위) 차이 문제를 해결한다.<br />영상 같은 데이터가 버벅이는 현상과 유사함.<br />버퍼에 데이터를 모으는 중일수도 있다.<br /><br /></li>
<li>Caching<br />자주 사용하는 데이터를 미리 복사해 둠.<br />캐시 hit 할 때 I/O 를 생략할 수 있음.<br />원래는 HW 이지만 SW 구현도 가능하다.<br />버퍼링과 다른 점은 자주 사용할것 같은 것을 예상하는 효과임.</li>
<li>Spooling<br />한 I/O 장치에 여러 프로그램이 요청을 보낼 시 출력이 섞이지 않도록 하는 기법.<br />각 프로그램에 대응하는 disk file 에 기록.<br />스풀링이 완료되면 스풀을 한 번에 하나씩 I/O 장치로 전송.</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@yGCfU/btqMdVlCfRU/oWwCR7MUKdbTygsTj4hXD0/img.png" ><p class="cap1">width="515" height="316" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>DIsk Scheduling</h2>
<ul>
<li>Disk access 요청들의 처리 순서를 결정</li>
<li>Disk system 의 성능을 향상 - 모든 스케쥴링은 성능과 연관이 있음.</li>
<li>평가 기준<br />throughput - 단위 시간 당 처리량<br />mean response time - 평균 응답 시간<br />predictability - 응답 시간의 예측성, 요청이 무기한 연기(starvation)되지 안도록 방지</li>
</ul>
<h2>Disk Scheduling</h2>
<ul>
<li>seek time</li>
<li>rotational delay</li>
<li>data transmission time</li>
</ul>
<h2>Disk Scheduling</h2>
<ul>
<li>seek time 을 최적화하는 방법<br />FCFS<br />SSTF<br />Scan<br />C Scan<br />Look</li>
</ul>
<h2>FCFS (First Come First Service)</h2>
<ul>
<li>요청이 도착한 순서에 따라 처리</li>
<li>장점<br />단순하다 - 스케쥴링 오버헤드가 적다.<br />공평한 처리 기법</li>
<li>단점<br />최적의 성능 달성에 대한 고려가 없는 방식이다.</li>
<li>Disk access 부하가 적은 경우에 적합하다.</li>
</ul>
<h2>SSTF (Shortest Seek Time First)</h2>
<ul>
<li>현재 head 위치에서 가장 가까운 욫어 먼저 처리</li>
<li>장점<br />이동거리가 줄어든다<br />throughput 크다.<br />평균 응답 시간이 짧다.</li>
<li>단점<br />predictability 이 적다 - 헤드로부터 멀리 떨어진 요청은 언제 서비스받을지 모른다.<br />평균 응답은 짧지만 특정 작업은 응답이 매우 늦을 수 있다.<br />starvation 현상 발생이 가능</li>
<li>일괄처리 시스템에 적합.<br />throughput 이 커야하는 시스템.</li>
</ul>
<h2>Scan Scheduling</h2>
<ul>
<li>현재 head 의 진행 방향에서 head 와 가장 가까운 요청 먼저 처리.</li>
<li>진행방향 기준 마지막 실린더에 도착 후 반대 방향으로 진행</li>
<li>장점<br />SSTF 의 starvation 문제 해결<br />어쨌든 가까운 요청을 처리하므로 throughput 이 높다.</li>
<li>단점<br />진행 방향 반대쪽 끝의 요청들의 응답시간이 길어질 수 있다.<br />가까운데도 방향이 반대라고 처리가 늦어질 수 있다는 의미.</li>
</ul>
<h2>C-Scan Scheduling</h2>
<ul>
<li>SCAN 과 유사</li>
<li>head 가 미리 정해진 방향으로만 이동<br />마지막 실린더에 도착 후 시작 실린더로 이동하고 재시작</li>
<li>장점<br />CAN 대비 균등한 기회 제공</li>
</ul>
<h2>Look Scheduling</h2>
<ul>
<li>혹은 엘리베이터 알고리즘이라고도 한다.</li>
<li>Scan 에서 현재 진행 방향에 요청이 없으면 방향 전환<br />마지막 실린더 까지 이동하지 않음<br />Scan(C-Scan) 의 실제 구현 방법</li>
<li>장점<br />Scan 의 불필요한 head 이동 제거</li>
</ul>
<h2>Disk Scheduling</h2>
<ul>
<li>회전 딜레이를 최적화하는 방법</li>
</ul>
<h2>SLTF - Shortest latency Time First</h2>
<ul>
<li>fixed head disk 시스템에 사용<br />각 track 마다 head 를 가진 디스크<br />아예 하드웨어적으로 헤드가 고정되어 있는 시스템임.</li>
<li>sector queuing algorithm<br />각 섹터 별 큐 유지.<br />head 아래 도착한 sector 의 queue 에 있는 요청을 먼저 처리함.</li>
<li>moving head disk 의 경우에도 사용 가능.<br />head 가 특정 실린더에 도착하면 고정 후 해당 실린더의 요청을 모두 처리</li>
</ul>
<h2>SPTF - Shortest Positioning Time First</h2>
<ul>
<li>positioning time = seek time + rotational delay</li>
<li>positioning time 이 가장 작은 요청 먼저 처리</li>
<li>장점<br />throughput 은 올라가고 평균 응답 시간은 줄어든다.</li>
<li>단점<br />가장 안쪽가 바깥쪽 실린더의 요청에 대해 starvation 현상 발생 가능</li>
</ul>
<h2>Eschenbach 스케줄링</h2>
<ul>
<li>SPTF 알고리즘의 하나</li>
<li>positioning time 최적화</li>
<li>disk 가 1 회전하는 동안 요청을 처리할 수 있도록 요청을 정렬해놓는다.</li>
<li>요청들이 랜덤으로 분산되어 있으면 헤드이동시간 + 디스크 회전시간이 적어진다.</li>
<li>하지만 한 실린더 안에 다수의 요청이 있으면 오히려 성능이 떨어진다.</li>
</ul>
<h2>RAID Architecture</h2>
<ul>
<li>디스크 시스템의 성능과 신뢰성을 높이는 방법 중 하나</li>
</ul>
<h2>RAID</h2>
<ul>
<li>Redundant Array of Inexpensive Disks</li>
<li>여러개의 물리 디스클르 하나의 논리 disk 로 사용<br />OS support, raid controller</li>
<li>disk system 의 성능 향상을 위해 사용<br />performance - access speed<br />reliability</li>
</ul>
<h2>RAID 0</h2>
<ul>
<li>disk striping<br />논리적인 한 블럭을 일정한 크기로 나누어 각 disk 에 나누어 저장</li>
<li>모든 disk 에 입출력 부하 균등 분배<br />parallel access 병렬 처리로 빠른 속도<br />performance 향상</li>
<li>한 디스크에서 장애 시 데이터 손실 발생<br />low reliability</li>
</ul>
<h2>RAID 1</h2>
<ul>
<li>Disk mirroring<br />동일한 데이터를 미러링 디스크에 중복 저장</li>
<li>최소 2 개의 disk 로 구성<br />입출력은 둘 중 어느 disk 에서도 가능</li>
<li>한 disk 에 장애가 생겨도 데이터 손실이 없다.<br />reliability 확보</li>
<li>가용 disk 용량은 전체 디스크 용량의 절반이 된다.</li>
</ul>
<h2>RAID 3</h2>
<ul>
<li>RAID 0 + parity disk<br />byte 단위 분할 저장<br />모든 disk 에 입출력 부하 균등 분배 - parallel access, performance 향상</li>
<li>한 disk 에 장애 발생 시 패리티 정보를 이용하여 복구<br />reliability 어느정도 확보</li>
<li>write 시 패리티 계산 필요<br />오버헤드가 발생. - 패리티를 계산해서 패리티 디스크에 저장해야 하기때문<br />write 가 몰릴 시, 병목현상 발생 가능</li>
</ul>
<h2>RAID 4</h2>
<ul>
<li>RAID 3 와 유사 단 블럭 단위로 분산 저장<br />독립된 access 방법<br />disk 간 균등 분배가 안될 수도 있음</li>
<li>병목 현상으로 성능 저하가 가능함.<br />한 디스크에 입출력이 몰릴 때</li>
</ul>
<h2>RAID 5</h2>
<ul>
<li>RAID 4 와 유사함.<br />독립된 access 방법</li>
<li>parity 정보를 각 disk 들에 분산 저장<br />패리티 디스크의 병목현상 문제 해소<br /><br /></li>
<li>현재 가장 널리 사용되는 RAID level 중 하나.<br />높은 성능과 신뢰성을 확보.</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@o0jMW/btqMcSJUZhM/oR43Oa9NkoZq0b2hb0XqK1/img.png" ><p class="cap1">width="602" height="192" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<p>&nbsp;</p>