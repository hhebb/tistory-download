<h1>자료구조</h1>
<p>현실의 문제, 가상의 개념을 알고리즘에서 돌릴 수 있도록 만든 구조화된 데이터 구조.<br>풀고자 하는 문제의 특성에 따라 선택해야하는 자료구조가 다르다.<br>자료구조에 따라 알고리즘의 성능이 달라진다.</p>
<h3>대표적인 자료구조</h3>
<p>배열, 스택, 큐, 링크드 리스트, 해쉬, 힙</p>
<h1>알고리즘</h1>
<p>어떤 문제를 풀기 위한 절차/방법<br>어떤 문제에 대해, 입력을 넣으면 출력을 얻을 수 있도록 만드는 프로그래밍</p>
<h3>자구알의 중요성</h3>
<p>어떤 자료구조와 알고리즘을 쓰느냐가 성능이 크게 차이난다.<br>결국 프로그래머로서 개발력의 척도이며 실제로 매일 쓰게될 것들이고 역량이며, 검증할 수 있는 척도</p>
<h1>배열</h1>
<h3>배열의 장점</h3>
<p>빠른 접근 가능</p>
<h3>배열의 단점</h3>
<p>추가, 삭제가 오래걸림(땡기고 새로 만들기 때문)<br>그러나 파이썬은 리스트.</p>
<h1>큐</h1>
<h3>큐 특징</h3>
<p>FIFO 정책, 가장 먼저 넣은 것을 가장 먼저 꺼낸다.<br>줄을 서는 행위와 비슷<br>인덱스 접근이 필요없음.<br>순서대로 넣고 꺼내기만 한다.</p>
<h3>우선순위 큐 - 힙</h3>
<p>데이터를 넣는 순서가 아닌 우선순위에 따라 꺼낸다.</p>
<h3>큐의 쓰임</h3>
<p>멀티태스킹을 위한 프로세스 스케쥴링 방식을 구현하는데 많이 쓰임.<br>장단점은 딱히 없다.</p>
<h1>스택</h1>
<h3>스택 특징</h3>
<p>LIFO 정책<br>가장 나중에 넣은 데이터를 가장 먼저 빼는 구조</p>
<h3>스택의 쓰임</h3>
<p>컴퓨터 내부 프로세스 구조의 함수 동작 방식에 쓰임<br>재귀함수 자체가 함수 스택을 쌓는 것임.<br>재귀함수를 대체할 수 있다.</p>
<h3>스택의 장점</h3>
<p>구조가 단순, 구현이 쉬움.<br>데이터 저장/읽기가 빠르다.</p>
<h3>스택의 단점</h3>
<p>스택은 단순하고 빠른 성능을 위해 사용되어서 배열구조로 구현하는 경우가 많음. (일반적으로)<br>그래서 데이터 최대 갯수 미리 지정하는 점, 저장 공간 낭비가 생기는 점이 단점으로 작용할 수 있다.<br>단, 링크드 리스트로 하면 단전이 아님</p>
<h1>링크드 리스트(연결 리스트)</h1>
<h3>링크드 리스트 특징</h3>
<p>구조는 복잡하진 않지만, 사람이 구현하기가 헷갈리거나 어려움.<br>면접에서 손코딩에 자주 나옴.<br>배열과 다르게, 포인터를 이용해 연결함.<br>배열은 고정된 공간을 미리 할당해야하지만, 연결 리스트는 필요할때마다 노드를 연결한다.</p>
<h3>연결 리스트 구현</h3>
<p>노드, 포인터<br>노드 = 데이터 + 포인터<br>포인터는 다음 노드의 주소값<br>Node 를 클래스로 만드는 것이 기본<br>head 노드를 설정하고 각 노드를 순차적으로 찾는것이 기본적인 로직</p>
<h3>연결 리스트의 장점</h3>
<p>배열처럼 미리 데이터 공간을 할당할 필요 없음<br>데이터 삭제 제거에 빠름</p>
<h3>연결 리스트의 단점</h3>
<p>연결을 위한 별도 데이터 공간이 필요해서 저장공간 효율이 좋지 않음.<br>연결 정보를 찾는 시간 때문에 탐색(접근) 이 느림.<br>배열은 인덱스로 찾는다.<br>삭제 제거에 작업이 필요.</p>
<h1>이중 연결 리스트</h1>
<p>이중 연결 리스트<br>head, tail 있음.<br>구현할 줄 아는 게 좋음?</p>
<h1>시간복잡도</h1>
<p>사실 문제 풀 때 젤 중요한 것 중 하나임.<br>알고리즘 문제는 정답이 없고 해결법이 여러가지임. 수학문제와도 동일한 점임.<br>가장 빠르게 푸는것이 가장 좋은것이고 테스트도 이를 기준으로 출제된다.<br>시간이 허용되는 정도에 따라 선택해야하는 알고리즘, 전략이 달라지기 때문에 가장 중요함.<br>시간은 반복문에 의해 지배되고 입력의 최대값을 대입하여 계산한다.<br>최악의 실행시간인 빅오 표기법을 기준으로 접근하면 된다.<br>문제를 낼 때 대부분은 빅오 기준으로 출제하므로 여기에 맞추면 된다.<br>프로그래머로서 알고리즘을 작성할 때 생각해야 하는 기본적인 요소다.<br>방법을 바꾸면 시간이 획기적으로 혹은 약간이라도 줄어든다.<br>반복문을 없애든, 몇단계 건너뛰든 빠르게 하는 방법만 찾는다.</p>
<h1>해쉬테이블</h1>
<h3>해쉬 특징</h3>
<p>key value 로 자료를 저장하는 자료구조<br>파이썬에는 딕셔너리, c++ 에서는 map 에 해당한다.<br>상당히 많이 쓰이는 자료구조 중 하나임.<br>검색에서 해쉬는 무엇보다 좋음. 리스트와 다르게 key 를 기준으로 찾아버린다. 즉 선형 자료구조가 아님.<br>그래서 상당히 빠르다.<br>저장할 땐 key, value 쌍으로 저장하고 불러올 떈 key 를 이용해 value 를 리턴<br>주로 배열로 구현할 땐, 공간을 탐색시간과 트레이트 오프 하는 것임.</p>
<h3>해쉬 용어</h3>
<p>해쉬 - 임의의 입력값을 고정 길이로 변환하는 것.<br>해쉬 테이블 - 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조<br>해싱 함수 - key 에 대해 연산을 이용해 데이터 위치를 찾을 수 있는 함수.<br>해쉬 값 / 해쉬 주소 - key 를 해싱 함수로 연산해서 나오는 값으로, 해쉬 테이블에 있는 데이터에 접근가능.</p>
<h3>해쉬 테이블의 장점</h3>
<p>데이터 저장/읽기가 매우 빠르다. - 검색, 추가<br>키 중복이 굉장히 쉬움 - 테이블에 값이 있는지만 체크하면 됨.</p>
<h3>해쉬 단점</h3>
<p>저장공간이 조금 더 필요하다.<br>복수의 키에 대한 해쉬주소가 중복되면 중복 해결을 해주어야 함.</p>
<h3>해쉬 용도</h3>
<p>검색에 좋음.<br>저장/삭제/읽기가 빈번한 경우.<br>캐쉬 구현시 - 중복 확인이 쉽기 때문.</p>
<h3>해쉬 충돌 해결 알고리즘</h3>
<p>개방 해싱 - 해쉬 충돌 시 추가적인 저장공간을 할당. 체이닝. 테이블의 원소를 리스트로 만들고 계속 추가하면됨.<br>폐쇄 해싱 - 충돌 시 충돌지점 이후의 사용되지 않은 테이블에 값을 넣는다. 저장공간을 아낄 수 있다.</p>
<h3>기타 해쉬 함수</h3>
<p>key 를 넣어 해쉬값을 반환하는 함수<br>SHA 256 알고리즘. hashlib 라이브러리 있음. 고정된 hex 해쉬값을 반환</p>
<h3>해쉬의 시간복잡도</h3>
<p>일반적으로 O(1)<br>최악의 경우, 모두 충돌할 때 O(N)</p>
<h1>트리 구조</h1>
<h3>트리</h3>
<p>면접에서 트리 많이 물어보기도 함. 취업이든 실무든 중요한 자료구조이다.<br>node 와 branch 를 이용해 사이클을 이루지 않도록 구성한 데이터 구조.<br>이진 트리 형태의 구조로 탐색 알고리즘을 위해 많이 사용.<br>이외에도 다른 알고리즘에 많이 사용</p>
<h3>트리 용어</h3>
<p>node - 데이터를 저장하는 공간. 자식에게 닿는 branch 를 가짐<br>root node<br>leaf<br>parent<br>child<br>sibling<br>depth</p>
<h1>이진 트리, 이진 탐색 트리</h1>
<p>이진트리는 노드의 가지가 최대 2 인 트리<br>이진 탐색 트리는 BST 라고 쓰기도 한다.<br>이진트리의 특수한 형태.</p>
<h1>BST</h1>
<p>데이터를 트리에 저장해놓고 트리를 타며 값을 비교한다.<br>정렬된 배열에 비해 탐색속도가 매우 빠르다(O(log))</p>
<h3>구현</h3>
<p>링크드 리스트 기반으로 만든다.<br>node 를 만들고 그것을 기반으로 논리적으로 트리구조를 만든다.</p>
<h3>BST 트리 삭제</h3>
<p>복잡함.<br>삭제할 노드가 leaf node 일 때 - 단순히 그 노드만 삭제하고 부모의 branch 를 초기화 해야함.<br>삭제할 노드가 자식이 하나만 있을 때 - 노드를 삭제하기 전 남겨진 자식 노드를 부모 노드와 연결시키고 삭제해야 함.<br>삭제할 노드가 자식이 두 개 있을 때 - 삭제할 노드의 오른쪽 자식 중 가장 작은 leaf 값을 위로 올림.<br>혹은 삭제할 노드의 왼쪽 자식 중 가장 큰 leaf 를 위로 올림.<br>삭제할 데이터가 있는지 없는지 먼저 체크. 이 때 parent 도 함께 갱신하는것이 추가 작업이 필요없어 효율적이다.</p>
<h3>BST 시간 복잡도, 단점</h3>
<p>탐색 시 - depth 가 h 이면 O(h), O(logN)<br>이는 균형잡혀 있을 때.<br>최악의 경우엔 리스트와 다를바가 없다.<br>정렬된 데이터를 하나씩 트리에 추가하면 리스트와 동일한 효율이 나옴.</p>
<h1>힙(우선순위 큐)</h1>
<p>최대값과 최소값을 빠르게 찾기 위해 만들어진 완전 이진 트리. 트리의 변형</p>
<h3>힙을 쓰는 이유</h3>
<p>배열에서 최대값을 찾으려면 O(N)<br>힙에 넣으면 O(logN)<br>최대값과 최소값을 빠르게 찾아야 하는 경우에 사용해야함</p>
<h3>힙 구조</h3>
<p>최대힙, 최소힙<br>각 노드는 자식보다 크거나 같다(최대힙)<br>완전 이진 트리 형태다.</p>
<h3>힙과 BST 비교</h3>
<p>힙은 각 노드가 자식보다 크거나 같음<br>BST 는 각 노드가 왼쪽 자식보다 크고 오른쪽 자식보다 작은 규칙이 있다.<br>BST 는 탐색 목적, 힙은 최대/최소값 찾는 목적의 구조임.</p>
<h3>힙 구현</h3>
<p>삽입 시(push) - 일단 완전 이진 트리 형태를 맞춰서 집어넣는다. 그리고 크기에 따라 노드를 교체해준다.<br>제거 시(pop) - 루트 노드를 삭제한다. 마지막 노드를 루트를 올리고 크기에 따라 하나씩 교체한다.<br>균형이 잡혀있어서 순서가 있음. 즉 리스트나 배열로 표현가능함.<br>완전 이진 트리는 인덱스 계산이 가능하다.</p>
<h3>힙 시간복잡도</h3>
<p>데이터 삭제 및 삽입 시 최악의 경우 O(logN)</p>
