<h1>JS</h1>
<h2>변수 선언</h2>
<p>let - 재선언 불가, block scope<br>var - 모두 허용, function scope<br>const - 재선언, 재할당 불가</p>
<h2>block scope</h2>
<p>{} 내에서 접근 가능<br>함수 스코프의 부분집합</p>
<h2>function scope</h2>
<p>함수 안에서 접근 가능</p>
<h2>자료형 종류</h2>
<p>string<br>number<br>boolean<br>array<br>object - 객체 그 자체<br>null<br>undefined - 할당되지 않은 변수</p>
<h2>object</h2>
<p>{} 를 이용해 만든다.<br>멤버 추가할 때 obj[&#39;prop&#39;] = 1, obj.prop = 1 등으로 할당할 수 있다.<br>그리고 접근할 때도 마찬가지로 [&#39;prop&#39;] 나 .prop 으로 접근가능하다.</p>
<h2>연산자</h2>
<p>=== - 동등<br>!== - 다름<br>!</p>
<h2>함수</h2>
<p>funcion 키워드<br>js 는 함수를 일급 객체로 다룬다.<br>즉 함수를 변수에 할당할 수 있다.<br>이 때는 익명 함수로 선언한다.</p>
<h2>이벤트</h2>
<p>웹에서 상호작용할 때 필요.<br>document.querySelector().onclick = 람다 함수</p>
<h2>문자열</h2>
<ul>
<li>연산 가능<br>문자열 + 숫자 도 자동 변환해줌</li>
</ul>
<h2>형변환</h2>
<p>Number 객체 - 문자열 수를 숫자 형으로 변환</p>
<h2>문자열 메서드</h2>
<p>length<br>인덱싱 <code>[]</code><br>indexOf(&#39;str&#39;)<br>slice(a,b), slice(a)<br>toLowerCase()<br>toUpperCase()</p>
<h2>배열</h2>
<p>인덱싱 가능<br>length 멤버로 크기 접근</p>
<h2>배열 메서드</h2>
<p>split() - 문자열 메서드에도 해당함<br>push(item), pop() - 맨 끝에서 동작<br>unshift(item), shift() - 맨 앞에서 동작<br>객체 삭제 메서드 delete - 주의할 것은 값은 사라지지만 빈 것으로 만들어 갯수는 유지된다.<br>splice(idx, 0, item) - 아이템을 idx 에 추가<br>splice(idx, n) - idx 부터 n 개 삭제<br>slice(from, to) - from 부터 to 까지 복사 반환. to 는 제외</p>
<h2>조건문</h2>
<p>if () {} else{}</p>
<h2>switch 문</h2>
<p>switch(){ case 1: break; defalut: break;}</p>
<h2>삼항 연산자</h2>
<p>( ) ? a : b</p>
<h2>반복문</h2>
<p>for(let i = 0; i &lt; 10; i ++){}<br>while(){}</p>
<h2>함수</h2>
<p>function name(){}</p>
<h2>익명함수</h2>
<p>function (){} - 주로 이벤트 핸들러로 사용<br>let tmp = function(){} - 변수에 익명 함수를 넣을 수 있다. 그리고 tmp() 로 호출할 수 있다. 하지만 헷갈리니 쓰지마</p>
<h2>오브젝트</h2>
<p>let obj = {} - 딕셔너리처럼 선언.<br>특이하게도 함수까지 포함한다.<br>객체 리터럴이라고도 하는데, 선언과 동시에 멤버에 값을 입힌다.<br>클래스로 생성하는 방식과 다르다.<br>오브젝트의 값을 갱신하거나 추가할 수도 있다.</p>
<h2>생성자 함수</h2>
<p>js 의 클래스에 해당.<br>주로 대문자로 시작한다.<br>this 키워드를 이용해서 자신 객체에 접근한다.</p>
<h2>객체 생성 다른 방법</h2>
<p>new Object() 로 빈 객체 생성 가능</p>
<h2>프로토타입</h2>
<p>상속시키려는 멤버를 저장한 객체<br>모든 객체는 상속을 받기 위한 프로토타입 객체를 가진다.<br>프로토타입 체인을 통해 상위의 상위로 가서 상속을 받는다.<br>funk.prototype.method 에 추가하면 상속받는 모든 객체에서 사용가능하다.<br>prototype 객체는 처음엔 빈 객체다.<br>객체 지향 언어로 쓰기 위해 도입한것임.</p>
<h2>생성자 속성</h2>
<p>모든 생성자 함수는 constructor 속성을 지닌 객체를 프로토타입 객체로 가진다.<br>생성자 속성은 그 객체를 참조할 수 있다.<br>생성자 자격이 부여되면 new 로 객체를 만들어낼 수 있다. 함수만 가능</p>
<h2>상속</h2>
<p>call()</p>
<h2>콜백 함수</h2>
<p>콜백함수를 인자로 받고 결과값을 콜백에 다시 전달<br>function add(a, b, callback){callback(result)}<br>add(1,1, function(res)){}</p>
<h2>콜백 함수 - 함수 리턴</h2>
<p>값이 아니라 함수를 콜백에 넣어준다.<br>함수안에 함수를 만들 수 있다.<br>위의 함수에 return 을 명시한다.</p>
<h2>클로저</h2>
<p>내부 함수가 외부 함수 멤버의 값을 유지하며 접근할 수 있다.<br>반환 받은 내부 함수는 외부 함수 내부의 값을 유지하며 변경할 수 있다.</p>
