<p>사실 닥치고 문제를 풀면서 얻어지는 감각이 진짜 실력이다.</p>
<p>문제도 안 풀면서 이렇다 저렇다 할 꺼리가 아니다.</p>
<p>하지만 이러한 유형들과 느끼는 점들을 한 번 짚고 가야만 할 것 같다.</p>
<p>유형 인지와 테크닉, 기본기에 대한 인사이트가 머리속에 정착하려면 풀이 외적으로 되새김과 되내임이 필요하다.</p>
<p>앞으로 이 포스트도 꾸준히 업데이트 할 예정이지만, 이 포스트는 비공개할 것이다.</p>
<p>개인적인 상념이 포함되므로.</p>
<p>물론 차후에 퀄리티가 괜찮아지고 내 개인적인 상념들이 빠지면 정리해서 업로드할 생각도 있다.</p>
<p>약간 PS 로직 치트노트라고 생각해도 좋을 듯 하다.</p>
<hr>
<h2>선형 자료구조 다루기</h2>
<p>모든 프로그램이나 알고리즘 문제에는 가장 기본적인 자료형인 선형 자료구조가 거의 필수적으로 등장한다.</p>
<p>즉, 기본중의 기본이다.</p>
<p>리스트, 튜플, 스택, 큐(힙) 등은 자료가 선형으로 저장된다.</p>
<p>언어마다 라이브러리 기능의 범위가 다르지만, 보통 데이터를 추가하고 제거하고 찾으면서 목적을 이룬다.</p>
<p>추가는 끝에 추가, 처음에 추가, 특정 위치에 추가.</p>
<p>제거는 끝에 제거, 처음에 제거, 특정 위치에 제거 등이 있다.</p>
<h2>선형 자료구조 탐색</h2>
<p>선형 자료구조의 특징으로 대부분 처음부터 순서대로 탐색을 하지만 꼭 그런것은 아니다.</p>
<p>몇 칸을 건너뛰면서 탐색할 수도 있고, 거꾸로 탐색할 수도 있다.</p>
<p>물론 뒤로 몇 칸 돌아가서 다시 돌아올 수도 있고, 여기저기 뛰어다닐 수도 있다.</p>
<p>그리고 탐색하는 포인트를 하나가 아닌 여러개를 다룰 수도 있다.</p>
<p>이 때는 반복문을 중첩하는 경우가 많으므로 반드시 인덱스를 이용한 순회를 미리 지면에 시뮬레이션 해 보아야 한다.</p>
<h2>선형 자료구조 완성/미완성</h2>
<p>선형 자료구조를 다루는 방법은 크게 2 가지가 있다고 생각한다.</p>
<p>하나는 모든 데이터를 미리 구조에 담아놓고 로직을 수행하는것이고</p>
<p>다른 하나는 로직에 따라 하나씩 혹은 몇개씩 구조에 담는 것이다.</p>
<p>이는 직접 2 가지 경우 따로 나눠서 생각하는 것으로 결정이 가능하다.</p>
<p>필요없는 라인과 필요없는 변수, 필요없는 로직이 제거될 수 있는 중요한 부분이다.</p>
<p>탐색과 추가/제거 기능을 응용하면, 추가제거를 하면서 탐색을 행하는 로직이 있다.</p>
<p>선형자료에 추가제거를 하면서 계속 탐색을 하면 너무나 흔한 인덱스에러가 날 가능성이 농후하다.</p>
<p>이럴 땐 순서대로 하는 것이 아닌 while 문을 이용하여 탐색 포인트를 조건에 따라 갱신하면서 로직을 수행한다.</p>
<p>물론 이 경우에도 인덱스를 이용한 순회를 미리 숙지해야 한다.</p>
<p>선형 자료구조임에도 불구하고 탐색순서가 너무 뒤죽박죽이면 로직에 허점이 생기기 쉬우며, 또 출제자의 의도에 벗어난 것일 수 있으므로, 효율적인 탐색이 가능하도록 자료구조를 선택해야한다.</p>
<h2>2 차원 배열</h2>
<p>2 차원 배열은 여전히 순서가 있지만 2 차원이라는 특성으로 인해 비선형으로 종종 바뀌곤 한다.</p>
<p>여기서 탐색과 추가/제거 기능이 추가되면 자연스럽게 난이도는 올라간다.</p>
<p>그러나 순서가 있는 자료구조로 만들어졌음을 인지한다면 지면에 직접 그리며 쉽게 푸는것이 가능하다.</p>
<p>그러나 그 자체로도 비선형 자료구조가 될 수 있기 때문에, 그래프문제, 재귀 문제에 많이 활용된다.</p>
<p>지도나 게임판 등 어떠한 공간에서 일어나는 일을 구현하는데 많이 쓰인다.</p>
<p>결국엔 하나 혹은 여러개의 어떠한 포인트를 찍고 탐색하고 추가제거를 행하는 것에는 변함이 없다.</p>
<p>다른것이 전혀 없는데 차원이 달라진 것 밖에 없다.</p>
<h2>지면 풀이 습관</h2>
<p>어떤 문제든지 기록을 하며 아이디어를 구체화시켜야 한다.</p>
<p>머릿속에 떠다니는 로직을 곧바로 로직에 옮길 수 있는 것은 정말 단순한 로직밖에 없다.</p>
<p>최소한 수도코드를 짜놓으면 그렇지 않았을때보다 그대로 프로그램을 만드는데 아주 획기적으로 시간이 단축된다.</p>
<p>물론 수도코드가 잘못된 로직으로 이루어졌다면 결과 역시 잘못될 수 있으며 실제 코드로 옮겨서 정확히 구현하는 데 적지 않은 시간이 걸릴 수도 있다.</p>
<p>하지만 여전히 계획성없는 코드보다도 효율적이며 이는 절대적이다.</p>
<h2>각종 단위</h2>
<p>시간이나 자릿수가 넘어가는 모든 숫자 형태의 자료는 모두 최소단위로 통일시켜놓고 시작하는 것이 좋다.</p>
<p>특히 시간 계산같은 경우는, 분이면 분, 초면 초 단위로 단 하나의 단위로 표현해놓는다.</p>
<p>이렇게 하면 비교를 할 때 하나의 로직만 있으면 되기 때문에 시간 단축 + 실수 방지 + 짧은 코드 를 달성할 수 있다.<br>연산을 할 때도 연산자 하나로 한 번의 계산으로 완료할 수 있어서 매우 효율적이다.</p>
<h2>수 비교 혼동방지</h2>
<p>수 비교 특히, 수직선에서 초과 미만 개념이 나오는 문제는 대소관계가 항상 헷갈리게 되어있다.<br>왜냐면 방향 기준을 잡지 않아서 여러번 생각하기 때문이다.<br>수학 문제 풀 때도 마찬가지였다.<br>이 때 &lt; 기호를 기준으로 놓고 보면 항상 작은것이 왼쪽에 놓여 자연스럽다.<br><code>&gt;</code> 기호를 쓰더라도 순간적으로 <code>&lt;</code> 가 되게 하여 뒤집으면 크고 작음을 생각할 필요없이 수직선 상에 순서대로 놓이게 된다.<br>이는 각종 단위를 하나로 통일하여 하나의 로직으로만 처리하는 방식과 유사한 접근법이다.<br>즉, 줄일 수 있는 로직은 줄이는 것이다.</p>
<h2>재귀 관련</h2>
<p>재귀가 익숙하지 않은 상태에선 재귀를 써야하는지도 잘 모르고 쓰게 되더라도 설계하는것이 쉽지 않을 수 있다.<br>재귀 함수의 정의를 목적에 맞게 한 줄로 정의를 먼저 해보아야 한다.<br>인자로 받을 것, 자신을 호출할 포인트, 반환할 것 들을 재료로 사용해야 한다.<br>그리고 유념할 것은 재귀를 호출하면 다시 돌아온다는 것이고, 재귀의 결과를 뭉뚱그려서 <code>어떠한 결과</code> 라고 생각하면 작은 문제에 집중할 수 있다.</p>
