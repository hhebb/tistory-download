<h1>파일 보호</h1>
<h2>File Protection</h2>
<ul>
<li>File 에 대한 부적절한 접근 방지<br />다중 사용자 시스템에서 필수적이다.</li>
<li>접근 제어가 필요한 연산들<br />read - (R)<br />write - (W)<br />execute - (X)<br />append - (A)</li>
</ul>
<h2>File Protection Mechanism</h2>
<ul>
<li>파일 보호 기법은 system size 및 응용 분야에 따라 다를 수 있음</li>
<li>Password 기법<br />각 file 들에 pw 부여<br />비현실적임 - 사용자가 각각 파일에 대한 pw 를 기억해야함. 중요한것만 pw 건다.</li>
<li>Access Matrix</li>
</ul>
<h2>Access matrix</h2>
<ul>
<li>범위(domain-=user/group)와 개체(object=file) 사이의 접근 권한을 명시.</li>
<li>용어<br />object - 접근대상 (file, device 등)<br />domain - 접근 권한의 집합, 그룹 (사용자, 프로세스)<br />access right - &lt;object name, right-set&gt; (테이블의 값)</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@cddRKK/btqMfjeqxhB/InNMpM0A1pNUTQqY4bNdp1/img.png" ><p class="cap1">width="602" height="220" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>Access table 구현 - global table</h2>
<ul>
<li>시스템 전체 파일들에 대한 권한을 테이블로 유지.</li>
<li>단점<br />테이블의 사이즈가 너무 크다.<br />테이블의 빈 공간이 많기도 하다.<br />결국 오버헤드가 생긴다.</li>
<li>해결법<br />매트릭스가 아닌, 인접 리스트 형태로 저장.<br />col, row 둘 중 하나를 기준으로 삼는다.</li>
</ul>
<h2>Access List</h2>
<ul>
<li>access matrix 의 col 을 리스트로 표현<br />각 오브젝트에 대한 접근 권한을 나열</li>
<li>오브젝트(파일) 생성 시 각 도메인에 대한 권한을 부여한다.</li>
<li>오브젝트 접근 시 권한을 검사</li>
<li>실제 OS 에서 많이 사용됨.<br />rwx rwx rwx</li>
</ul>
<h2>Capability list</h2>
<ul>
<li>Access matrix 의 row 를 리스트로 표현<br />각 도메인에 대한 접근 권한 나열</li>
<li>capability 를 가짐이 권한을 가짐을 의미한다.<br />프로세스가 권한을 제시, 시스템이 검증 승인.<br />매 접근시 리스트를 확인해야하는 부담이 줄어듬.</li>
<li>시스템이 capability list 자체를 보호해야 함.<br />보안에 문제가 생길 수 있다.<br />그래서 커널에 저장하지만 그것은 곧 오버헤드로 이어진다.</li>
</ul>
<h2>Lock-key Mechanism</h2>
<ul>
<li>Access list 와 capability list 를 혼합한 개념</li>
<li>object 는 lock, domain 은 key 를 가짐</li>
<li>시스템은 여전히 key, lock 을 관리해야해서 오버헤드 있음.</li>
</ul>
<h2>권한 관리 기법 비교</h2>
<ul>
<li>global table<br />단순하지만 비대해진다.</li>
<li>access list<br />오브젝트 별 권한 관리가 용이함<br />모든 접근마다 권한을 검사해야 함 - 오브젝트 많이 접근하는 경우 느림</li>
<li>capability list<br />리스트 내 오브젝트들에 대한 접근에 유리<br />오브젝트 별 권한 관리(권한 취소 등)가 어려움</li>
</ul>
<h2>혼합법</h2>
<ul>
<li>많은 OS 가 Access list 와 capability list 개념을 함께 사용한다.<br />둘의 장점을 취한다.<br />오브젝트에 대한 첫 접근 - access list 탐색<br />capability 생성 후 해당 프로세스에게 전달 - 이후 접근 시 권한 검사 불필요<br />마지막 접근 후 - capability 삭제</li>
</ul>
<h2>파일 시스템 구현</h2>
<ul>
<li>allocation methods</li>
<li>free space management</li>
</ul>
<h2>allocation methods</h2>
<ul>
<li>continuous allcation</li>
<li>discountinuous allocation</li>
</ul>
<h2>Continuous Allocation</h2>
<ul>
<li>한 파일을 디스크의 연속된 블럭에 저장</li>
<li>장점<br />효율적인 파일 접근<br />순차, 직접 접근할 때 좋음</li>
<li>문제점<br />새로운 파일을 위한 공간 확보가 어려움<br />외부 단편화가 발생함.<br />파일 공간 크기 결정이 어려움 - 파일이 커져야하는 경우를 고려해야 함.<br />공간을 할당하는 것에 어려움이 있다.</li>
</ul>
<h2>Linked Allocation - Discontinuous</h2>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@b1qzDS/btqMeiAiAJ4/c31M1Z5tG2IY092XK4t9ck/img.png" ><p class="cap1">width="366" height="244" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<ul>
<li>파일이 저장된 블럭들을 연결 리스트로 연결<br />비연속 할당이 가능</li>
<li>디렉토리는 각 파일에 대한 첫 번째 블럭에 대한 포인터를 가짐</li>
<li>단순하지만 외부 단편화도 없다.</li>
<li>단점<br />직접 접근에 비효율적<br />포인터 저장을 위한 공간 필요<br />신뢰성 문제 - 사용자가 포인터를 실수로 건드리는 문제 등이 있다.</li>
</ul>
<h2>Linked allocation - FAT</h2>
<ul>
<li>File Allocation Table (FAT)<br />각 블럭의 시작 부분에 다음 블럭의 번호를 기록하는 방법<br />그래서 탐색에 좀 더 빠르다?</li>
<li>윈도우 등에서 사용.</li>
</ul>
<h2>Indexed Allocation</h2>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@bFHaJe/btqMfjZNqO7/plO3WjcDMtEStX92jjb7b0/img.png" ><p class="cap1">width="443" height="274" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<ul>
<li>파일이 저장된 블럭의 정보(pointer) 를 인덱스 블럭에 모아 둠.</li>
<li>직접 접근에 효율적<br />순차 접근에는 비효율적</li>
<li>파일 당 인덱스 블럭을 유지해야 함<br />공간 오버헤드가 발생한다.<br />인덱스 블럭 크기에 따라 파일의 최대 크기가 제한 됨.</li>
<li>유닉스 등에서 사용 됨.</li>
</ul>
<h2>Free Space management</h2>
<ul>
<li>bit vector</li>
<li>linked list</li>
<li>grouping</li>
<li>counting</li>
</ul>
<h2>Bit vector</h2>
<ul>
<li>시스템 내 모든 블럭들에 대한 사용 여부를 1 비트로 표시</li>
<li>단순하고 효율적임</li>
<li>비트 벡터 들을 메모리에 보관해야 함. - 대형 시스템에 부적합.<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@Qbsyq/btqMeE4cykW/jfHGBGAju1upkszwjJgJCk/img.png" ><p class="cap1">width="419" height="303" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>Linked List</h2>
<ul>
<li>빈 블럭을 연결 리스트로 연결</li>
<li>비효율적임.<br />링크 포인터 공간 필요<br />공간, 시간적으로 모두 손해</li>
</ul>
<h2>Grouping</h2>
<ul>
<li>n 개의 빈 공간을 그룹으로 묶고 그룹 단위로 연결 리스트로 연결</li>
<li>빈 공간들의 집합에 대표를 지정<br />연속된 빈 블럭을 쉽게 찾을 수 있다.</li>
</ul>
<h2>Counting</h2>
<ul>
<li>연속된 빈 블럭들 중 첫 번째 블럭의 주소와 연속된 블럭 수를 테이블로 유지</li>
<li>continuous allocatioin 시스템에 유리한 기법</li>
<li>경우에 따라 더 비효율적일 수도 있다.</li>
<li>즉 프로그램이나 시스템의 특성에 따라 관리 기법이 달라진다.</li>
</ul>