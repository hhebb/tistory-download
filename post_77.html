<blockquote>
<p>알고리즘 끝까지</p>
</blockquote>
<h2>신장 트리</h2>
<p>spanning tree<br>그래프에서 모든 노드가 연결되어 있으면서 트리 속성을 만족하는 그래프.<br>즉 사이클이 생기지 않는 그래프.</p>
<h2>최소 신장 트리(MST)</h2>
<p>신장 트리 중에서 간선의 가중치 합이 최소인 신장 트리<br>조건을 다시 쓰면, 사이클이 없고 모든 노드가 연결되며 가중치가 최소인 그래프의 연결.<br>사이클이 없으면 트리와 동일한 구조다.</p>
<h2>크루스칼 알고리즘</h2>
<p>모든 노드를 독립적인 집합으로 만든다.<br>모든 간선을 비용 기준으로 정렬하고 작은것부터 양 끝 두 노드를 비교한다.<br>중요한 것은 사이클이 생기지 않도록 연결하는 것이다.<br>또 매 순간 가장 작은 가중치를 가지는 간선을 선택하므로 그리디 메커니즘이 사용된 것이다.</p>
<h3>유니온 파인드 알고리즘</h3>
<p>disjoint set(서로소 집합) 을 표현할 때 사용하는 알고리즘.<br>노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때 사용.<br>개별 집합들을 트리로 관리한다.</p>
<ol>
<li>초기화 - 모든 원소가 개별 집합으로 이뤄지도록 초기화</li>
<li>union - 2 개의 집합을 하나의 집합으로 합친다. 두 트리를 하나의 트리로 만든다. 각각 트리라는 뜻임.</li>
<li>find - 2 노드가 동일한 부분집합에 있는지 체크하기 위해 각각의 루트노드를 확인한다.<br>find 는 사이클을 확인하는데 사용할 수 있다.<br>최악의 경우 링크드 리스트 형태가 된다. find 로직 수행 시 비효율적이게 될 수 있다.</li>
</ol>
<h3>서로소 집합</h3>
<p>서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.</p>
<h3>유니온 파인드 구체</h3>
<p>트리 구조 최적화를 위한 방법으로 union-by-rank<br>랭크를 깊이로 표현하고 두 트리 중 랭크가 낮은것을 높은곳에 union<br>union-find 연산의 시간복잡도는 O(logN) 을 보장하게 된다.<br>path compression 은 find 할 때 사용되는 기법으로 잎 노드를 바로 루트 노드의 직계자손으로 만들어<br>경로를 압축한다.<br>위의 2 방법을 사용하면 union/find 연산이 거의 상수 O(n) 으로 줄어든다.</p>
<h3>시간 복잡도</h3>
<p>결과적으로 O(ElogE)<br>크루스칼 알고리즘 자체는 O(E). 간선 정렬이 지배적이다.</p>
<h3>프림 알고리즘</h3>
<p>전체 간선을 보는 크루스칼과 달리 지금까지 노드들과 연결된 간선들만 선택하는 것이 차이점.<br>특정 정점에서 시작하고, 해당 정점에 연결된 가장 가중치가 작은 간선을 선택하는 방식.<br>역시 그리디 메커니즘 적용.</p>
<h3>프림 알고리즘 구현</h3>
<p>역시 heap 을 사용.<br>연결된 노드 안에 없다면 사이클이 없다는 것을 이용하여 사이클을 제거한다.</p>
<h3>프림 알고리즘 시간 복잡도</h3>
<p>최악의 경우 O(ElogE)<br>개선하면 O(ElogV) - 간선이 아닌 정점을 중심으로 진행</p>
<h2>백트래킹</h2>
<p>퇴각 검색으로 부름<br>제약 조건 만족 문제에서 해를 찾는 문제 해결 전략<br>탐색하는 수를 줄이는 기법이다.<br>고려할 모든 경우의 수를 상태공간 트리로 표현<br>이 트리를 DFS 방식으로 탐색 진행<br>promision - 해당 루트가 조건에 맞는지 검사하는 로직<br>prunning - 조건이 만족되지 않는 지점에서 가지치기하는 로직</p>
<h3>N 퀸 문제</h3>
<p>각 행에 퀸을 하나씩 놓는 방법으로 접근한다.<br>퀸을 놓을 수 있는 모든 경우의 수를 상태라고 하고 트리 개념으로 생각. 트리를 만들지는 않는다.<br>각 행마다 체크하다가 조건을 만족하지 않는다면 그 이후는 확인할 필요도 없다.<br>이 때 백트랙한다. 후보에서 아예 제거하는 방식으로도 구현할 수 있다.</p>
