<h1>네트워크 레이어 IP</h1>
<h2>간단 정리</h2>
<ul>
<li>App 계층<br>  기본 단위는 메세지<br>  HTTP, FTP, DNS 등이 있다.</li>
<li>전송 계층<br>  기본 단위는 세그먼트(헤더 + 메세지)<br>  TCP, UDP 가 있다.</li>
<li>네트워크 계층<br>  기본 단위는 패킷(헤더 + 메세지(세그먼트))<br>  IP 하나만 있다.</li>
<li>링크 계층<br>  기본 단위는 프레임</li>
</ul>
<h2>IP 헤더</h2>
<ul>
<li>헤더 + 메세지(TCP 헤더 + 메세지)<br>  헤더는 총 20 byte.<br>  TCP 헤더도 20 byte, 총 40 byte<br>  실제 네트워크에서 헤더만 있는 빈 패킷이 많이 돌아다닌다 - 전송 확인인 ACK 때문임.</li>
<li>IP 주소</li>
<li>checksum</li>
<li>length</li>
<li>TTL<br>  라우터 하나 거칠 때 마다 하나씩 카운트하고 0 이 되면 버림.<br>  라우팅 테이블이 잘못되었을 때 무한으로 네트워크 상에서 돌아다닐 수 있으므로 일정시간 후 제거함.<br>  원활한 네트워크 상황을 위해 있는 기능</li>
</ul>
<h2>IP 주소</h2>
<ul>
<li>32 bit 숫자. 또는 4 byte<br>  실제 라우터는 bit 단위로 읽는다.</li>
<li>IP 는 호스트라기보다 더 정확하게는 NIC(Network Interface Card) 를 지칭한다.<br>  라우터는 NIC 를 여러개 꽂아서 IP 주소를 여러개 가진다.<br>  인터페이스를 지칭한다.</li>
</ul>
<h2>IP 주소 배정</h2>
<ul>
<li>만약 어떤 기준없이 IP 를 할당한다면 문제가 생김<br>  실제 라우팅 테이블의 사이즈가 커지고 관리가 어려움.</li>
</ul>
<h2>Hierarchical Addressing</h2>
<ul>
<li>IP 주소를 2 부분으로 나눈다.<br>  앞의 24 비트는 network id. Prefix, Subnet Id 라고도 한다.<br>  뒤의 8 비트는 host id</li>
<li>이 preifx 가 같으면 같은 네트워크에 있는 것으로 판단할 수 있다.<br>  그래서 라우팅을 더 효율적으로 할 수 있다.</li>
</ul>
<h2>Subnet Mask</h2>
<ul>
<li>앞의 24 개 bit 에만 1 을 할당하여 네트워크 id 를 알아내기 편하게 한 비트 마스트.<br>  10 진수로는 255.255.255.0</li>
<li>항상 IP 주소는 함께 다님.</li>
</ul>
<h2>구버전 IP 배정</h2>
<ul>
<li>class 기반 배정</li>
<li>A, B, C 클래스로 나눠서 각 기관에 나누어줌<br>  8 bit 단위로 prefix 를 나눈다.<br>  예를 들어 12.12.12.12/8 - /8 은 prefix 가 8 bit 라는 것이고 꽤 큰 규모의 네트워크임.</li>
<li>사이즈에 대해서 비효율적임.</li>
<li>여러개의 prefix 를 받아야하는 경우가 생기므로 결국 라우팅이 늦어진다.</li>
</ul>
<h2>새로운 IP 배정</h2>
<ul>
<li>classless inter-domain routing(CIDR)</li>
<li>8 bit 단위가 아닌 네트워크 크기에 맞춰서 유연하게 네트워크 id 사이즈를 결정.</li>
</ul>
<h2>Longest Prefix Match Forwarding</h2>
<ul>
<li>라우터로 들어온 패킷의 dst 주소를 포워딩 테이블과 매칭시켜 링크로 보내는 것을 포워딩이라고 한다.</li>
<li>테이블에 있는 주소는 IP 가 서브넷 사이즈와 함께 표시된다.</li>
<li>그러면 dst 주소와 매칭되는 주소가 여러개 있을 수 있는데, 그 중 가장 길게 매칭되는 곳으로 보내는 것</li>
<li>이것이 라우터가 하는 주된 작업!</li>
<li>포워딩 테이블은 라우팅 알고리즘, 프로시저가 채우게 된다.</li>
</ul>
<h2>Subnet</h2>
<ul>
<li>같은 prefix, subnet id 를 가진 디바이스의 집합<br>  즉 하나의 네트워크라고 생각해도 됨.<br>  IP 주소를 prefix 기준으로 나누면 subnet 이 어떤 덩어리인지 알 수 있다.</li>
<li>또는 라우터를 거치지 않고 접근이 가능한 호스트들의 집합</li>
<li>라우터는 인터넷 인터페이스가 여러개일 수 있다.<br>  그래서 IP 주소가 여러개다.<br>  그런데 그 IP 주소의 prefix 가 다 다른다.<br>  즉 subnet 을 여러개 가진다.</li>
</ul>
<h2>IPv4, IPv6</h2>
<ul>
<li>IPv4 IP(42억 개) 주소가 고갈이 될것이라고 예견</li>
<li>그래서 128 비트 길이의 IP 주소를 디자인함.</li>
<li>사실 이미 고갈된지 오래임.</li>
</ul>
<h2>NAT (Network AddressTranslation)</h2>
<ul>
<li>IP 주소를 재활용하는 트릭. 근본적인 해결법이 아니라고도 한다.</li>
<li>내부 네트워크는 내부적으로만 유일하고 다른 네트워크에서는 중복될 수 있는 주소를 할당받는다.</li>
<li>외부 네트워크로 나갈 때(out-bound)는 내부 네트워크를 묶어두고 있는 라우터의 IP 로 src 주소로 바꿔준다.<br>  내부 네트워크 IP 는 사실상 유일하지 않기 때문임.</li>
<li>src 포트번호도 바꿔서 보내야 함<br>  같은 네트워크의 단말기끼리 구분을 위해서.</li>
<li>그리고 들어올떄(in-bound) 는 port 번호로 각 단말기를 구분하여 들어간다.</li>
<li>라우터는 포트-디바이스 정보도 관리한다?</li>
</ul>
<h2>NAT 단점</h2>
<ul>
<li>전송 시 IP 주소를 바꾸고 port 도 바꾼 것을 한 짓임<br>  port 번호는 프로세스를 찾아가는 전송계층의 영역임.<br>  즉, layer violation 임.</li>
<li>port 번호를 host 찾는데 사용해버린다..</li>
<li>그렇다면 port 는 어떻게 알릴것인가?<br>  그래서 NAT 를 이용하는 내부 네트워크 호스트는 특정 포트를 열어두는 웹서비스를 할 수가 없다.<br>  다른 클라이언트가 이 호스트의 웹서버 프로세스에 도달할 수 없으므로</li>
</ul>
<h2>포트포워딩</h2>
<ul>
<li>NAT 는 포트 번호까지 IP 주소처럼 쓰는 단점이 있어 도착지로서의 역할을 하기가 힘들다.</li>
<li>포워딩을 하면 포트번호를 호스트와 연결을 시킬 수 있다.</li>
<li>그래서 약간 어거지로 포트 번호까지 찾아오게 할 수 있다.</li>
<li>참고로 웹 클라이언트는 동적 포트(49152 이상) 중 하나를 열어서 접근한다. </li>
</ul>
