<h1>css 중급</h1>
<h2>크로스 브라우징</h2>
<p>웹페이지가 모든 브라우저에서 깨지지 않고 의도한 대로 나오게 하는 작업.  </p>
<h2>웹 표준 준수</h2>
<p>표준을 지켜도 버그가 있는 경우가 있다.<br>브라우저 엔진이 다르므로 차이가 있을 수 있다.  </p>
<h2>브라우저 엔진</h2>
<p>웹 브라우저 프로그램에 장착된 렌더링 엔진<br>Trident - 구버전 IE 등이 사용<br>Gecko - 모질라 재단의 파이어폭스<br>Webkit - 사파리, 초기버전 크롬, 안드로이드와 iOS 기본 브라우저<br>Presto - 구버전 오페라. 사용되지 않음.<br>Blink - 크롬, 오페라<br>듀얼 - 블링크/트라이던트 를 번갈아 사용한다.  </p>
<h2>브라우저 기본 스타일</h2>
<p>css 스타일 없이 html 만 주면, 브라우저 별로 다르게 보인다.<br>이는 브라우저가 자체적인 스타일을 적용해버리기 때문임.  </p>
<h2>css 초기화</h2>
<p>이러한 차이점을 보다 편하게 작업하기 위해 차이나는 부분들에 미리 스타일을 주는 방법이 초기화다.<br>여백(margin, padding) 때문에 혼동이 생긴다. 그래서 모든 요소들의 여백을 0 으로 만들어 놓고 작업을 한다.<br><code>*{margin: 0; padding: 0;}</code><br><code>*</code> 은 모든 요소를 선택하는 선택자이다.<br>이렇게 모두 선택하면 렌더링 속도가 떨어질 수 있다고 하여 일일이 스타일을 주기도 한다.<br>html, doby, div {margin: 0; padding:0;} 이런 식으로 한다.<br>기본 리스트 스타일도 거의 안쓰므로 스타일을 아예 없애서 초기화한다.<br><code>ol, ul{list-style: none;}</code><br>이미지에 border 요소를 거의 쓸 일이 없으므로 초기화<br><code>img{border: none;}</code><br>그리고 거의 모든 컨텐츠를 담는 body 요소에 스타일을 지정해주는 등 작업을 한다.<br>css 초기화는 정답이 없다.  </p>
<h2>css 초기화 주의할 점</h2>
<p>초기화하면 속성의 상속이 이루어지지 않는다??  </p>
<h2>IE 크로스 브라우징</h2>
<p>IE 7 이하 브라우저는 웹 표준을 준수해도 렌더링이 제멋대로다.<br>버전 별로도 크로스 해야한다.  </p>
<h2>IE 용 주석을 이용한 방법</h2>
<p><code>&lt;!--\[if IE 7\]&gt;css, js 링크&lt;!\[endif\]--&gt;</code><br>IE 버전 별로 작동하게 된다.<br><code>&lt;!--\[if lt IE 7\]&gt;</code> 처럼 범위 지정가능<br>lt<br>lte<br>gt<br>gte  </p>
<h2>IE 대응</h2>
<p>IE 6 점유율이 낮아져도 여전히 사용자가 있음.<br>구형 브라우저 사용하고 있다는 것을 알려주는 기능을 넣는게 좋다.  </p>
<h2>css 디버깅</h2>
<p>css 파일에서 버그가 생기면 웹페이지가 작동하지 않거나 의도와 다르게 작동한다.<br>브라우저는 웹 디버깅을 위한 개발자 도구를 내장하고 있다.<br>주로 F12 를 눌러서 켠다.<br>대부분의 브라우저는 비슷한 기능들을 가지고 있다.<br>html, css 정보를 확인할 수 있다.  </p>
<h2>선택자 2</h2>
<p>대부분의 스타일 파일은 기본 선택자들로 채워진다.<br>하지만 나머지 선택자들을 알면 더 풍부해질 수 있다.  </p>
<h2><code>*</code> 선택자</h2>
<p>모든 요소를 선택하는 선택장.<br>우선순위 중 제일 하위에 있다.<br>css 초기화 정도에서만 사용한다. 속도가 조금 떨어지는 것을 알고 있어야 한다.<br>속도때문이 아니더라도 굳이 쓸 이유가 없는 선택자이다.  </p>
<h2>관계를 나타내는 선택자들</h2>
<h2>A &gt; B 선택자</h2>
<p>공백으로 구분하는 자식은 모든 계층의 자식에 영향을 준다.<br><code>&gt;</code> 선택자는 직계 자손들만 선택할 수 있다.  </p>
<h2>A + B 선택자(인접 형제 선택자)</h2>
<p>A 와 형제 관계로 있는 B 요소를 선택한다. 단 인접해 있어야 한다.<br>A 는 제외하고 그 이후의 모든 형제를 선택한다.  </p>
<h2>A ~ B 선택자(일반 형제 선택자)</h2>
<ul>
<li>선택자와 거의 동일하지만 인접하지 않아도 형제면 다 선택한다.  </li>
</ul>
<h2>가상 클래스 선택자들(pseudo-class)</h2>
<p>대부분 선택자들은 class, id 나 요소들간 관계로 선택하는 선택자였다.<br>가상 클래스 선택자들은 해당 요소의 상태에 따라 선택을 한다.<br>요소의 상태이기 때문에 요소를 가리키는 다른 선택자와 같이 사용한다.<br>.abc:pseudo-class{} 처럼 &#39;:&#39; 으로 표현한다.  </p>
<h2>a 요소의 가상 클래스</h2>
<p>:link - 링크 상태를 선택. a 가 앵커가 아닌 링크로 사용되고 있을 때에 선택할 수 있는 선택자<br>:visited - 링크 중에 방문한 링크를 선택하는 선택자<br>:hover - 호버링 상태를 선택. 밑줄이 생기거나 색이 바뀌게 하는 등의 기능. 꼭 a 요소가 아니더라도 다른 요소에서도 쓰임.<br>:active - 클릭 상태. 링크를 마우스로 눌렀을 때 상태를 선택.  </p>
<h2>a 가상 클래스 선택자 순서</h2>
<p>a 요소의 가상 클래스는 모두 같은 우선 순위를 가진다.<br>덮어씌어질 수 있다는 의미이다.<br>그래서 큰 범위부터 작은 범위로 선언하면 된다.<br>link - visited - hover - active 순서대로 선언하는 것이 효율적이다.  </p>
<h2>:focus 선택자 - 초점이 선택된 상태</h2>
<p>input 요소(폼) 가 선택되었을 때 기보드 초점이 해당 요소에 와있을 떄를 선택한다.<br>브라우저에서 tab 키를 통해 이동되는 초점을 의미한다.<br>이 선택자는 a 요소에도 위치한다.<br>키보드의 접근성이 향상되므로 선택자 사용을 권장한다.  </p>
<h2>:first-child 선택자</h2>
<p>말그대로 해당 요소가 첫번쨰 자식인가를 판단하여 선택한다.  </p>
<h2>다중 css 시트</h2>
<p>여러개의 웹페이지를 관리하는데 하나의 css 파일로 관리한다면 비효율적임.<br>웹 페이지가 무거워지고 느려진다.<br>그래서 파일을 개별로 나눈다.  </p>
<h2>link 요소 이용</h2>
<p>제일 권장되는 방법<br><code>&lt;link href=&quot;&quot;/&gt;</code></p>
<h2>@import 이용</h2>
<p>언어처럼 모듈을 임포트하는 것 같음.<br>그런데 css 는 그냥 다 분리하는게 관리하기 좋다.<br>그리고 페이지의 로딩속도를 늦춘다.<br>웹 페이지에 들어가면 브라우저는 html, css, 이미지 등을 다운 받는다.<br>대부분 여기서 로딩이 걸린다.<br>link 방식은 병렬로 다운 받지만 , @import 방식은 단계적으로 로딩 받으므로 느려질 수 밖에 없다.  </p>
<h2>무조건 다 나눈것이 좋은가?</h2>
<p>각 페이지마다 파일을 다운로드 하는데 서버에 요청을 한다.<br>그래서 무조건 나누면 서버 요청응답 시간이 로딩을 길어지게 할 수 있다.<br>사용의도에 따라 파일을 합치거나 나누는것이 좋다.  </p>
<h2>스타일 우선 순위</h2>
<p>다중 스타일 시트라고 해서 시트간 우선순위는 없다.<br>각 css 파일 안에 같은 우선 순위를 가진 선택자라면 가장 아래에 들어가 있는 css 선택자로 덮어씌워진다.<br>그런데 브라우저 내장 스타일 시트도 있고, 사용자가 추가할 수 있는 스타일이 있다.<br>1 - 브라우저 내장 시트<br>2 - 사용자 스타일 시트<br>3 - 제작자 시트<br>4 - 제작자 시트 중 중요 표시 된 속성<br>5 - 사용자가 넣은 시트 중 중요 표시된 속성<br>중요 표시는 속성값 뒤에 !important 를 넣어주면 된다.<br>이는 응급일때만 사용하도록 한다.  </p>
<h2>선택자 우선 순위</h2>
<p>스타일 시트 내의 우선 순위.<br>b 가 아무리 커도 a 가 큰 것이 우선 순위가 된다.<br>a - css 선택자가 아닌 요소에 직접 style 속성으로 스타일을 주는 경우에 1 이 됨.<br>b - 선택자 중에서 id 선택자의 개수만큼 숫자가 올라감.<br>c - 클래스 선택자, 요소의 속성을 이용한 선택자, 가상 클래스 선택자 개수만큼 숫자가 올라감<br>d - 요소 명으로 준 선택자와 가상 선택자만큼 숫자가 올라감.  </p>
<h2>display, visibility</h2>
<h2>display 속성</h2>
<p>HTML 에서 마크업을 할 때엔 외형적인 것이 아닌 의미 중심으로 작성한다.<br>크게 블록 요소, 인라인 요소가 있었다.<br>이 둘은 스타일에서 다르게 나타나기 때문에 외형적인 한계가 있다?<br>display 속성은 이를 보완해준다.<br>해당 요소를 블록 또는 인라인으로 바꿔서 보여줄 수 있도록 만들어 준다.<br>혹은 아예 보이지않게 만들어 동적인 웹을 제작하는데에 쓰인다.<br>block<br>inline<br>inline-block - 두 가지 특징을 동시에 가진 형태.<br>none - 요소를 아예 보여주지 않는다.<br>inherit<br>위와 같은 속성값을 가진다.  </p>
<h2>inline-block</h2>
<p>인라인 특성과 블록 특성을 같이 가지고 있는 형태.<br>인라인 요소처럼 줄바꿈이 일어나지 않는다.<br>하지만 블록 요소처럼 높이나 너비값을 가질 수 있다.<br>보통 버튼 같은 형태를 만들 때 유용하게 사용된다.  </p>
<h2>display: none</h2>
<p>아예 보여주지 않는다.<br>이 속성값은 js 와 함께 동적인 페이지를 구현하는데 활용된다.<br>탭이나 메뉴 등 내용을 보이거나 감출 때 사용된다.  </p>
<h2>visibility 속성</h2>
<p>이 속성은 요소가 보여질 지에 대해 결정하는 속성.<br>visible - 디폴트. 요소를 보여줌<br>hidden - 요소를 안 보여줌.<br>collapse - table 요소들에서만 줄 수 있는 값. 필요에 따라 공백을 없에서 테이블 레이아웃을 자연스럽게 유지  </p>
<h2>display: none vs visibility: hidden</h2>
<p>none 은 흔적도 없이 사라지지만, hidden 은 요소의 영역을 남겨놓는다.  </p>
<h2>visibility: collapse</h2>
<p>이 속성 값은 table 요소(table, tr, th, td) 에만 사용 가능.<br>테이블의 레이아웃에 따라 hidden 이나 none 으로 처리된 것처럼 보여준다.<br>tr 요소에 visibility: hidden 값을 줄 경우, 빈 영역이 남게 된다. 이 때는 none 처럼 처리하여 공백을 없애버린다.<br>반면 th, td 를 숨길 때 none 을 사용하면 꺠질 수 있다.<br>그래서 collapse 를 써야함. 자동으로 안깨지게 해주니까.  </p>
<h2>overflow, float, clear</h2>
<p>css 레이아웃을 잡는데 기본이 되는 속성들.<br>요소들을 배치할 떄 많이 활용하게 될 속성들임.  </p>
<h2>overflow 속성</h2>
<p>이 속성은 박스 모델 안에서 내부 컨텐츠가 박스를 벗어날 때 처리하는 정책을 결정.<br>visible - 벗어난 상태 그대로 보여짐.<br>scroll - 우측에 스크롤바 노출, 스크롤링. 항상 스크롤바가 노출.<br>hidden - 벗어나는 컨텐츠 다 숨김<br>auto - 컨턴츠가 박스를 벗어날 때만 스크롤바를 노출.<br>inherit  </p>
<h2>float 속성</h2>
<p>글 중간에 이미지를 넣고자 할 때.<br>이름대로 요소를 띄워서 왼쪽이나 오른쪽에 배치할 수 있도록 만들어 준다.<br>none - 요소를 띄우지 않는다. 디폴트<br>left<br>right<br>inherit<br>이 속성은 레이아웃 잡을 때 많이 사용하는 속성이며 쉽지 않음.  </p>
<h2>clear 속성</h2>
<p>float 을 사용해서 이미지 등을 본문에 넣었다가 양옆이 아닌 이미지 아래에서 새 섹션을 시작할 때<br>float 을 해제시켜 줄바꿈을 하게 한다.<br>none - 해제를 안 함<br>left - float:left 를 해제함<br>right<br>both  </p>
<h2>float 레이아웃</h2>
<p>기본적인 float 배치<br>(가로로 배치한 경우)<br>다단의 레이아웃도 이를 기본으로 응용하여 만들어짐.<br>div 같은 블록 요소는 줄바꿈이 생겨 기본적으로 세로로 배치된다.<br>하지만 float 속성을 스타일을 주면 가로로 나란히 오도록 만들 수 있다.<br>float: left; 속성값을 그냥 주면 부모 요소가 해당 요소를 인식하지 못한다.<br>말 그대로 float, 띄워주는 것이므로.<br>모든 요소는 float 되지 않는 요소들만 인식하여 레이아웃이 렌더링 된다.  </p>
<h2>float 요소를 포함하기 위한 방법</h2>
<p>부모 요소 높이 값 조절 - 구림.<br>float 해제시킬 임의의 요소 삽입 - 추가적으로 아무 의미 없는 요소를 추가해 준다.<br>overflow 이용한 방법 - 임의의 요소를 넣지 않아도 부모 요소가 떠있는 요소들을 인식하게 만들어 준다.  </p>
<h2>중첩된 float 배치</h2>
<p>가로 배치 안에 가로 배치 등에 해당.<br>중요한 것은 가로로 배치되어도 부모가 자식을 잘 인식하는데, 이는 부모 역시 float 된 요소이기 때문이다.<br>clear:both, overflow:hidden 스타일을 준 요소의 사우이 요소가 해당 요소를 완전히 감싸게 하는 습관을 들이면 좋다!  </p>
<h2>table 스타일</h2>
<p>테이블 요소만을 위한 스타일 속성  </p>
<h2>border 스타일</h2>
<p>다른 요소와 마찬가지로 테두리 스타일을 줄 수 있다.<br>테이블에서만 주는 border 관련 속성이 있다.  </p>
<h2>border-collapse</h2>
<p>테이블 테두리에 공백을 가질지 없앨지 결정하는 속성.<br>오직 table 요소에만 사용가능. th, tr 등은 안됨.<br>table{border-collpase: collapse;}<br>separate - 셀 들 사이 공백을 만든다<br>collapse - 셀들을 합쳐 공백을 제거함.<br>inherit  </p>
<h2>border-spacing</h2>
<p>border-collapse 속성값이 separate 일 때 셀 간의 공백의 크기를 조절해 주는 속성.<br>단위는 px, em 등이 온다.<br>역시 table 요소에만 적용될 수 있다.<br>table{border-collapse:separate; border-spacing: 5px;}  </p>
<h2>table-layout</h2>
<p>기본적으로 내부 요소에 따라 셀의 너비가 결정됨.<br>이를 고정할지 아닐지를 결정한다.<br>역시 table 요소에서만 사용가능.<br>table(table-layout:fixed;}<br>auto - 열의 너비를 자동적으로 잡아 준다. 내부를 모두 읽고나서 너비를 정하므로 느려질 수 있다?<br>fixed - 고정된 레이아웃을 잡는다.<br>inherit  </p>
<h2>vertical-align</h2>
<p>수직정렬을 나타내는 속성.<br>이 속성은 인라인 요소간의 관계를 기준으로 정렬한다.<br>테이블의 셀에서 이 속성이 쓰이면 셀 안에서 수직 정렬이 된다.<br>td{vertical-align: middle;}<br>top, middle, botton 만 쓸 수 있다.  </p>
<h2>caption-side</h2>
<p>테이블 소개 및 설명을 담당하는 캡션이라는 것이 있다.<br>필수적인 요소이다.<br>가장 먼저 선언되어야 하기 때문에 도표 위에 위치한다.<br>이 속성은 이 캡션의 위나 아래로 설정한다.<br>caption{caption-side: top;}<br>caption 요소에서만 사용 가능하다.  </p>
<h2>display: table</h2>
<p>테이블 요소들은 다른 블록, 인라인 요소와는 다른 방식으로 보여진다.<br>그래서 테이블을 레이아웃 용도로 쓸 수 있는데 지양해야 한다.<br>하지만 이런 방식이 편하므로 비슷한 기능을 할 수 있게 만들어놨다.<br>위의 display 요소에서 다 다루지 않은 것 중<br>table<br>table-caption<br>table-row<br>table-cell<br>table-column<br>등등<br>이를 사용하면 html 테이블 요소를 사용하지 않고 테이블을 만들 수 있다.<br>하지만 이를 사용하면 rowspan, colspan 같은 셀 병합은 구현할 수 없다.</p>
