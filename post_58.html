<h2>출처</h2>
<p>프로그래머스</p>
<h2>난이도</h2>
<p>프로그래머스 level 2, 카카오 2018 블라인드 채용 문제</p>
<h2>유형</h2>
<p>구현<br />알고리즘(lzw 알고리즘)<br />문자열</p>
<h2>특이사항</h2>
<p>설명해주는 내용을 잘 이해하고 충실히 옮겨야하는 구현 문제.<br />비교적 쉬운 문제지만 까다롭지 않은것은 아니다.</p>
<h2>총평</h2>
<p>다른 사람들 코드를 보니 나의 절반 정도였다.<br />여기저기 지저분한 로직이 많다.<br />파이썬을 사용하는 만큼 그 이점을 최대한 활용해야 할 듯.<br />코드도 짧아야 디버깅 시간이 줄어들 수 있다.</p>
<p>&nbsp;</p>
<pre id="code_1601042542937" class="python" data-ke-language="python" data-ke-type="codeblock"><code>def has_key(dic, value):
    for k, v in dic.items():
        if value == v:
            return k
    return -1
    
def solution(msg):
    answer = []
    dic = {}
    
    # 사전 초기화
    for idx, n in enumerate(range(65, 65 + 26)):
        dic[idx + 1] = chr(n)

    idx = 0
    while idx &lt; len(msg):   
        longest = ''
        for idx_sub in range(idx, len(msg)):
            exit = False
            eval_msg = msg[idx:idx_sub+1]
            key_result = has_key(dic, eval_msg)

            # 마지막에 도달했을 때 처리
            if idx_sub == len(msg) - 1:
                key = has_key(dic, eval_msg)
                if key == -1:
                    saved_key = ''
                    idx_cut = 0
                    for idx in range(len(eval_msg)):
                        tmp_key = has_key(dic, eval_msg[0:idx + 1])
                        if tmp_key != -1:
                            saved_key = tmp_key
                            idx_cut = idx
                    answer.append(saved_key)
                    key_remain = has_key(dic, eval_msg[idx_cut+1:])
                    answer.append(key_remain)
                else:
                    answer.append(key)
                
                exit = True
                break
            if key_result == -1:
                # 최장 길이 문자를 사전에 등록한다.
                dic[len(dic) + 1] = eval_msg
                # 사전에 있는 문자를 출력한다.
                key = has_key(dic, longest)
                answer.append(key)                    
                idx += len(longest)
                break
            else:
                longest = eval_msg
                pass
        if exit:
            break
    return answer</code></pre>