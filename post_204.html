<h1>네트워크 계층</h1>
<p>ICMP, IPv6 조금<br>나머지는 라우팅 알고리즘</p>
<h2>ICMP - Internet Control Message Protocol</h2>
<ul>
<li>네트워크에서 일어나는 특정 이벤트를 src 에게 피드백을 해주는 프로토콜</li>
<li>사용자 데이터가 아니라 네트워크 상에서의 컨트롤 메세지.</li>
<li>TTL 터짐, dst 포트가 닫혀 있다 등등의 정보를 보내 줌.</li>
<li>네트워크 진단에도 사용됨.</li>
</ul>
<h2>IPv6</h2>
<ul>
<li>주소 길이 128 bit 라서 주소 갯수는 문제 없음.</li>
<li>만약 IPv6 로 전환된다면 과도기가 존재할 것임.<br>IPv4 를 쓰는 라우터는 새로운 패킷을 이해 못하므로 추가적인 작업이 필요<br>이를 터널링이라고 한다.</li>
</ul>
<h2>라우팅 알고리즘</h2>
<ul>
<li>네트워크를 그래프로 간주할 수 있다.</li>
<li>결국 목적지까지 최단거리를 구하는 문제임.</li>
<li>크게 2 가지 시각이 있다.<br>하나는 전체 네트워크 상태를 안다고 가정했을 때 - link state 알고리즘<br>다른 하나는 이웃의 정보에만 의존할 때 - distance vector 알고리즘</li>
</ul>
<h2>Link State</h2>
<ul>
<li>각 라우터가 네트워크 전체 상황을 알아야 한다.</li>
<li>이를 가능하게 하려면 모든 라우터가 브로드캐스트 해야한다.</li>
<li>그래서 깔끔한 그래프 구조를 구할 수 있게 된다.</li>
<li>그리고 다익스트라 돌리면 끝이다.</li>
<li>현실적으로 가능한 사이즈에서 쓸 수 있다.<br>관리 주체가 동일한 네트워크 집합에 한정된다.<br>라우팅 테이블을 작성하는 것은 어느정도 독립적으로 사용해도 된다.</li>
</ul>
<h2>Distance Vector</h2>
<ul>
<li>이웃들의 정보로만 라우팅 테이블을 만든다.<br>그래서 다소 비직관적이다.<br>각 라우터가 각자 다른 상황에서 라우팅 알고리즘을 돌린다.</li>
<li>$d_x(y) = min{c(x, v) + d_v(y)}$<br>v 는 이웃 노드.<br>c(x, v) 는 알지만 d_v(y) 는 모른다.<br>이것은 재귀적으로 타고 구해야 한다.</li>
<li>한 번 씩 갱신하면서 점차적으로 전파함.</li>
<li>다익스트라처럼 한 번에 라우팅 테이블이 완성되는 것이 아니라 서서히 완성되어감.<br>이웃에게 자신의 idstance vector 를 전달하여 거리를 재계산하는 과정 반복</li>
<li>최종적으로 변화하지 않는 안정 상태가 되면 완료.</li>
</ul>
<h2>Distance Vector 상태 변화</h2>
<ul>
<li>만약 링크 cost 가 바뀌면 그 노드들과 인접한 노드들의 라우팅 테이블을 다시 채워줘야함.</li>
<li>다른 멀리 있는 노드들은 차차 업데이트 된다.</li>
<li>cost 가 줄어들면 인접한 노드들만 업데이트된다.</li>
<li>하지만 cost 가 커지면 멀리까지 전파되어서 재계산이 필요하다.</li>
<li>이 경우 수렴할 때 까지 count to infiniy 현상이 계속 반복된다.<br>각 노드가 큰 그림을 보지 못하는 상황 때문에 어쩔 수 없이 발생함.<br>이 때 중요한 것은 기존의 값을 넘겨주지 말고 무한대를 넘겨줘야 한다.<br>이래야만 비효율적인 count to infinity 업데이트가 안 생긴다.<br>이를 poison reverse 트릭이라고 한다</li>
</ul>
<h2>로컬 네트워크 라우팅</h2>
<ul>
<li>link state, distatnce vector 알고리즘은 모두 제한된 로컬 영역에서 라우팅하는 방식.</li>
</ul>
