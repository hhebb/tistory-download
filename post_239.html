<h1>네트워크 보안</h1>
<ul>
<li>네트워크 보안에 관한 백그라운드</li>
</ul>
<h2>요소</h2>
<ul>
<li>기밀성<br>  암호화</li>
<li>인증<br>  사용자임을 확신</li>
<li>메시지 변조 방지</li>
<li>서비스 지속 가능성<br>  dos, DDos 방지</li>
</ul>
<h2>네트워크 계층과 보안</h2>
<ul>
<li>보안에 대한 철학이 없는 상태로 설계된 네트워크라서 각 계층별로 취약점이 계속 발견</li>
<li>발견될 때마다 보안기술이 등장하여 땜빵친다.</li>
<li>네트워크 계층 자체에는 보안에 대한 개념이 전혀 없다.</li>
<li>개별적으로 구현이 되어서 적용된다.</li>
</ul>
<h2>현실</h2>
<ul>
<li>누구나 탈취자가 될 수 있다.</li>
<li>wireshark 켜면 패킷 다 볼 수 있다.</li>
<li>패킷, 세그먼트, app 메시지 다 나오고 src, dst 및 데이터 모든 활동을 알 수 있다.(평문으로 보냈다고 가정했을 때)</li>
<li>tor 툴을 사용하면 적어도 dst 는 숨겨준다. 대신 존나 느리다. (완전한 익명성이 보장 안된다던데?)</li>
<li>웹 차단은 어떻게 이루어지는가에 대한 생각도 해야한다.<br>  지정된 블랙리스트 사이트를 통신사에서 캐치하여 막는다.<br>  ip 기준으로 판단하므로 국가 판단, 특정 사이트 판단 가능.<br>  사실상 ip 주소가 아니라, http 헤더의 host 이름으로 검열하게 된다!</li>
<li>프록시를 통해 차단을 우회한다.<br>  보통 프록시 서버는 차단안함.<br>  통제가 심한 곳은 프록시도 차단하여 가두리 양식한다.</li>
</ul>
<h2>암호화</h2>
<ul>
<li>대칭키<br>  암호화와 복호화에 사용하는 키가 같다.<br>  수신자와 송신자가 동일한 키를 공유하고 있어야 함.<br>  두 호스트가 직접 공유해야 한다.<br>  암호화 복호화에 연산이 적다.</li>
<li>비대칭키<br>  암호화와 복호화에 사용되는 키가 다르다.<br>  각자 2 개의 키를 가지고 있다.<br>  하나는 모두에게 공개할 수 있고 다른 하나는 개인만 가지고 있다.<br>  키를 직접 공유하지 않아도 된다.<br>  개인키로 암호화 공개키로 복호화, 그 반대의 방식이 일치하는 유용한 특성을 지닌다.<br>  수학적인 연산이 많이 든다.</li>
<li>실제로는 대칭키와 비대칭키 방식이 혼용됨.<br>  즉 공유된 공개키로 메세지를 보내고 스스로 복호화하는 방식인듯</li>
</ul>
<h2>인증</h2>
<ul>
<li>공개키 방식을 이용해 인증함.</li>
<li>먼저 개인키로 암호화한 후 공개키로 복호화하여 특정 메세지가 나오면 인증으로 판단.</li>
<li>전자 서명도 동일한 원리.</li>
<li>모든 메시지를 다 암호화하는것은 연산량이 많으므로 보통 메시지의 해쉬값을 암호화한다.</li>
</ul>
<h2>공개키 문제</h2>
<ul>
<li>공개키는 누군가로부터 제공받는다.</li>
<li>누군가 공개키를 잘못된것을 주면 다른 누군가가 풀어볼 수 있게 된다.</li>
<li>그래서 공개키 인증서가 등장.</li>
<li>인증기관이 공개키 주인과 공개키를 세트로 적어둔다.</li>
<li>인증기관은 인증기관의 개인키로 암호화함.</li>
<li>그렇다면 인증기관은 어떻게 신뢰할 것인가?</li>
<li>상용 브라우저는 설치될 때 인증서가 하드코딩된다.</li>
<li>원래 인증서는 서버에서 가지고 있어야함.</li>
<li>우리나라는 반대로 유저가 가지고있는 이상한 구조.</li>
</ul>
<h2>SSL - Secure Socket Layer, TLS(transport layer security)</h2>
<ul>
<li>네트워크를 사용하는 것은 대부분 http 웹 서비스</li>
<li>바로 아래 계층이 tcp/udp 라서 이것들이 제공하는 기능을 쓸 수 밖에 없다.</li>
<li>TCP 는 신뢰성, 교통관리 순서 보장 등은 있지만 보안은 없음.</li>
<li>그래서 임시방편으로 계층 하나를 더 만든것처럼 만듬.</li>
<li>app 계층과 전송 계층 사이의 계층을 만듬</li>
<li>일종의 네트워크 라이브러리이다.</li>
<li>app 계층에서 내려오는 메시지를 암호화하고 tcp 로 내보내는 개념이다.</li>
<li>TCP 를 사용하되 안전하게 사용하도록 하는 라이브러리.</li>
<li>TCP 위에서 작동하므로 TCP 커넥션이 있어야함.</li>
</ul>
<h2>HTTPS</h2>
<ul>
<li>메세지를 그냥 보내지 않고 SSL 라이브러리를 이용해 보낸다.</li>
<li>그것만 빼면 HTTP 와 동일하다.</li>
<li>HTTP + SSL = HTTPS</li>
</ul>
<h2>HTTPS 과정</h2>
<ul>
<li>SSL 은 TCP 기반이므로 먼저 TCP 커넥션이 필요함.</li>
<li>인증과정을 통해 키를 생성하고 안전한? 통신을 수행한다.</li>
<li>실제로 키는 4 개 정도 만들어지고 각자 역할이 다르다.</li>
<li>키 유출시 피해를 최소화하기 위함.</li>
<li>서버가 누군지 확신하는 방법!</li>
<li>서버가 유저에게 정상적인 서버라는 인증서를 주면 그걸 믿고 유저는 활동함.</li>
<li>한국은 유저가 공인인증서를 가지고 있고 서버가 인증을 받으므로 유저가 불편하고 피싱 등의 문제 있음.</li>
</ul>
<h2>HTTPS record</h2>
<ul>
<li>HTTPS 계층은 app 메세지를 SSL record 라는 것으로 만든다.</li>
<li>이 레코드에는 기존 메세지에 MAC(message authentication code) 를 추가한다.</li>
<li>MAC 은 생성된 보안 키와 메세지를 합쳐 해쉬 함수통과 시킨 해쉬 값임.</li>
<li>메시지 데이터는 키로 암호화된 데이터가 들어감.</li>
<li>이 record 가 최종적으로 TCP 세그먼트의 데이터에 들어가게 된다.</li>
<li>이렇게 만들어진 IP 패킷을 스니핑하면 src, dst 는 알 수 있지만 내용은 모르게 된다.</li>
<li>dst 도 숨기려면 TOR 같은 툴을 사용한다.</li>
<li>이 메세지를 읽을 수도 없고 변조한다면 해쉬가 깨져서 들킨다.</li>
</ul>
<h2>그래도 해킹</h2>
<ul>
<li>데이터를 깔 수는 없지만 https 레코드 순서를 바꿔버릴 수는 있다.</li>
<li>tcp 는 순서를 보장하므로 순서가 뒤집히면 재전송을 계속한다.</li>
<li>레코드 통째로 바꾸는건 어렵지 않다.</li>
<li>이를 reordering 이라고 한다.</li>
<li>이걸 막기 위해 레코드에 seq 를 붙인다. - TCP 의 seq 와 다르다!<br>  레코드의 순서를 카운트하는 역할임.<br>  이 seq 가 다르면 누군가 장난친것임.</li>
<li>TCP FIN 을 강제로 보내버린다면 문제를 일읠 수 있다.</li>
<li>이를 방지하기 위해 record 에 type 필드를 넣어줌.<br>  정말 메세지가 다 보내졌는지 여부를 나타냄.</li>
<li>seq, type, data 를 합쳐서 해쉬를 만들기 때문에, 전송량이 많아지진 않는다!</li>
<li>이 모든 보안 기능을 SSL 에서 보장해준다.</li>
<li>HTTPS 서비스하려면 인증기관에서 인증을 받아야한다.</li>
</ul>
<h2>방화벽</h2>
<ul>
<li>게이트웨이(라우터 등)가 패킷을 감시하는 모니터링 디바이스다.</li>
<li>들어오고 나가는 패킷을 감시할 수 있는 위치에 있다.<br>  outgoing, incoming 패킷을 감시하고 조건부 drop 한다.</li>
<li>대부분의 게이트웨이는 방화벽이 설치되어 있다.</li>
<li>필터링 정책들은 기관마다 다른데 방화벽의 패킷 drop 으로 구현한다.</li>
<li>웹 서버를 차단하기 위해 라우터가 포트 번호도 봐야하기 때문에 계층 침범한다.<br>  라우터는 정말 많은 일을 한다..</li>
<li>웹 서버로만 사용하려면 80 번 포트 제외 다른 dst 포트 모두 drop 시켜서 정책 구현.</li>
</ul>
<h2>ssh 패킷 드랍</h2>
<ul>
<li>ssh 는 기본적으로 22 포트 사용.</li>
<li>ssh 도 네트워크 연결 프로토콜.</li>
<li>보통 원격접속에 사용되지만 일종의 서버, 클라이언트 개념으로도 사용가능.</li>
<li>만약 80 포트만 방화벽에 의해 차단되면 22 번 포트 ssh 연결을 통해 DoS 공격이 가능.</li>
</ul>
<h2>방화벽 ACL - Access Control Lists</h2>
<ul>
<li>방화벽이 드랍할 규칙 테이블</li>
<li>일반 사용자에게는 http, dns 같은 것만 있으면 큰 무리가 없다.</li>
<li>그래서 ssh 같은 건 추가적으로 방화벽 해제가 필요하다.</li>
<li>TCP 커넥션을 체크해야 더 안전하므로 현재는 Stateful Packet Filtering 을 방화벽에 적용한다.</li>
</ul>
