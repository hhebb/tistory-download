<h1>15 강</h1>
<p>그래프 탐색 핵심 유형</p>
<h2>바이러스</h2>
<ul>
<li>난이도 - 하</li>
<li>유형 - dfs, bfs</li>
<li>비고<br />쉽다. 기초 탐색을 수해할 줄 알면 된다.<br />그 외에, 문제에서 요구하는 추가 정보를 잘 구현해줄수 있어야한다.<br />연결된 모든 노드들을 구하면 된다.<br />노드갯수가 적으므로 재귀 dfs 빠르게 푸는것이 유리함.</li>
</ul>
<pre class="vim"><code># 바이러스
from collections import deque

n = int(input())
m = int(input())

graph = [[] for _ in range(n+1)]

for _ in range(m):
    src, dst = list(map(int, input().split()))
    graph[src].append(dst)
    graph[dst].append(src)


def bfs():
    q = deque([1])
    infected = [1]
    while q:
        here = q.popleft()
        for there in graph[here]:
            if there not in infected:
                infected.append(there)
                q.append(there)
    print(len(infected)-1)

bfs()</code></pre>
<h2>유기농 배추</h2>
<ul>
<li>난이도 - 하</li>
<li>유형 - dfs, bfs</li>
<li>핵심
<ul>
<li>그래프 기초 탐색을 할 줄 알아야 한다.</li>
<li>모든 원소에 대해 탐색을 시도하고, 총 탐색 횟수가 정답이다.</li>
<li>체크된곳, 배추가 없는곳 모두 무시하며 탐색을 하게 될 것이다.</li>
</ul>
</li>
<li>비고<br />쉽다.<br />전형적인 flood fill 문제다.<br />2 차원 배열을 그래프 문제 중 가장 기초 중의 기초 문제이다.<br />재귀 dfs 로 풀 수 있지만, 이때는 재귀가 1000 넘어가므로 sys.setrecurtionlimit 을 사용해야함.</li>
</ul>
<pre class="maxima"><code># 유기농 배추
from collections import deque

tc = 1#int(input())

dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

def bfs(matrix, r_, c_, check):
    #check = [[False] * len(matrix[0]) for _ in range(len(matrix))]
    q = deque([(r_, c_)])
    check[r_][c_] = True
    count = 0
    while q:
        r, c = q.popleft()
        for d in range(4):
            next_r, next_c = r + dr[d], c + dc[d]
            if not(next_r &gt;= 0 and next_r &lt; len(matrix) and next_c &gt;= 0 and next_c &lt; len(matrix[0])):
                continue
            if not check[next_r][next_c] and matrix[next_r][next_c]:
                check[next_r][next_c] = True
                q.append((next_r, next_c))

for _ in range(tc):
    col, row, k = 5, 4, 6#map(int, input().split())
    matrix = [[0] * col for _ in range(row)]
    check = [[False] * col for _ in range(row)]
    answer = 0

    for i in range(k):
        c, r = map(int, data[i].split())#map(int, input().split())
        matrix[r][c] = 1

    #for i in range(len(matrix)):
        #print(matrix[i])
    # 풀이
    for i in range(row):
        for j in range(col):
            if matrix[i][j] == 1 and not check[i][j]:
                answer += 1
                bfs(matrix, i, j, check)
    print(answer)</code></pre>
<h2>효율적인 해킹</h2>
<ul>
<li>
<p>난이도 - 하</p>
</li>
<li>
<p>유형 - bfs, dfs</p>
</li>
<li>
<p>핵심<br />그냥 bfs, dfs 돌리면 됨.<br />입력 사이즈가 커서 bfs 가 더 유리하다.</p>
</li>
<li>
<p>비고<br />시간초과의 늪에 빠졌는데 이유를 발견하지 못했다.<br />모범 답안과 하나도 다르게 하지 않은듯한데 대체 어디서 걸리는지 모르겠다.<br />문제 자체는 쉬운데 정답조건이 참 까다롭다.</p>
<p>그런데 bfs 할 때 check 하는 거 실수하기도 했다.<br />언제나 내 잘못이 먼저인데 언제나 깨닫는게 쉽지 않다.<br />결국 경험과 실력이다.</p>
</li>
</ul>
<pre class="vim"><code># 효율적인 해킹
from collections import deque

n, m = 5, 4#map(int, input().split())
graph = [[] for _ in range(n+1)]
result = []
max_val = -1

for i in range(m):
    dst, src = map(int, data[i].split())#map(int, input().split())
    graph[src].append(dst)

def bfs(node):
    check = [[] for _ in range(n+1)]
    count = 1
    q = deque([node])
    check[node] = True
    while q:
        here = q.popleft()
        for there in graph[here]:
            if not check[there]:
                q.append(there)
                count += 1
                check[there] = True
    return count

for i in range(1, n+1):
    c = bfs(i)
    if c &gt; max_val:
        result = [i]
        max_val = c
    elif c == max_val:
        result.append(i)
        max_val = c

for i in result:
    print(i, end=' ')</code></pre>