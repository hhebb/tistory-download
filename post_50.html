<h2>출처</h2>
<p>프로그래머스</p>
<h2>난이도</h2>
<p>프로그래머스 level 2</p>
<h2>유형</h2>
<p>소인수분해</p>
<p>소수 판별</p>
<p>최소 공배수</p>
<h2>특이사항</h2>
<p>소인수 분해 활용</p>
<p>소수 판별 활용</p>
<p>최소 공배수 계산법 필요</p>
<h2>총평</h2>
<p>여러개의 공통된 최소 공배수를 구하는 것이라서 기준 숫자(최댓값)을 기준으로 잡음.</p>
<p>모든 약수들을 구헤서 기준 수에 포함 안된 것들을 추가해주는 단순한 알고리즘이다.</p>
<p>하지만 중복되는 약수, 여러번 나오는 약수를 처리하는 데 꽤 애먹었음.</p>
<p>먼저 지면에 순서대로 풀어보는 습관이 필요한 듯.</p>
<p>&nbsp;</p>
<pre id="code_1600772819467" class="python" data-ke-language="python" data-ke-type="codeblock"><code>def solution(arr):
    answer = 1
    arr.sort(reverse=True)
    elements = [[] for i in range(len(arr))]
    container = [2, 3]
    
    # 소수 구해놓기
    for num in range(3, 101):
        for n in range(2, num-1):
            if num % n == 0:
                break
            else:
                if n == num - 2:
                    container.append(num)
                continue
    
    
    
    # 소인수 분해 해놓기
    for idx, num in enumerate(arr):
        tmp_num = num
        con_idx = 0
        
        while con_idx != len(container):
            if tmp_num % container[con_idx] == 0:
                elements[idx].append(container[con_idx])
                tmp_num /= container[con_idx]
                con_idx = 0
            else:
                con_idx += 1
                 
    

    answer_elem = elements[0].copy()
    
    for elem in elements[1:]:
        tmp_elem = answer_elem.copy()
        wait_elem = []
        
        while len(elem) &gt; 0:
            num = elem.pop(0)
            if num not in tmp_elem:
                wait_elem.append(num)
                answer_elem.append(num)
            else:
                tmp_elem.pop(tmp_elem.index(num))
        #answer_elem.extend(wait_elem)
        
    for elem in answer_elem:
        answer *= elem
    return answer</code></pre>