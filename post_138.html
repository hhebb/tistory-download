<h1>동기화</h1>
<h2>동기화</h2>
<ul>
<li>다중 프로그래밍 시스템<br>여러 개의 프로세스들이 존재<br>프로세스들은 독립적으로 동작함.<br>공유 자원 또는 데이터가 있을 때 문제가 발생 할 수 있다.</li>
<li>동기화 - synchronization<br>프로세스 간 동작을 맞추는 것<br>프로세스 간 서로 정보를 공유하는 것<br>프로세스 간 대화 하는 것</li>
</ul>
<h2>프로세스간 Asynchronous and Concurrent</h2>
<ul>
<li>비동기적 - asynchrounous<br>프로세스들이 서로에 대해 모름</li>
<li>병행적 - concurrent<br>여러 개의 프로세스들이 동시에 시스템에 존재<br>병행 수행중인 비동기적 프로세스들이 공유자원에 동시 접근할 때 문제 발생 가능!</li>
</ul>
<h2>용어</h2>
<p>shared data (critical data) - 여러 프로세스들이 공유하는 데이터<br>critical section - 임계 영역, 공유 데이터를 접근하는 코드 영역 (code segment)<br>mutual exclusion - 상호 배제, 둘 이상의 프로세스가 동시에 임계 영역에 진입하는 것을 막는 것.</p>
<h2>race condition</h2>
<p>concurrent 프로세스에서 임계영역에 동시에 접근할 때, 메모리에 결과는 정확히 예측할 수 없다?<br>기계어 명령의 수행 상황에 따라서 메모리에 쓰이는 결과값이 달라질 수 있다. - race condition</p>
<ul>
<li>기계어 명령 (machine instruction)의 특성<br>원자성, 분리불가능<br>명령 실행도중 인터럽트 받지 않는다.<br>코드는 기계어로 번역되어 수행된다.</li>
</ul>
<h2>mutual exclusion - 상호 배제</h2>
<p>하나의 프로세스가 임계영역cs 에 있을 때 다른 프로세스가 cs 에 진입하지 못하게 하는 것.</p>
<h2>ME 를 구현하는 SW solution</h2>
<p>primitives - 기본 연산</p>
<ul>
<li>enterCS() primitive<br>cs 진입 전 다른 프로세스가 cs 에 있는지 검사</li>
<li>exitCS() primitive<br>cs 벗어날 때 후처리.</li>
</ul>
<h2>ME primitive 요구사항</h2>
<ol>
<li>mutual exclusion - cs 에 프로세스가 있을 때 다른 프로세스가 진입하면 안된다.</li>
<li>progress - cs 밖에 있는 다른 프로세스가 cs 에 진입하는 것을 방해 하면 안됨</li>
<li>bounded waiting - 한정 대기 시간을 가져야함</li>
</ol>
<h2>Two Process Mutual Exclusion</h2>
<p>턴(차례) 를 넘기며 상호 배제를 구현.<br>자신의 턴이 아니면 대기하다가 턴을 받으면 cs 에 진입<br>progress 조건을 위배한다.<br>한 프로세스가 2 번 연속 cs 진입 불가.<br>cs 에서 프로세스가 종료되면 턴을 넘겨주지 못하여 다른 프로세스가 진입 못함.</p>
<h2>TPME 2</h2>
<p>버전 1 보완.<br>턴 대신 각각 플래그를 두어 진입 가능 판단.<br>상호 배제 조건 위배<br>도중에 preemption 이 일어나면 플래그 때문에 여러 프로세스가 cs 에 접근할 수 있다.<br>pregress, bounded waiting 조건 위배<br>플래그를 한 번 더 확인하더라도 preemption 이 그 다음에 일어난다면 영영 진입을 못한다.</p>
<h2>dekker 알고리즘</h2>
<p>two process ME 를 보장하는 최초의 알고리즘<br>턴과 플래그를 모두 두어서 판단한다.<br>자신의 차례가 아니면 플래그를 내리고 대기.<br>다른 프로세스가 cs 를 나오면서 턴을 바꾸고 플래그를 내리면 비로소 자신이 진입할 수 있다.<br>각 단계마다 preemption 이 일어나도 ME 를 보장한다!</p>
<h2>peterson 알고리즘</h2>
<p>dekker 보다 간단하게 구현<br>각각 턴을 양보하는 로직이 있어 늦게 양보하는 프로세스가 먼저 cs 에 진입한다.</p>
<h2>N-Process ME - 다익스트라 알고리즘</h2>
<p>플래그를 3 개의 상태로 나타냄.<br>idle - 프로세스가 cs 진입 시도하지 않는 상태<br>want_in - cs 진입 시도 1 단계 일 때<br>in_cs - cs 진입 시도 2 단계 및 cs 내에 있을 때<br>in_cs 상태에 자신말고 아무도 없으면 비로소 cs 에 들어갈 수 있음을 보장한다!<br>만약 in_cs 상태인 프로세스가 더 있다면 다시 진입 시도 1 단계로 가서 반복함.<br>이로써 N process ME 를 해결함.</p>
<h2>SW 솔루션</h2>
<p>dekker, 다익스트라 등의 솔루션<br>반복 과정 때문에 속도가 느리고 구현이 복잡하다.<br>중요한것은 이 알고리즘의 코드 자체도 기계어 실행 도중 preemption 이 일어날 수 있다.<br>interrupt 를 방지할 수 있긴 하지만 오버헤드가 생김</p>
<ul>
<li>busy waiting 이 발생한다.<br>그저 대기하는 상태임에도 반복문을 돌며 진입을 시도하여 오버헤드가 생긴다.</li>
</ul>
<h2>ME HW 솔루션</h2>
<p>sw 솔루션은 비효율적.<br><code>TestAndSet</code> 기계어 명령을 만듬<br>실행 중 인터럽트(preemption) 을 받지 않는다.</p>
<h2>TAS instruction</h2>
<p>값을 검사하고 값을 할당하는 것을 한 번에 수행!<br>TAS 는 lock 변수를 두어서 조작하며 아주 단순하게 ME 해결한다.<br>하지만 3 개 이상의 프로세스일 때 bounded waiting 조건이 위배된다.<br>다음 프로세스가 도착하여 먼저 들어가버리면 처음 대기하던 프로세스가 영영 진입 못할수도 있다.</p>
<h2>TAS N-Process ME</h2>
<p>waiting 이라는 불리언 배열을 이용해 먼저 온 순서대로 진입시켜 bounded waiting 을 해결한다.</p>
<h2>HW 솔루션</h2>
<p>TAS 를 이용해 구현이 간단해졌다.<br>하지만 여전히 busy waiting 이 존재하고 이로 인해 효율성이 낮아진다.</p>
<h2>OS 솔루션</h2>
<p>busy solution 을 해결하기 위해 등장함.</p>
<h2>Spinlock</h2>
<p>정수형 변수이다.<br>초기화, P(), V() 연산으로만 접근이 가능함.<br>atomic(indivisible) 연산이다.<br>이는 OS 가 보장하도록 되어 있다.</p>
<ul>
<li>P(S) 연산 - 자물쇠를 잠그는 과장<br>S 가 0 보다 커질때까지 기다리다가<br>S 가 0 보다 클 때 S 를 감소시키고 나간다.</li>
<li>V(S) 연산 - 자물쇠를 푸는 과정<br>S 를 하나 증가시키고 나간다.</li>
</ul>
<h2>스핀락 동작</h2>
<p>cs 에 들어갈 때 자물쇠를 잠그는 P 연산.<br>나갈 때 자물쇠를 푸는 V 연산<br>스핀락 변수를 조작하는 것임.<br>플래그를 두는 sw 솔루션과 유사하지만, OS 가 atomic 한 연산을 보장하므로 preemption 을 방지한다.<br>그래서 OS 의 도움으로 ME 문제를 단순히 해결할 수 있음</p>
<h2>스핀락 문제점</h2>
<p>프로세스가 들어간 상태에서 프로세스가 종료되면 일을 못한다.<br>P, V 는 한 번에 처리됨을 보장하는데 루프도 포함이므로.<br>그래서 멀티 프로세서 시스템에서만 사용이 가능하다.<br>그리고, 스핀락은 busy waiting 을 계속 가지고 있음. P 의 대기 반복문에 해당</p>
<h2>semaphore</h2>
<p>다익스트라가 제안함.<br>busy waiting 문제를 해결함.<br>세마포어는 음이 아닌 정수형 변수.<br>역시 초기화, P(), V() 연산으로만 접근 가능.<br>P - probern<br>V - verhogen</p>
<ul>
<li>임의의 S 변수 하나에 ready queue 하나가 할당 됨.</li>
</ul>
<h2>세마포어 2</h2>
<ol>
<li>binary semaphore<br>S 가 0, 1 두 종류의 값만 갖는 경우<br>ME 문제 해결용으로만 사용</li>
<li>counting semaphore<br>S 가 0 이상의 정수 값을 가지는 경우<br>생산자-소비자 문제 해결에 사용</li>
</ol>
<h2>세마포어 3</h2>
<ul>
<li>P(S) 연산 - 자물쇠를 잠그는 연산<br>S 가 0 이면 스핀락처럼 뺑뺑이 돌지 않고 레디 큐를 할당하고 여기서 기다리게 하고 나온다.</li>
<li>V(S) 연산 - 레디 큐에 기다리고 있는 프로세스가 있다면 그 중 하나를 깨우고 아니면 S 를 올리고 나온다.<br>모두 OS 에서 지원하는 atomic 연산이라 한 번에 실해된다는 것을 보장한다.<br>현존하는 실제 OS 에서 사용하는 ME 솔루션이다.</li>
</ul>
<h2>세마포어로 해결 가능한 동기화 문제들</h2>
<ol>
<li>상호 배제 문제</li>
<li>프로세스 동기화 문제</li>
<li>생산자-소비자 문제</li>
<li>리더-라이터 문제</li>
<li>철악자들의 저녁 문제</li>
</ol>
<h2>세마포어 - ME</h2>
<p>스핀락과 유사하지만, 프로세스를 뺑뺑이 돌리지 않고 레디 큐에서 대기하도록 한다.</p>
<h2>세마포어 - 프로세스 동기화</h2>
<p>프로세스들의 실행 순서 맞추기<br>sync 라는 세마포어 변수를 두어서 순서를 맞춘다..</p>
<h2>세마포어 - 생산자 소비자 문제</h2>
<p>생산자 프로세스 - 메시지, 데이터를 생성하는 프로세스 그룹<br>소비자 프로세스 - 메시지, 데이터를 전달받는 프로세스 그룹</p>
<h2>single buffer 생산자 소비자</h2>
<p>2 개의 세마포어 변수를 둔다.<br>consumed, produced 변수<br>생산자 - P(con) - buffer 대입 - V(prod)<br>소비자 - P(prod) - buffer 에서 꺼냄 - V(con)</p>
<h2>N-buffer 생산자 소비자</h2>
<p>원형 큐를 버퍼로 사용<br>nrefull, nreempty, mutexP, mutexC 세마포어 변수 사용<br>mutexP, mutexC 변수는 한 번에 하나만 들어갈 수 있도록 제어</p>
<h2>세마포어 - reader writer 문제</h2>
<ul>
<li>reader<br>데이터를 읽기 연산만 수행<br>여러 개가 동시에 접근해도 된다.</li>
<li>writer<br>데이터 갱신 연산만 수행<br>여러 개가 동시에 쓰면 안된다.<br>읽는 도중 쓰거나 쓰는 도중 읽으면 안됨.</li>
<li>특징<br>데이터 무결성 보장이 필요하다.<br>reader 는 동시에 데이터 접근 가능<br>writer 는 동시 데이터 접근 시, 혹은 reader 와 writer 간에는 ME 가 필요</li>
<li>해결법<br>reader, writer 에 대한 우선권 부여<br>reader 우선 솔루션, writer 우선 솔루션</li>
</ul>
<h2>reader writer 문제 해결법</h2>
<p>wmutex, rmutex, nreaders 세마포어 변수 사용</p>
<h2>세마포어 특징</h2>
<p>no busy waiting<br>뺑뺑이 돌지 않고 레디 큐에 블락 상태로 대기한다.<br>하지만 대기 중인 프로세스를 꺠우는 순서는 비결정적이다.<br>즉, starvation 문제가 발생한다.</p>
<h2>sequencer/eventcount</h2>
<p>세마포어의 starvation 을 해결하기 위해 도입<br>은행 번호표와 비슷한 개념</p>
<ul>
<li>시퀀서<br>정수형 변수<br>번호표 기계에 해당한다.<br>0 으로 초기화되고 감소하지 않으며 커지기만 한다.<br>그래서 발생 사건들의 순서를 유지할 수 있다.<br>ticket() 연산으로만 접근이 가능하다.</li>
<li>ticket(S)<br>현재까지 ticket() 연산이 호출된 횟수 반환</li>
</ul>
<h2>eventcount</h2>
<p>*이벤트 카운트<br>정수형 변수<br>0 으로 초기화, 감소하지 않음<br>특정 사건의 발생 횟수를 기록<br>read(E), advance(E), await(E, v) 연산으로만 접근 가능</p>
<ul>
<li>read(E)<br>현재 이벤트카운트 값 반환. 번호표를 읽는 것에 해당</li>
<li>advance(E)<br>E 를 하나 올린다.<br>은행원이 대기 인원을 호출하는 것에 해당.<br>E 를 기다리고 있는 프로세스를 깨움</li>
<li>await(E, v)<br>v 는 정수형 변수<br>E &lt; v 이면 E 에 연결된 큐에 프로세스 전달 및 스케줄러 호출</li>
</ul>
<h2>Eventcount/Sequencer - ME</h2>
<p>starvation 을 해결한다.<br>은행 업무 과정과 유사하게 풀었다.</p>
<h2>Eventcount/Sequencer - 생산자 소비자 문제</h2>
<p>시퀀서 2개, 이벤트카운트 2 개(in, out) 세마포어 변수<br>ticket(), advance() 는 각각 P, V 연산에 대응됨</p>
<h2>이벤트카운트/시퀀서 특징</h2>
<p>no busy waiting<br>no starvation - 우선순위로 처리<br>세마포어 보다 더 low level 컨트롤 가능. 순서 컨트롤</p>
<h2>ME - 언어 레벨</h2>
<p>OS 솔루션 까지는 유연하지만 쓰기가 어렵고 논리적 오류 발생 가능성이 높다.<br>이까지는 low level 메커니즘이라고 한다.<br>언어레벨은 high level 솔루션이다.<br>좀 더 쓰기 쉬운 방법을 제공한다.</p>
<h2>high-level 메커니즘</h2>
<p>언어 레벨의 구조<br>객체지향적인 방법과 유사</p>
<h2>monitor</h2>
<p>공유 데이터와 cs 를 모아놓은 방이라고 생각.<br>단 한 명만 들어갈 수 있는 책방.<br>conditional variable 존재<br>wait(), signal() 연산이 있다.</p>
<h2>모니터 구조</h2>
<ol>
<li>entry queue - 모니터 내의 프로시져 수만큼 존재. 랭귀지가 보장해줌.</li>
<li>ME - 모니터 내에는 항상 하나의 프로세스만 진입 가능</li>
<li>information hiding - 정보 은폐. 공유 데이터는 모니터 내의 프로세스만 접근 가능</li>
<li>condition queue - 조건 큐. 모니터 내의 특정 이벤트를 기다리는 프로세스가 대기하는 곳</li>
<li>signaler queue - 신호제공자 큐. 항상 하나의 신호제공자 큐가 존재. 임시 대기실.</li>
</ol>
<h2>모니터 - 자원 할당 문제</h2>
<p>엔트리 큐 - release, request 두 개가 있음. 책 반납, 대출에 해당<br>컨디션 큐 - 빌릴 수 있는지 에 대한 큐<br>시그널 큐 - 시그널을 보내 컨디션 큐에 있는 것 하나를 꺠움.<br>세마포어, s/e 로 해결하려면 복잡하다.<br>모니터는 매우 간단하게 코드로 작성할 수 있다.(외부적)</p>
<p>다시 공부하기</p>
