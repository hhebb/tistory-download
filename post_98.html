<h1>6 강</h1>
<p>재귀.<br>아주 중요하다. 하지만 잘 써야 한다.<br>사이즈 보고 재귀로 안될 것 같으면 뻐르게 DP, 스택으로 방향을 돌려야 한다.</p>
<h2>피보나치 수</h2>
<ul>
<li>난이도 - 하</li>
<li>유형 - 재귀, DP</li>
<li>핵심<br>너무 유명하고 기본적인 문제.<br>일반 재귀로 풀면 시간초과가 난다.<br>중복문제가 너무 많아지므로 DP 를 사용해야 한다.<br>혹은 단순 순차 계산으로 풀 수도 있다.</li>
<li>비고<br>DP 테이블이 아니더라도, 변수 2, 3 개 를 이용해 바꿔치기하며 계산 가능.<br>결국 구하는것이 마지막 피보나치 수 이므로 이렇게 가능하다.</li>
</ul>
<pre><code># 피보나치 수
n = 10
a, b = 0, 1
for _ in range(n-1):
    a, b = b, a+b
print(b)</code></pre><h2>Z</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - 재귀</p>
</li>
<li><p>핵심<br>매 스텝마다 4 분할 하는 것을 캐치하여 재귀함수를 구현한다.</p>
</li>
<li><p>비고<br>옛날에 풀다가 포기한 것으로 기억된다.<br>이번에는 더 성장을 해서 설계를 할 수 있었다.<br>그런데 계속되는 실수로 푸는데 3 시간 걸렸다.<br>아이디어는 정말 간단한데 난 아직 구현력이 한참 멀었다고 생각한다.<br>그리고 3 시간 중 1 시간은 함수 반환만 하고 출력을 안한 것 때문에 헛발질 했다.<br>이걸 깨달았을 때 진짜 헛웃음 나오고 미쳐돌아버리는줄 알았다.</p>
<p>1 년인가 2 년전에 처음 코테를 시작할 때 백준 풀면서 느꼈던 멘붕이 다시 찾아온다.<br>그 때 느꼈던 자괴감, 허탈함 등이 다시 나타난다.<br>틀렸습니다! 가 계속 뜰 때 받는 스트레스, 진짜 사소한 거 하나 때문에 틀렸다는걸 알았을 때 허무함.<br>들인 시간에 비해 얻는게 쥐꼬리만한 너무 가혹한 백준 저지.<br>무한한 현타의 시간만 주었던 백준.<br>그래서 내가 때려쳤었는지도 모른다.<br>오늘도 현타가 씨게 왔는데 이걸 계속 할 수 있을까?<br>여기서 수백 수천 문제를 풀어야 하는데 이게 계속 이렇게 스트레스 받으면 버틸 수 있을까?<br>프로그래머스가 참 친절한 저지 사이트라는 것을 느끼게 된다.</p>
</li>
</ul>
<pre><code># Z

N, r, c = list(map(int, input().split()))

def search(size, order, coord):
    if size == 1:
        if coord == (r, c):
            return order
        elif coord[0] + 1 == r and coord[1] + 1 == c:
            return order + 3
        elif coord[0] == r and coord[1] + 1 == c:
            return order + 1
        elif coord[0] + 1 == r and coord[1] == c:
            return order + 2


    if r &lt; coord[0] + 2 ** (size - 1):
        if c &lt; coord[1] + 2 ** (size - 1):
            return search(size-1, order, coord)
        else:
            return search(size-1, 
                          order + 2 ** (2*(size-1)), 
                          (coord[0], coord[1] + 2 ** (size-1)))

    else:
        if c &lt; coord[1] + 2 ** (size - 1):
            return search(size-1, 
                          order + 2 * 2 ** (2*(size-1)),
                          (coord[0] + 2 ** (size-1), coord[1]))
        else:
            return search(size-1, 
                          order + 3 * 2 ** (2*(size-1)), 
                          (coord[0] + 2 ** (size-1), coord[1] + 2 ** (size-1)))

print(search(N, 0, (0,0)))</code></pre><h2>0 만들기</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - 완전탐색, 재귀</p>
</li>
<li><p>핵심<br>   제한이 작기 때문에 완전탐색으로 풀 수 있다.<br>   매 스텝마다 연산자를 하나씩 골라서 끝까지 채운다.<br>   그 이후에 최종적으로 수식을 조립하고 계산한다.<br>   eval 활용</p>
</li>
<li><p>비고<br>단순하지만 이렇게 단계를 나누어 푸는 방법이 좋다.<br>그렇지 않고 매 스텝마다 수식을 조립하려는 생각을 하면 복잡해진다.<br>재귀를 반복하며서 매 스텝마다 고른 결과는 인자로 전달해도 되고<br>전역 변수를 조작하면서 백트랙처럼 복원해줘도 된다.<br>즉 변경된 데이터는 잘 다루기만 하면 어떤 방식으로든 사용가능</p>
<p>쉬운데 백준 사이트는 정답을 받기가 참 까다롭다.<br>형식 실수를 자주 범하게 되고, 또 유의사항을 잘 표기 안 해놓는다.</p>
</li>
</ul>
<pre><code># 0 만들기
tc = int(input())

def recurse(pos, oper):
    global n

    if pos == n-1:
        tmp = result[:]
        # 수식 조립
        for i in range(len(oper)):
            tmp.insert(i*2 + 1, oper[i])

        # 수식 정리
        res = []
        for i in tmp:
            if i != &#39; &#39;:
                res.append(i)
        res = &#39;&#39;.join(res)
        res = eval(res)

        if res == 0:
            print(&#39;&#39;.join(tmp))
        return

    recurse(pos+1, oper+&#39; &#39;)
    recurse(pos+1, oper+&#39;+&#39;)
    recurse(pos+1, oper+&#39;-&#39;)

for _ in range(tc):
    n = int(input())
    result = [str(i + 1) for i  in range(n)]
    recurse(0, &#39;&#39;)
    print()</code></pre>