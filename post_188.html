<h1>TCP 계속</h1>
<h2>congestion control</h2>
<ul>
<li>유일하게 알 수 있는 receriver 피드백을 이용해 네트워크 상황을 유추한다.</li>
<li>직관적으로 생각하면 네트워크의 가장 용량이 적은 곳에서 병목이 생김.</li>
<li>네트워크 전체는 모두가 사용하므로 함부로 사용하면 안된다.<br>  그래서 통신할 때 처음에 작은 양부터 보내기 시작한다.</li>
</ul>
<h2>TCP Congestion control</h2>
<ul>
<li></li>
</ul>
<ol>
<li>slow start<br> 최대한 조심스럽게 시작한다.<br> 네트워크 혼잡을 피하기 위해<br> 천천히 시작하지만, 사실 지수적으로 늘리며 통신하기 시작한다. (윈도우 사이즈를 늘린다는 의미)<br> 너무 천천히 증가하면 효율이 떨어지므로.<br> threshold 도달하면 지수적 증가를 멈춘다.</li>
<li>additive increse<br> threshold 도달시 선형적으로 통신량을 증가한다.</li>
<li>multiplicative decrease<br> 만약 계속 증가하다가 패킷 유실이 탐지되었을 때, 윈도우 사이즈를 절반으로 뚝 떨어뜨린다.<br> 패킷 유실이 네트워크 상황이 악화되었다고 유추한다.<br> 그리고 다시 선형적으로 늘린다.<br> 확 떨어뜨리는 이유는, 혼잡 상황때는 모두가 확 빠져야 병목이 해소되기 때문이다.</li>
</ol>
<h2>MSS - Maximum Segment Size</h2>
<ul>
<li>위에서 말한 통신량의 단위.</li>
<li>윈도우 사이즈는 곧 ACK 를 받지 않고 한 번에 보낼 수 있는 세그먼트 갯수.</li>
<li>윈도우 사이즈는 MSS 를 직접 조절한다.</li>
<li>MSS 가 지수적으로 증가한다.</li>
<li>500 byte 짜리라고 한다.</li>
</ul>
<h2>그래프</h2>
<ul>
<li>위의 3 가지 phase 를 시간에 따라 그래프를 그리면 톱날처럼 그리며 반복한다.</li>
<li>어떤 이상적인 위치에서 통신량이 고정되는 것은 불가능하다. 항상 변하므로.</li>
</ul>
<h2>Rate</h2>
<ul>
<li>rate = congWin / RTT</li>
<li>RTT 도 변하지만 윈도우 사이즈가 더 격하게 변한다.</li>
<li>그래서 rate 는 윈도우 사이즈에 좌우된다.</li>
<li>윈도우 사이즈는 전체 네트워크 상태에 좌우된다.</li>
<li>하지만 전체 네트워크는 개개의 행동이 만들어낸다.</li>
<li>즉, 상호적으로 영향을 주면서 영향을 받는다.</li>
</ul>
<h2>TCP Tahoe, TCP Reno</h2>
<ul>
<li>Tahoe<br>  패킷 유실이 발생되면 그 지점의 MSS 크기에서 절반을 threshold 로 설정한다.<br>  그리고 다시 MSS 1 부터 전 과정을 반복한다.<br>  즉 threshold 값이 변하는 것임.<br>  초창기 congestion control 버전<br>  이제 안쓰임.</li>
<li>Reno<br>  패킷 유실은 타임 아웃, 3 duplicate ACK? 둘 을 이용해 탐지함.<br>  타임아웃은 특정 시점 이후로 터진상황이고, 3 dup ACK 는 특정 세그먼트만 유실된 상황.<br>  Reno 는 3 duplicate ACK 에 의한 유실탐지이면, 절반으로 줄인 threshold 로 줄인다.<br>  그리고 선형적 MSS 증가를 진행한다.<br>  만약 타임아웃으로 인한 유실이면 Tahoe 처럼 진행.<br>  즉, Reno 버전은 패킷 유실 상태를 구분하여 congestion control 을 한다는 것이 중요하다.</li>
</ul>
<h2>Threshold</h2>
<ul>
<li>처음 임계값은 임의로 설정할 수 있다.</li>
<li>그 이후로는 유실 지점에서 절반으로 셋팅한다.</li>
</ul>
<h2>TCP Fairness</h2>
<ul>
<li>실제 네트워크는 2 개의 end point 가 아니라 여러개의 end point 가 사용한다.</li>
<li>각 point 는 나름대로 각자 congestion control 를 수행한다.</li>
<li>하지만 이런 상황에서 각 point 들은 공평하게 사용량을 확보하는가?</li>
<li>신기하게도 공평하게 된다..</li>
<li>2 대 의 컴퓨터의 대역폭을 조절하는 예시<br>  처음에 불공평한 상황(한쪽이 더 많은 대역폭 점유)에서 시작.<br>  한정된 대역폭을 넘어가서 패킷 유실이 일어나면 각자 점유율을 절반으로 줄이고 선형적으로 증가<br>  이를 반복하면 결국 각자 절반의 대역폭을 점유하도록 수렴한다.<br>  2 대만 아니라 모든 point 가 공평하게 나누어지게 된다.</li>
<li>TCP 의 congestion control 은 각자 조심스러운 행동을 취하며 혼잡해소를 하며 공평성도 확보하도록 한다!</li>
</ul>
<h2>정말 공평한가?</h2>
<ul>
<li>하지만 이 공평성은 TCP 연결 단위에 해당한다.</li>
<li>즉, 사용자마다 TCP 연결 갯수가 다르면 사용자 입장에서는 공평하지 않을 수 있다.</li>
</ul>
