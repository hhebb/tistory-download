<h1>위상 정렬</h1>
<ul>
<li>개념<br>그래프를 순서대로 일렬로 정렬하는 알고리즘이다.<br>그래프는 비선형이므로 정렬결과가 여러개일 수 있다.<br>단, DAG(방향성 비순환 그래프) 에 대해서만 정렬이 가능하다.</li>
<li>비고<br>사이클을 감지해내는 로직이 추가된다.<br>bfs, dfs 등의 탐색 알고리즘과 추가적인 데이터로 구현이 가능하다.<br>여러가지 정렬결과가 있을 수 있지만, bfs 와 heap 을 이용하면 하나의 결과만 얻을 수도 있다.<br>보통 bfs 를 이용한 정렬을 더 많이 사용한다.</li>
</ul>
<pre><code># heap 을 이용한 위상 정렬 - 사이클 감지 로직 포함
# indegree 를 추가로 저장하고 활용한다.

from heapq import *

graph = {node:[] for node in nodes}
in_degree = {node:0 for node in nodes}

def topological_sort():
    result = []
    #q = deque()
    heap = []

    # 그래프를 구성하면서 동시에 in-degree 를 채운다
    for src, dst in data:
        graph[src].append(dst)
        in_degree[dst] += 1

    # 최초 in-degree 가 0 인 노드를 큐에 집어넣는다.
    for node, deg in in_degree.items():
        if deg == 0:
            heappush(heap, node)#q.append(node)
            result.append(node)

    # 최대 노드 갯수만큼 방문하게 된다.
    for i in nodes:
        # 모든 노드 방문 전에 큐가 빈다면 사이클이 발생하므로 위상정렬을 할 수 없다!
        #if len(q) == 0:
        if len(heap) == 0:
            print(&#39;사이클 발생&#39;)
            return

        here = heappop(heap)#q.popleft()
        for there in graph[here]:
            in_degree[there] -= 1
            if in_degree[there] == 0:
                heappush(heap, there)#q.append(there)
                result.append(there)
    return result</code></pre><pre><code>
# dfs 를 이용한 위상 정렬 - 사이클 검출 로직 포함
# 재귀가 끝나는 시점에 결과와 종료 여부를 업데이트한다.

sort_result = []
check = {node:False for node in nodes}
finish = []

def dfs(node):
    for there in graph[node]:
        if not check[there]:
            check[there] = True
            dfs(there)
            # 방문은 했는데 완전히 끝나지않은 노드를 찾을 때 사이클 감지
        elif there not in finish:
            print(&#39;사이클&#39;, node, there)
            global sort_result
            sort_result = []
            return
    sort_result.append(node)
    finish.append(node)</code></pre>