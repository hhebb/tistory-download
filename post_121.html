<h1>16 강</h1>
<p>다익스트라, 최소 신장 트리(MST) 알고리즘</p>
<h2>해킹</h2>
<ul>
<li>난이도 - 중</li>
<li>유형 - 다익스트라 최단경로</li>
<li>핵심<ul>
<li>방향 그래프를 구성하고 시간을 거리로 환산한다.</li>
<li>모든 컴퓨터가 감염되는 시간이 각 최단시간들의 최댓값임을 캐치한다.</li>
<li>그보다, 가장 먼 거리에 있는 도달가능점을 찾는 것이라고 인지한다.</li>
<li>다익스트라는 heap 을 사용하는것이 효율적임</li>
<li>다익스트라는 O(NlogD)</li>
</ul>
</li>
<li>비고<br>감염시간은 가중치로 일종의 거리 개념으로 생각해야 한다.<br>감염이 되지 않는 즉, 그래프의 연결이 이루어지지 않는 경우도 항상 염두에 두어야한다.<br>백준은 특히 예외와 정답조건이 빡빡하다. </li>
</ul>
<pre><code># 해킹
from heapq import *
tc = int(input())

for _ in range(tc):
    n, m, start = list(map(int, input().split()))
    graph = [{} for _ in range(n+1)]

    for i in range(m):
        src, dst, t = list(map(int, input().split()))
        graph[dst][src] = t

    def dijkstra(start):
        heap = []
        heappush(heap, (0, start))
        dists = [1e9] * (len(graph) + 1)
        dists[start] = 0
        visited = [start]
        while heap:
            here_dist, here = heappop(heap)
            if here not in visited:
                visited.append(here)
            if here_dist &gt; dists[here]:
                continue

            for there in graph[here]:
                new_dist = here_dist + graph[here][there]
                if new_dist &lt; dists[there]:
                    heappush(heap, (new_dist, there))
                    dists[there] = new_dist

        return dists, visited

    dists, visited = dijkstra(start)

    max_t = -1
    for v in visited:
        max_t = max(max_t, dists[v])
    print(len(visited), max_t)</code></pre><h2>거의 최단 경로</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - 다익스트라 최단 경로</p>
</li>
<li><p>핵심</p>
<ul>
<li>최단 경로를 구하고 노드를 제외하여 총 2 번 돌린다.</li>
<li>마지막 다익스트라 돌릴 때의 최단 경로 길이를 구한다.</li>
<li>경로는 bfs 로 역추적할 수 있다.</li>
</ul>
</li>
<li><p>비고</p>
<ul>
<li>아이디어를 생각해냈고 솔루션을 냈지만, 최단경로가 하나가 아니라는 점을 간과했다.<br>최단경로를 구하는 방법을 겨우 생각해내었고 구현을 했지만, 여러개중 단 하나의 경로만 구할 수 있었다.<br>bfs 로 역추적하면 모든 최단경로를 확인할 수가 있다.<br>그러니까 내가 고안한 것은, 유일하며 최신에 갱신된 최단경로만을 확인하는 반면,<br>bfs 는 최단 경로 길이에 해당하는 경로를 모두 탐색할 수 있다. 말 그대로 그래프 완전탐색이니까.<br>여기서 bfs 는 최단 거리를 기반으로 수행한다.<br>한 칸 씩 이동하며 각 노드가 경로에 포함되는지 체크하는데, 이 부분은 타당성을 납득하기가 쉽지 않았다.<br>항상 나의 능력보다 앞서간다.</li>
</ul>
<p>그러나 문제를 전체적으로 이해하고 해결하는 플로우는 거의 근접했다.<br>해결하진 못했지만 점점 더 실력이 쌓이는것을 느낀다.</p>
</li>
</ul>
<h2>우주신</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - MST</p>
</li>
<li><p>핵심</p>
</li>
<li><p>그래프 형태로 변환해야 한다.</p>
<ul>
<li>MST 를 쓸 줄 아는가</li>
<li>좌표 상 거리를 간선의 가중치로 인지해야 한다.</li>
<li>모든 간선을 연결하다기에 노드 N 을 제곱한만큼 간선을 고려해야 한다.</li>
<li>크루스칼 알고리즘은 O(ElogE) 로 빠르므로 크루스칼을 이 문제는 N^2 logN^2 .프림은?</li>
</ul>
</li>
<li><p>비고<br>  이론을 다시 공부하고 풀어야겠다.</p>
</li>
</ul>
