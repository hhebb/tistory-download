<h1>7 강</h1>
<p>존나 어렵다.<br>입력 사이즈를 보고 로그 씌웠을 때 탐색 크기를 보고 저울질해야 한다.<br>수학적이고 획기적인 솔루션이 떠오르지 않을 때, 왠만하면 하나하나 무식하게 찾는 문제일 가능성이 높다.<br>수학 문제는 적절한 공식, 기하적인 변환 등으로 푸는 경우가 많다.<br>PS 도 그런 경우가 있지만 대부분은 무식한 솔루션으로 시작해서 효율성을 올리는 방법으로 푸는 듯 하다.<br>컴퓨팅 파워를 이용하여 무차별 대입하면 풀리지 않는 경우는 없다라는 사실을 숙지해야 한다.<br>숫자를 하나씩 올리며 탐색하면 무조건 풀린다.<br>이진 탐색은 단순히 그 탐색과정을 log 로 바꿔주는 것이다.<br>탐색하는 방식, 도구라고 생각하면 된다.<br>결국 획기적인 계산법이 아니면 무식한 방법으로 시작하여 효율을 올리는 것 둘 중 하나인듯하다.</p>
<h2>공유기 설치</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - 이진 탐색</p>
</li>
<li><p>핵심</p>
</li>
<li><p>데이터 범위가 크다면 그리고 탐색을 해야 한다면 이진 탐색을 고려해야만 한다.</p>
</li>
<li><p>공유기 사이의 gap 을 설정하고 그만큼 점프하며 공유기 갯수를 채울 수 있는지 확인한다.<br>  안되면 gap 을 줄이며 계속 진행하다가 조건에 맞으면 gap 을 출력한다.</p>
</li>
<li><p>gap 을 순차적으로 하나씩 줄이면 시간초과가 나므로 절반씩 줄이며 진행해야 한다.</p>
</li>
<li><p>이진 탐색 logn, 총 집의 갯수 20 만 곱하면 약 6,000,000 컷. 크기를 먼저 계산.</p>
</li>
<li><p>비고<br>결과적으론 gap 을 설정하는 것은 이진 탐색, 집을 탐색하는 것은 선형 탐색이다.<br>이진 탐색의 응용 문제다.<br>단순히 이진 탐색으로 수를 찾는것만 알고 있다면 응용하기 어렵다.</p>
<p>이진 탐색 문제는 어려울 수 밖에 없다<br>이진 탐색을 반복적으로 푸는 것도 알아야 한다.<br>재귀를 반복으로 만들 땐, 단순 for, while, stack 모든 방법이 있다. 적절히 바꾸는 연습을 해야 한다.</p>
<p>확실히 어려운 문제였음.<br>이진 탐색을 끼워맞춰보려고 했지만 도저히 솔루션이 떠오르지 않았음.<br>균등하게 분할해서 풀려고도 해보았고, 첫 원소부터 하나씩 차례대로 골라보려고도 했다.<br>정답은 후자에 가까웠다</p>
</li>
</ul>
<pre><code># 공유기 설치
n, c = list(map(int, input().split()))
arr = []
for _ in range(n):
    arr.append(int(input()))
    pass

# 정렬. 정렬이 되어있어야 이진 탐색할 수 있다.
arr.sort()

# 이진 탐색에서 left, right 최초 설정
start = arr[1] - arr[0]
end = arr[-1] - arr[0]
result = 0

# 이진 탐색을 반복문으로 구현
while start &lt;= end:
    print(start, end)
    cur_wifi = arr[0]                 # 기준점을 첫 집으로 설정
    mid = (end+start)//2              # gap 은 이진 탐색에서 mid
    count = 1                         # 첫 집에 무조건 설치하므로 1 카운트

    for i in range(1, len(arr)):
        if arr[i] &gt;= cur_wifi + mid:   # 다음 집이 gap 보다 크면 설치하고 카운트, 기준점 변경
            cur_wifi = arr[i]
            count += 1

    # 이진 탐색 left, right 설정 부분
    if count &gt;= c:                    # gap 만큼 띄워서 설치했을 때 설치 수가 더 많으면 시작점을
        start = mid + 1               # 중간점으로 바꾸고 이진 탐색으로 계속 반복
        result = mid
    else:                             # 설치 수가 부족하면 끝점을 중간점으로 바꾸고 이진 탐색으로 계속 반복.
        end = mid - 1

print(result)</code></pre><h2>중량 제한</h2>
<ul>
<li><p>난이도 - 중상</p>
</li>
<li><p>유형 - 이진 탐색</p>
</li>
<li><p>핵심</p>
</li>
<li><p>찾고자하는 것이 중량이므로 중량의 사이즈를 보고 매우 크면 log 나 제곱근의 복잡도 알고리즘을 사용하도록 고려한다.</p>
</li>
<li><p>BFS 사용</p>
</li>
<li><p>중량의 최댓값을 이진 탐색으로 찾는다.</p>
</li>
<li><p>중량값을 최소로 잡고 이진 탐색법으로 중량을 탐색한다.</p>
</li>
<li><p>매번 BFS 로 도달가능을 체크한다.</p>
</li>
<li><p>BFS 는 O(E) 로 탐색이 가능하다는 것을 인지해야한다.</p>
</li>
<li><p>중량을 대상으로 탐색하는데 이를 log 복잡도로 하므로 총 E * logN 으로 무난하게 통과할 수 있는 사이즈.</p>
</li>
<li><p>비고<br>그래프 탐색과 이진 탐색이 섞인 문제다.<br>강사도 대회용 문제라고 어렵다고 한다.<br>BFS 를 알긴 하지만 아직 기초 기능만 알고 응용에는 한참 부족하며<br>이진 탐색의 응용력도 딸려서 손도 못댔다.<br>너무 어렵다 나중에 건드려야겠다.</p>
</li>
</ul>
