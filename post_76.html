<blockquote>
<p>다익스트라 까지</p>
</blockquote>
<h2>이진탐색</h2>
<p>탐색은 해쉬, 순차탐색, BST 등을 배웠다.<br>정렬이 되어있다는 가정하에 O(logn) 시간으로 탐색한다.<br>일종의 분할정복 메커니즘이다.<br>2 개의 서브 리스트로 나눈다.<br>그래서 주로 재귀로 구현한다.</p>
<h3>이진탐색 구현</h3>
<p>주어진 리스트에서 원하는 데이터가 있다면 True, 없으면 False 반환하는 재귀함수로 구현<br>리스트의 가운데를 집고 절반을 버리는 과정을 반복한다.<br>단 먼저 정렬이 되어있어야 한다.</p>
<h3>이진탐색 시간복잡도</h3>
<p>길이 n 의 리스트를 1 이 될 때까지 진행하므로 O(logn)</p>
<h2>그래프</h2>
<p>트리도 그래프의 일종.<br>그래프가 실세계 문제와 밀접함.<br>노드와 엣지로 구성됨.</p>
<h3>그래프 용어</h3>
<p>노드 - 정점.<br>간선 - 노드간의 관계를 표시한 선. 노드를 이어주는 선<br>인접 정점 - 간선으로 직접 연결된 노드<br>정점의 차수 - 무방향 그래프에서 하나의 노드에 인접한 노드의 수<br>진입차수 - in degree. 방향 그래프에서 외부에서 오는 간선의 수<br>진출차수 - out degree. 방향 그래프에서 외부로 나가는 간선의 수<br>경로 길이 - 경로를 구성하기 위해 사용된 엣지의 수<br>단순 경로 - 첫 노드와 끝 노드를 제외하고 중복된 노드가 없는 경로.<br>사이클 - 단순 경로의 시작, 끝 노드가 동일한 경우. 단순 경로의 특수한 경우</p>
<h3>그래프 종류</h3>
<p>무방향 그래프<br>방향이 없는 그래프<br>양뱡향 이동 가능<br>노드의 연결을 (a, b) 로 표기</p>
<h3>방향 그래프</h3>
<p>간선에 방향이 있음.<br>설정된 방향으로만 갈 수 있다.<br>연결된 간선을 &lt;a, b&gt; 로 표기. a --&gt; b 만 가능한 경우.</p>
<h3>가중치 그래프, 네트워크</h3>
<p>간선에 비용이나 가중치가 할당된 그래프</p>
<h3>연결 그래프 / 비연결 그래프</h3>
<p>연결 그래프는 무방향 그래프의 모든 노드에 대해 항상 경로가 존재함.<br>비연결 그래프는 특정 노드에 대해 경로가 없을 때.</p>
<h3>사이클 / 비순환 그래프</h3>
<p>사이클은 단순 경로의 시작 노드와 종료 노드가 같은 경우.<br>비순환 그래프는 사이클이 없는 그래프.</p>
<h3>완전 그래프</h3>
<p>모든 노드가 서로 연결되어 있는 그래프.</p>
<h3>트리와의 차이</h3>
<p>그래프의 특수한 경우가 트리.<br>트리는 방향성 비순환 그래프(DAG)<br>트리는 부모 자식 관계가 있음.<br>루트 노드가 있음.</p>
<h2>BFS</h2>
<p>비선형 그래프 탐색</p>
<h3>그래프 표현법</h3>
<p>노드가 순차적인 숫자들이면 2 차원 리스트로 만든다.<br>노드가 숫자가 아닌 것이면 보통 해쉬로 만든다.</p>
<h3>BFS 구현</h3>
<p>기본적으로 queue 활용한다.<br>반드시 방문 여부를 알 수 있는 방안이 필요하다.<br>수많은 응용이 가능하다.<br>방문 순서를 저장하는 기능도 필요에 따라 추가할 수 있음.</p>
<h3>BFS 시간 복잡도</h3>
<p>노드 수 V, 간선 수 E 라고 할 때<br>모든 노드 방문의 시간 복잡도는 O(V+E). 즉 인접 리스트 테이블의 모든 원소 수.</p>
<h2>DFS</h2>
<p>깊이 우선 탐색<br>중요-재귀 뿐 아니라 stack 을 이용한 반복문으로도 구현 가능.<br>재귀는 함수 스택을 쌓는 과정이므로 스택으로 바로 대체할 수 있음.<br>BFS 는 큐, DFS 는 스택을 이용해 탐색을 하는 과정이라고 이해할 수 있다.<br>스택에 쌓을 때 역순으로 넣어서 탐색 순서를 바꿔줄 수 있다.</p>
<h2>탐욕 알고리즘</h2>
<p>최적해를 구하기 위한 정책<br>여러 경우 중 매순간 최적인 경우만 선택하는 정책. 즉 선형화한다.<br>전체를 탐색하지 않고 한방향 즉, 선형으로 진행한다.<br>모든 조합을 고려하지 않는다.<br>주로 먼저 정렬을 한 다음 순서대로 데이터를 적용한다.<br>단, 매 스텝마다 최적인 경우만 고르는 것이 전체의 최적이 되는 조건이 있어야 한다.<br>부분 배낭 문제는 물건을 쪼갤 수 있으므로 무조건 효율이 좋은 물건을 먼저 넣는것이 전체적으로 최적의 해를 만든다.<br>쪼갤 수 없다면 모든 경우를 다 따질 수 밖에 없다.</p>
<h3>그리디 한계</h3>
<p>항상 최적이 되지 않으며 적용하기 위해선 조건이 필요하다.<br>그래서 근사치 추정에 쓰이기도 한다.</p>
<h2>최단 경로 알고리즘</h2>
<p>두 노드를 잇는 가장 짧은 경로를 찾는 알고리즘.<br>혹은 가중치 그래프에서 간선의 가중치 합이 최소가 되는 경로를 찾는 것이 목적.</p>
<h3>최단 경로 문제 종류</h3>
<p>단일 출발, 단일 도착 - 시작점과 끝점의 최단 경로만 찾는다. 1:1<br>단일 출발 최단 경로 - 시작점 하나와 나머지 모든 노드와의 최단 경로를 각각 찾는 알고리즘. 1: 다<br>전체 쌍 최단 경로 - 그래프 내 모든 노드 쌍에 대한 최단 경로를 찾는 문제. 다 : 다</p>
<h2>다익스트라 알고리즘 - 단일 출발 최단 경로</h2>
<p>1 : 다 최단경로 알고리즘<br>첫 정점을 기준으로 연결되어 있는 전점들을 추가해가며 최단거리를 갱신하는 기법.<br>BFS 와 유사하게 가장 가까운 뎁스의 노드들을 먼저 탐색한다.<br>여러가지 버전이 있지만 가장 개선된 방식인 heap 을 이용한 알고리즘이 있다.<br>힙을 사용하는 이유는 최단거리를 빨리 찾을 수 있어서임.<br>가장 짧은 길이에 대한 노드를 먼저 계산하므로 더 긴 거리 루트는 스킵할 수 있다.<br>경로를 모두 저장하는 부분도 필요하다면 넣을 수 있다.</p>
<h3>다익스트라 시간복잡도</h3>
<p>각 노드마다 인접한 간선들을 모두 검사하는 과정<br>힙에 데이터를 넣고 삭제하는 과정<br>각각 O(E) (최악의 경우), O(ElogE) 걸리고 합한다.<br>결과적으로 O(ElogE) 가 걸린다.</p>
