<h1>4 강</h1>
<h2>안정적인 프로토콜 예시</h2>
<ul>
<li>가상의 안정적인 프로토콜 Reliable Data Transfer Protocl</li>
<li>이 강의에서는 단일 패킷을 보낸다는 가정을 한다.</li>
<li>underlying layer 하위 계층에 패킷 에러가 발생한다는 환경에서<br>  sender 는 다음을 함께 보냄<br>  checksum - 에러 확인<br>  피드백 - 제대로 받았는가?. 에러 있으면 재전송한다. ack, nak 등등</li>
<li>만약 피드백에 에러가 있다면??<br>  receiver 가 ack 를 보낼 때 도중에 에러가 생기면 ack 인지 nak 인지도 모름.<br>  제대로 받았는지 안받았는지 모르는데 안받았다고 가정하고 복사하고 다시 보낸다.<br>  이 복사본이라는 것을 알리기 위해 시퀀스 번호를 헤더에 함께 전송한다.<br>  헤더는 크기가 최소화 되어야 좋다.<br>  만약 1 : 1 통신일 땐 시퀀스 번호 0, 1 토글하면 된다.</li>
</ul>
<h2>RDT 1</h2>
<ul>
<li>no loss, no error 상황에서 신뢰성있는 통신</li>
<li>그냥 주고 받으면 됨</li>
</ul>
<h2>RDT 2.0</h2>
<p>no loss 상황이지만 error 는 있는 상황</p>
<ul>
<li>sender<br>  시퀀스 넘버 붙여서 보내기<br>  ACK / NAK 반드시 확인하기<br>  NAK 을 받거나 오류 피드백을 받으면 시퀀스 넘버 바꾸고 복사해서 다시 보내기</li>
<li>receiver<br>  다시 보낸 복사본인지 확인하기<br>  받은 패킷이 오류가 있으면 NAK 보내고 아니면 ACK 보낸다.</li>
</ul>
<h2>RDT 2.1</h2>
<ul>
<li>패킷을 받으면 피드백으로 NAK 는 안보내고 무조건 ACK 를 보낸다.<br>  NAK 대신 시퀀스 넘버로 오류확인 한다.</li>
</ul>
<h2>RDT 3</h2>
<ul>
<li>하위 계층에서 패킷 오류만 아니라 패킷 유실까지 발생될 때 - 현실 세계</li>
<li>전송 도중 패킷이 사라지면 sender 는 피드백을 받을 수 없다.</li>
<li>타이머를 두어서 초과하면 유실되었다고 간주하고 재전송한다.</li>
<li>타임아웃을 얼마나 할 지는 적절히<br>  너무 짧으면 유실 상황 발생 시 복구가 빠름. 하지만 중복 패킷이 발생 가능. 그리고 네트워크 오버헤드<br>  짧아서 중복 패킷이 발생해도 꼬이지는 않는다.<br>  너무 길면 오버헤드가 적지만, 유실 상황에 대한 반응이 느림.</li>
<li>RDT 3 는 단일 패킷 전송에서는 완벽히 안정적임.</li>
</ul>
<h2>RDT 정리</h2>
<ul>
<li>신뢰성은 loss, error 를 극복해야한다.</li>
<li>error 에 대처하기 위해 에러 체크, 피드백, 재전송, 시퀀스 넘버가 필요하다.</li>
<li>loss 에 대처하기 위해 타임아웃이 필요하다.</li>
<li>신뢰성 있는 TCP 는 이 개념을 모두 패킷 헤더에 담고 있다.</li>
<li>RDT 3 는 안정적이지만 패킷 단위가 하나라서 비효율적임.</li>
<li>실제로는 데이터를 한꺼번에(batch) 들이붓고 한꺼번에 피드백을 받는다.</li>
</ul>
