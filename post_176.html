<h1>문법 2</h1>
<p>JS 끔찍하다.</p>
<h2>암묵적 형변환</h2>
<p>암묵적 형변환은 연산할 때 변수에 재할당하여 연산하는 것임 - 다른 언어와 마찬가지<br>js 엔진이 스스로 변환해주는 것임.<br>js 는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 많이 한다.</p>
<h2>객체</h2>
<p>js 에서는 프로토타입 기반 객체 지향 언어로서 클래스 개념이 없다.<br>ES 6 에서는 클래스가 도입되었다.</p>
<h2>객체 리터럴</h2>
<p>가장 일반적인 js 객체 생성 방식.<br>{} 만 사용하여 객체를 생성해냔다. 아무것도 안 담으면 빈 객체</p>
<h2>object 생성자 함수</h2>
<p>new Object() 함수를 호출하면 빈 객체를 생성할 수 있다.<br>그리고 여기에 프로퍼티나 메서드를 추가하는 방식이다.<br>이렇게 생성자 함수로 만들어진 객체를 인스턴스라고 한다.<br>String(), Number(), Boolean(), Array(), Date() 등 내장 생성자 함수도 있다.<br>사실상 이렇게 만들 필요는 없다. 불편하다.</p>
<h2>생성자 함수</h2>
<p>object 생성자 함수가 아닌 생성자 함수를 만들면 클래스 비슷하게 쓸 수 있다.<br>함수형식으로 만든다.<br>이름은 대문자로 보통 시작한다.<br>this 는 생성된 인스턴스 객체 자신을 의미한다.<br>this 로 선언된 변수는 public 이라서 외부에서 접근이 가능하다.<br>this 가 아닌 다른 변수는 private 이다.</p>
<pre><code>function Creator(){
    this.name = name;
    this.gender = gender;
    this.Say = function(){
        console.log(&#39;hihi&#39;);
    }
}

var person = new Creator();</code></pre><h2>프로퍼티 값 읽기</h2>
<p>객체의 프로퍼티나 메서드에 접근하는 방법은 마침표, 대괄호 2 방법이 있다.<br>단, 대괄호를 사용할 땐 안의 키 값이 문자열이어야 한다.</p>
<h2>프로퍼티 값 갱신</h2>
<p>객체가 소유하고 있는 프로퍼티에 값을 할당하면 값이 갱신된다.</p>
<h2>프로퍼티 동적 생성</h2>
<p>객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 주어진 키와 값으로 프로퍼티를 생성하고 객체에 추가한다.</p>
<h2>프로퍼티 삭제</h2>
<p>delete 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. 이 때 피연산자는 프로퍼티 키</p>
<h2>for-in 문</h2>
<p>객체, 배열에 포함된 모든 프로퍼티에 대해 루프를 수행할 수 있다.</p>
<pre><code>for(var p in person){
    console.log(p);
}</code></pre><h2>for-of</h2>
<p>for-in 은 배열에 쓰기에 부적합하다. 순서 보장 안하고 배열 아이템 이외의 프로퍼티도 다 순회함.<br>즉 배열을 순회하기 위해 사용.<br>ES 6 에서 추가됨.</p>
<pre><code>for(const i of arr){
    console.log(i)
}

for(const[i, v] of arr.entries()){
    console.log(i, v)
}</code></pre><h2>참조 타입</h2>
<p>객체 타입은 모든 연산이 실제값이 아닌 참조값으로 처리되는 참조 타입이다.<br>프로퍼티를 변경, 추가, 삭제가 가능해서 변경가능하다.<br>힙 영역에 저장</p>
<h2>값 타입</h2>
<p>원시 타입에 해당.<br>주소가 아닌 값 자체를 저장<br>변경이 불가능.<br>스택에 저장.</p>
<h2>객체 분류</h2>
<p>내장 객체와 사용자 생성 객체<br>내장 객체에는 표준 내장 객체, DOM, BOM 등이 있다.</p>
<h2>불변 타입</h2>
<p>원시타입은 불변타입인데 이는 메모리 영역에서 변경이 불가능하다는 것임<br>당연히 재할당은 가능하다.<br>여러가지 배열과 문자열 메서드는 새로 생성하고 반환하는 것일 뿐이다.</p>
<h2>불변 데이터 패턴</h2>
<p>객체의 값을 의도적으로 변경하지 않아야 할 때 이를 방지하는 방법이 2 가지 있다.<br>Object.assign(dst, src)<br>ES 6 에서 추가됨.<br>기존 src 객체를 변경하지 않고 복사하여 사용한다.<br>하지만 deep copy 가 아니라서 내부 객체는 얕은 복사가 된다.<br>Object.freeze(target)<br>아예 불변 객체로 만들어버림.<br>deepFreeze() 를 사용하여 깊은 냉각을 한다.</p>
<h2>Immutable.js</h2>
<p>페북이 만든 불변화 라이브러리.</p>
<h2>함수 선언</h2>
<ol>
<li>함수 선언문<br>function func(){}</li>
<li>함수 표현식<br>var func = function(){}</li>
<li>생성자 함수<br>클래스 만들 때 쓰는 문법</li>
</ol>
<h2>함수</h2>
<p>일급 객체.<br>객체이기 때문에 익명 함수를 만들어 변수에 할당하고 이를 참조하는 변수는 같은 참조값을 가진다.</p>
<h2>함수 호이스팅</h2>
<p>함수 선언문으로 선언하면 함수 호이스팅으로 어느곳에서나 사용 가능하다.<br>함수 표현식으로 작성하면 변수 호이스팅이 일어나서 함수로 인식이 안된다.<br>그래서 작성 위치를 상단에 해줘야한다.<br>함수 호이스팅은 호출전 선언 규칙을 무시하므로 사용하지 말것을 당부한다.<br>즉, 함수 표현식을 사용하도록 권고한다!</p>
<h2>함수 객체의 프로퍼티</h2>
<p>함수도 객체이므로 프로퍼티를 가질 수 있다..<br>함수.프로퍼티 = 값 으로 추가 가능</p>
<h2>함수만의 프로퍼티</h2>
<p>다른 객체와 다르게 고유의 프로퍼티가 있다.</p>
<h2>arguments 프로퍼티</h2>
<p>함수 호출시 인수들의 정보를 담고 있는 iterable 한 유사 배열 객체이다.<br>함수 내부에서 지역변수처럼 사용된다.<br>그리고 함수 호출시 인수를 아예 전달하지 않아도 에러가 발생하지 않는다.<br>없는 인수는 그냥 undefined 로 처리된다.<br>초과 전달된 인수는 무시된다..</p>
<h2>caller 프로퍼티</h2>
<p>자신을 호출한 함수를 의미한다.<br>즉 콜백함수로 쓰이는 함수에서 작성한다.</p>
<h2>prototype 프로퍼티</h2>
<p>함수 객체만 소유한다.<br>함수가 객체를 생성하는 생성자 함수로 사용될 때 인스턴스의 프로토타입 객체를 가리킨다.</p>
<h2>내부 함수</h2>
<p>함수 내부에 정의된 함수를 내부함수라고 한다.<br>내부 함수에서 외부 함수의 변수에 접근 가능하다.</p>
<h2>콜백 함수</h2>
<p>js 는 콜백함수가 많이 쓰인다.<br>이벤트 처리할 때.<br>인자로 이벤트처리 함수를 전달한다.</p>
<h2>타입 체크</h2>
<p>typeof 뿐 아니라 instanceof 연산자가 있다.<br>이때 타입은 contructor 를 말하며 프로토타입 체인에 존재하는 모든 contructor 를 검색하여 일치하는게 있으면 true 반환</p>
<h2>프로토타입</h2>
<p>js 는 프로토타입 객체 지향 언어다.<br>js 의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다.<br>이를 상속의 개념과 같이 생각하면 된다.<br>이러한 부모 객체를 프로토타입 객체라고 한다.<br>객체를 생성할 떄 프로토타입은 결정 된다.<br>그리고 임의의 다른 객체로 변경할 수도 있다.<br>즉, 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것이다.</p>
<h2><strong>proto</strong>, prototype</h2>
<p>함수 포함 모든 객체는 인터널 <strong>proto</strong> 슬롯이 있다.<br>prototype 은 함수 객체만 가지고 있는 프로퍼티이다.<br>함수 객체가 생성자로 사용될 때 부모 역할을 하는 객체를 가리킨다.</p>
<h2>constructor 프로퍼티</h2>
<p>객체를 생성하게 한 생성자 함수를 가리킨다.<br>생성자는 constructor 는 자기 자신 객체를 가리킨다.</p>
<h2>프로토타입 객체</h2>
<p>객체의 조상을 계속 타고 올라가서 프로퍼티를 자동으로 찾는다.</p>
<h2>프로토타입 객체의 확장</h2>
<p>프토타입도 객체이므로 프로퍼티를 추가 삭제할 수 있다.<br>변경된 프로퍼티는 즉시 프로토타입 체인에 반영된다.</p>
<h2>프로토타입 객체 변경</h2>
<p>생성자의 프로토타입 객체를 변경할 수 있다.<br>단, 프로토타입 변경 이전에 생성된 객체는 기존의 프로토타입 객체를 바인딩한다.</p>
<h2>스코프</h2>
<p>선언되지 않은 변수도 체인을 타고 어디서 선언된 것인지 확인한다.<br>하지만 선언되지 않더라도, 전역객체에 선언된 것이라고 암묵적으로 전역 프로퍼티로 생성한다.</p>
<h2>전역변수 억제</h2>
<p>전역변수를 남발하면 큰 문제가 된다.<br>전역변수를 저장하는 하나의 객체에 담아서 저장하는 방식이 좋다.</p>
<h2>strict mode</h2>
<p>js 의 여러 불안정성을 커버하기 위해 strict mode 를 사용할 수 있다.<br>&#39;use strict&#39; 을 선언<br>에러를 뱉기 시작한다.<br>그러나, 다른 모듈에서 호환을 위해 전역에 배치하지 말고 함수 선두에 선언한다.<br>사실 이것도 안좋으므로 즉시실행함수로 감싼 스크립트 단위로 적용한다...</p>
