<p>7 강</p>
<p><a href="https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN">강의 및 자료출처</a></p>
<h1>교착 상태 deadlock</h1>
<h2>데드락</h2>
<p>그 어떤 프로세스도 필요한 자원을 할당받지 못하는 상태<br>blocked, asleep state - 프로세서가 아닌 다른 자원을 기다릴 때<br>이 상태의 프로세스가 그 다른 자원을 할당받을 수 없는 상태가 데드락.<br>deadlock state<br>프로세스가 발생 가능성이 없는 이벤트를 기다리는 경우 - 프로세스가 데드락 상태에 있음.<br>시스템 내에 데드락에 빠진 프로세스가 있는 경우 시스템이 데드락 상태에 있음<br>deadlock vs starvation<br>데드락은 일어날 가능성이 없는 상황을 기다리는 상태. asleep 상태에서 형성<br>starvation 은 기다리는 발생할 수 있지만 운이 없어서 계속 자원 할당을 못받는 상태. ready 상태에서 발생한다.</p>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@rhVrH/btqLD1GPIXQ/1bL6Y6EojEz2XyKYbnjB1k/img.png" ><p class="cap1">width="602" height="380" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<h2>자원의 분류</h2>
<p>일반적 분류<br>HW 리소스, SW 리소스<br>다른 분류법<br>선점 가능 여부<br>할당 단위 여부<br>동시 사용 가능 여부<br>재사용 가능 여부</p>
<h2>자원 - 선점 가능 여부</h2>
<p>preemptible resources<br>선점 당한 후 돌아와도 문제가 발생하지 않는 자원.<br>프로세서, 메모리 등<br>non preemptible<br>선점 당하면 이후 진행에 문제가 발생하는 자원<br>디스크, 드라이브 등 데이터가 날라가는 문제가 발생하는 자원</p>
<h2>자원 - 할당 단위에 따른 분류</h2>
<p>total allocation resources<br>자원 전체를 프로세스에게 할당<br>프로세서, 디스크 - 단일 프로세스일 때 한 번에 하나의 프로세서만 사용가능??<br>partitiones allocation<br>하나의 자원을 여러 조각으로 나눠 여러 프로세스들에게 할당한다.<br>메모리 등은 나누어서 사용</p>
<h2>동시 사용가능 여부에 따른 분류</h2>
<p>exclusive allocation<br>한 순간에 한 프로세스만 사용 가능<br>프로세서, 메모리, 디스크 등. (메모리는 쪼갤 수 있지만 쪼개져서 할당된 부분은 각 프로세스만 사용 가능하다.)<br>shared allocation<br>여러 프로세스가 동시에 사용 가능한 자원<br>프로그램(sw), shared data 등. - 프로그램 하나를 여러개 띄울 수 있다는 점에서 소스코드는 동시 사용 가능</p>
<h2>재사용 가능 여부에 따른 분류</h2>
<p>serially reusable, (SR)<br>시스템 내에 항상존재하는 자원<br>사용이 끝나면 다른 프로세스가 사용 가능<br>프로세서, 메모리, 디스크, 프로그램 등<br>consumable (CR)<br>한 프로세스가 사용한 후에 사라지는 자원<br>시그널, 메세지 등</p>
<h2>데드락과 자원의 종류</h2>
<p>데드락을 발생시킬 수 있는 자원 형태<br>non preemptible 자원 - 선점하지 못하게 하면 접근을 못하게 막기 때문<br>exclusive allocation 자원 - 혼자만 쓸 때<br>SR 자원<br>할당 단위는 영향을 미치지 않음.<br>CR 을 대상으로 하는 데드락 모델은 너무 복잡하다.</p>
<h3>데드락 발생의 예</h3>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@wFjgy/btqLDM4cpFm/i5xIKj8dA3IVh5lioyQjm0/img.png" ><p class="cap1">width="602" height="323" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<h2>데드락 모델 (표현법)</h2>
<p>위의 소스 코드 형식으로는 파악하기 힘들다.<br>그래서 여러 방법들로 모델을 가시화한다.<br>그래프 모델<br>상태 전이 모델</p>
<h2>그래프 모델</h2>
<p>노드<br>프로세스 노드, 자원 노드<br>엣지<br>R → P - 자원이 프로세스에 할당 됨<br>P → R - 프로세스가 자원을 요청, 대기 중</p>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@bS7C95/btqLEk0pFUA/ufNR2gzlNjuG4aIGibpQh1/img.png" ><p class="cap1">width="449" height="245" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>위의 상황을 사이클이 생기는 그래프로 표현</p>
<h2>상태 전이 모델</h2>
<p>상태를 정의하고 그래프로 그려서 데드락 표기 가능</p>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@yqUSO/btqLE1Ty3Ci/fx6MvZBx7jarUa6Ls33Qp0/img.png" ><p class="cap1">width="602" height="424" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<h2>데드락 발생 필요 조건</h2>
<p>exclusive use of resource - 자원 특성<br>non preemptible resource - 자원 특성<br>hold and wait - 프로세스 특성<br>circular wait - 프로세스 특성. 사이클</p>
<h2>데드락 예방법 - prevention</h2>
<p>4 개의 데드락 발생 필요 조건 중 하나를 제거<br>모든 자원을 공유 허용<br>exclusive use 조건 제거<br>현실적으로 불가능<br>모든 자원에 대해 선점 허용<br>non preemptible 조건 제거<br>현실적으로 불가능<br>자원을 모두 반납하고 재시작하는 등의 유사하게 구현을 가능하지만 심각한 자원 낭비가 발생한다.<br>필요 자원 한 번에 모두 할당 - total allocation<br>hold and wait 조건 제거<br>자원 낭비가 발생한다. - 불필요한데 자원을 할당한다.<br>무한 대기 현상 발생가능함.<br>circular wait 조건 제거<br>totally allocation 을 일반화 한 방법<br>자원들에게 순서를 부여<br>프로세스는 순서 증가 방향으로만 자원 요청 가능 - 사이클이 만들어지지 않음.<br>자원 낭비가 발생한다.<br>예방법은 별로. 절대 데드락이 발생하진 않지만,<br>어느 한 조건을 제거해도 비현실적이거나 자원 낭비가 심하다.</p>
<h2>데드락 회피법 - avoidance</h2>
<p>시스템의 상태를 계속 감시한다.<br>시스템이 데드락 상태가 될 가능성이 있는 자원 할당 요청을 보류<br>시스템을 항상 safe state 로 유지.</p>
<h2>safe state</h2>
<p>모든 프로세스가 정상적으로 종료 가능한 상태<br>즉, safe sequence 가 존재 - 데드락 상태가 되지 않을 수 있음을 보장</p>
<h2>unsafe state</h2>
<p>데드락 상태가 될 가능성이 있음.<br>반드시 데드락이 발생한다는 것은 아님.</p>
<h2>데드락 회피법</h2>
<p>가정<br>프로세스 수가 고정됨<br>자원의 종류와 수가 고정됨<br>프로세스가 요구하는 자원 및 최대 수량을 알고 있음<br>non practical 한 방법이다..</p>
<h2>데드락 회피 - 다익스트라의 banker 알고리즘</h2>
<p>시스템을 항상 safe state 로 유지하는 알고리즘이다.<br>자원 타입은 하나, 갯수는 정해지고 프로세스도 고정된다고 고정<br>자원 요청이 들어왔을 때 할당하는 시뮬레이션 결과 safe sequence 존재 여부를 확인하는 것이 전부이다.</p>
<h2>데드락 회피 - habermann 알고리즘</h2>
<p>다익스트라는 자원 종류 1 개 이지만, 이 알고리즘은 여러개 종류<br>마찬가지로 시뮬레이션을 하여 safe sequence 를 확인한다.</p>
<h2>데드락 회피</h2>
<p>데드락 발생을 막는다.<br>high overhead<br>low resource utilization<br>사실 safe sequence 가 없어도 데드락이 반드시 발생하는것이 아닌데 그거때문에 accept 을 안하는 상황은 자원을 그냥 쉬게 하는것임<br>not practical<br>가장이 비현실적임, 비실용적</p>
<h2>데드락 감지 - detection</h2>
<p>데드락 방지를 위한 사전 작업을 하지 않음<br>데드락이 발생이 가능. 허용<br>주기적으로 데드락 발생 확인<br>시스템이 데드락 상태인가?<br>어떤 프로세스가 데드락 상태인가?<br>RAG 사용</p>
<h2>RAG - resource allocation graph</h2>
<p>데드락 검출을 위해 사용<br>방향성, 이분 그래프</p>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@R8q7p/btqLBNvK8QA/P4hNSXbvX4cytkXC0XI0KK/img.png" ><p class="cap1">width="548" height="247" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<h2>데드락 감지 방법</h2>
<p>graph reduction<br>주어진 RAG 에서 엣지를 하나씩 지워가는 방법<br>completely reduced - 모든 엣지가 제거 됨, 데드락에 빠진 프로세스가 없음<br>irreducible - 지울 수 없는 엣지가 존재, 하나 이상의 프로세스가 데드락 상태</p>
<h2>unblocked process</h2>
<p>자원이 할당가능한 프로세스.<br>최종 그래프에서 엣지가 모두 제거되면 데드락 없고, 엣지가 남으면 데드락 있음.</p>
<h2>데드락 감지 - 특징</h2>
<p>high overhead<br>검사 주기에 영향을 받는다.<br>노드의 수가 많은 경우</p>
<h2>데드락 회피 vs 데드락 감지</h2>
<p>avoidance<br>최악의 경우를 고려 (safe sequence)<br>데드락이 발생하지 않음<br>detection<br>최선의 경우를 생각<br>데드락이 발생할 수 있지만 해결하는 것에 중점</p>
<h2>데드락 리커버리</h2>
<p>데드락을 검출한 후 해결하는 과정<br>데드락 리커버리 method<br>프로세스 종료 - 데드락 상태인 프로세스 중 일부 종료.<br>리소스 선점</p>
<h2>데드락 리커버리 - 프로세스 종료</h2>
<p>종료 프로세스 선택<br>lowest termination cost<br>단순하고 적은 오버헤드. 한 바퀴만 돌면 되므로<br>하지만 불필요한 프로세스들이 종료될 가능성이 높다.</p>
<h2>minimum cost recovery</h2>
<p>최소 비용으로 데드락 상태를 해소할 수 있는 프로세스 선택<br>완전 탐색을 통해 최적의 상황을 찾는다.<br>그래서 오버헤드가 크다.</p>
<h2>데드락 리커버리 - 리소스 preemption</h2>
<p>데드락 상태 해결을 위해 선점할 자원 선택<br>해당 자원을 가지고 있는 프로세스를 종료 시켜서 자원을 가져온다.</p>
<h2>데드락 리커버리</h2>
<p>어쩄든 프로세스가 종료된다.<br>그 단점을 보완하기 위해 체크포인트마다 컨텍스트를 저장한다.<br>롤백을 위해 사용</p>
