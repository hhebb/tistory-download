<h1>고급 정렬</h1>
<p>$O(N^2)$ 이 아닌 $O(NlogN)$ 시간복잡도로 정렬할 수 있는 알고리즘들.<br>주로 분할정복 전략을 사용하며 재귀로 구현한다.<br>형태는 각각 어느정도 유사하다.<br>처음엔 이해조차 하기 힘들지만, 패턴을 익히면 알고리즘 동작과정이 그냥 당연한 것처럼 된다.</p>
<p>분할정복은 visualgo 를 보면 오히려 더 헷갈리게 된다.</p>
<p>이 파트는 개념과 코드를 보는것이 더 도움이 된다.</p>
<h2>퀵 정렬</h2>
<ul>
<li><p>개념 - pivot 을 지정하고, pivot 보다 큰것, 작은것 2 덩어리로 나눠서 다시 합친다.<br>다시 합치는 과정을 재귀를 타게 하여 최소 단위로 분할하고 다시 전체문제로 환원한다.</p>
</li>
<li><p>비고 - 퀵 정렬은 평균적으로 $O(NlogN)$ 시간복잡도를 가지지만, 이미 정렬되어있는 데이터들이 들어오면 최악의 경우로 기본 정렬들과 유사한 시간복잡도를 가지게 된다.<br>pivot 을 기준으로 매 단계마다 절반씩 나누어지는것이 가장 좋은 조건이다.</p>
<p>! 불안정 정렬(순서가 뒤바뀔 수 있는)이다.</p>
</li>
</ul>
<pre><code>def qsort(arr):
    if len(arr) &lt;= 1:                                # 배열의 사이즈가 1 개 이하면 분할의 끝이므로 반환.
        return arr

    pivot = arr[0]                                    # 첫 원소를 pivot 으로 잡는다.
    left = [i for i in arr[1:] if pivot &gt; i]        # pivot 보다 작은 원소들
    right = [i for i in arr[1:] if pivot &lt;= i]        # pivot 보다 큰 원소들

    return qsort(left) + [pivot] + qsort(right)        # 다시 합친것을 반환</code></pre><h2>병합 정렬</h2>
<ul>
<li><p>개념 - 데이터를 절반으로 쪼개고 다시 합치는 과정을 반복한다.<br>역시 분할 정복 전략을 사용하고 split, merge 기능을 나눠야 한다.</p>
</li>
<li><p>비고 - 퀵정렬과는 다르게 항상 절반으로 나누기 때문에 항상 $O(NlogN)$ 을 보장한다.<br>각 단계가 $N$ 총 $log(N)$ 단계.<br>안정 정렬의 특성을 가진다.</p>
</li>
</ul>
<pre><code># merge 함수
def merge(arr1, arr2):
    pl, pr = 0, 0                                # left, right 리스트의 현재 위치 포인터
    result = []                                    # 병합 결과를 담는 리스트

    while pl &lt; len(arr1) and pr &lt; len(arr2):    # 포인터 둘 다 끝에 도달하지 않았을 때, 비교하며 결과에 담는다.
        if arr1[pl] &lt; arr2[pr]:
            result.append(arr1[pl])
            pl += 1
        else:
            result.append(arr2[pr])
            pr += 1

    while pl &lt; len(arr1):                        # 오른쪽 포인터가 끝에 도달하면 왼쪽 포인터 남은것을 채워준다.
        result.append(arr1[pl])
        pl += 1

    while pr &lt; len(arr2):                        # 왼쪽 포인터가 끝에 도달하면 오른쪽 포인터 남은것을 채워준다.
        result.append(arr2[pr])
        pr += 1
    return result</code></pre><pre><code># split 함수
def split(arr):
    if len(arr) &lt;= 1:                            # 길이가 1 이하이면 바로 반환
        return arr

    left = arr[:int(len(arr)/2)]
    right = arr[int(len(arr)/2):]
    return merge(split(left), split(right))        # 나눈 것을 다시 합쳐서 반환
</code></pre><h2>병합 정렬 2</h2>
<ul>
<li>병합 정렬의 merge, split 을 하나로 합쳐서 구현한다.</li>
<li>결과적으로 코드 수는 많이 변하진 않았다.</li>
<li>하지만 함수의 구조가 변해도 동작방식은 동일하다는 것을 인지할 수 있다.</li>
<li>그것도 재귀함수와 일반함수를 합치고 나누는 과정이 자유자재로 가능해야 한다.</li>
</ul>
<pre><code>def merge_sort2(arr):
    if len(arr) &lt;= 1:
        return arr
    left = merge_sort2(arr[len(arr)//2:])
    right = merge_sort2(arr[:len(arr)//2])

    merged = []
    pr, pl = 0, 0

    while pr &lt; len(right) and pl &lt; len(left):
        if left[pl] &lt;= right[pr]:
            merged.append(left[pl])
            pl += 1
        else:
            merged.append(right[pr])
            pr += 1

    while pr &lt; len(right):
        merged.append(right[pr])
        pr += 1

    while pl &lt; len(left):
        merged.append(left[pl])
        pl += 1

    return merged

arr = random.sample(range(100), 20)
merge_sort2(arr)</code></pre>