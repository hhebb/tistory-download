<h1>가상 메모리 2</h1>
<h2>LFU (Least Frequently Used) 알고리즘</h2>
<ul>
<li>
<p>LRU 알고리즘의 단점은 시간을 기록해야한다는 단점이 있었음.</p>
</li>
<li>
<p>가장 참조 횟수가 적은 page 를 교체</p>
</li>
<li>
<p>page 참조 시 마다 참조 횟수를 누적해야함. 이것은 단순히 ++ 해주면 됨.</p>
</li>
<li>
<p>역시 지역성을 활용한다.</p>
</li>
</ul>
<p>단점</p>
<ol>
<li>
<p>최근 적재된 참조될 가능성 높은 page 가 교체될 가능성이 있다.</p>
</li>
<li>
<p>참조 횟수 누적은 여전히 오버헤드가 있다.</p>
</li>
</ol>
<h2>NUR (Not Used Recently) 알고리즘</h2>
<ul>
<li>
<p>LRU approximation<br />최근에 사용되지 않은 것을 메모리에서 뺀다.<br />LRU 보다 적은 오버헤드로 비슷한 성능 달성이 목적이다.</p>
</li>
<li>
<p>bit vector 사용<br />reference 비트 벡터 r - 주기적으로 갱신되는 것을 활용<br />update 비트 벡터 m</p>
</li>
</ul>
<h2>Clock 알고리즘</h2>
<ul>
<li>NUR 을 적용한 알고리즘</li>
<li>reference bit 를 사용한다.<br />하지만 주기적인 초기화가 없다.<br />대신 시계바늘이 지날 때 그 때 초기화를 시켜준다. - 참조 비트를 0 으로 해줌</li>
<li>page frame 들을 순차적으로 가리키는 포인터(시계바늘) 를 사용해 교체될 page 결정</li>
<li>어쨋든 한 방향으로 시침이 이동하므로 먼저 적재된 page 가 교체될 가능성이 높다.</li>
<li>LRU, NUR 과 비슷하게 reference bit(hardware component) 를 이용한다.<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@MXEmd/btqL1oH94lN/RbxQcKZkaFKpLb7wgLrSPk/img.png" ><p class="cap1">width="428" height="352" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>Second Chance Algorithm</h2>
<ul>
<li>clock 알고리즘 과 유사함.</li>
<li>update bit (m) 도 함께 고려함.</li>
<li>r, m 모두 0 일 때 교체해준다.<br /><br /></li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@byfR0Z/btqL1nJdROd/wtGzOKi4DYtzEGeWSoaXh0/img.png" ><p class="cap1">width="445" height="327" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>기타 알고리즘들</h2>
<ul>
<li>additional reference bits 알고리즘<br />LRU 와 비슷<br />여러개 하드웨어를 사용함</li>
<li>MRU<br />LRU 와 정반대 기법</li>
<li>MFU<br />LFU 와 정반대 기법</li>
<li>여러가지 기법틀이 있지만 지역성을 고려하여 page fault 를 줄이는 것이 핵심이다.</li>
</ul>
<h2>Variable allocation - Replacement Strategies</h2>
<ul>
<li>지금까지는 할당된 페이지 수가 fixed allocation 로 고정된 환경에서 교체 기법.</li>
</ul>
<h2>Working Set 알고리즘</h2>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>working set<br />프로세스가 특정 시점에 자주 참조하는 페이지들의 집합 - 지역성<br />최근 일정시간 동안 참조된 페이지들의 집합<br />시간에 따라 변하게 된다.</li>
<li>working set 메모리에 항상 유지하므로 page fault rate 감소, 시스템 성능 향상<br />윈도우 사이즈는 고정된다.<br />윈도우 사이즈가 성능을 결정짓는 융요한 요소<br />메모리 할당은 가변, 윈도우 사이즈가 고정된다.<br />이 알고리즘과 반대로 윈도우 사이즈는 가변이고 메모리 할당 수가 고정된 것은 LRU 알고리즘이다!<br /><br />지역성 때문에 윈도우 사이즈가 커져도 워킹 셋이 커지는 정도가 완화된다.</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@dC9omi/btqLYNBGOxm/FHOffy5xW18PQS8KCpVyEk/img.png" ><p class="cap1">width="602" height="323" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>working set transition<br />루프에서 루프로 넘어갈 때 일시적으로 워킹 셋의 사이즈가 커지고 작아지는 현상.</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@OG5OR/btqLYMiso4V/9m4lnzYpwizqNY2kX5ksU0/img.png" ><p class="cap1">width="602" height="337" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>working set 성능</h2>
<ul>
<li>page fault 외 다른 지표도 함께 봐야 함. page fault 만 가지고 성능을 평가할 수 없다.</li>
<li>예시<br />일정시간 동안 평균 page frame 수 등<br />페이지 프레임을 유지하는 비용도 포함해야 함.</li>
</ul>
<h2>working set 정리</h2>
<ul>
<li>특성<br />적재되는 page 가 없더라도 메모리를 반납하느 page 가 있을 수 있다.<br />새로 적재되는 page 가 있더라도 교체되는 page 가 없을 수 있다.<br />할당이 가변적이므로<br />지역성을 잘 고려한다.</li>
<li>단점<br />working set 관리에 오버헤드가 크다.<br />residence set 을 page fault 가 없어도 지속적으로 관리해야한다는 뜻<br /><br />그래서 윈도우 사이즈를 적당히 잡아줘야 한다.</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@v9VSq/btqL2PSLLru/NVKIbEtYK9uHh50MYc4tFk/img.png" ><p class="cap1">width="602" height="360" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>&nbsp;</p>
<h2>Page Fault Frequency 알고리즘</h2>
<ul>
<li>워킹셋 알고리즘 단점 해결</li>
<li>residence set size 를 page fault rate 에 따라 결정<br />low page fault rate - 프로세스에게 할당된 페이지 프레임 수를 줄인다.<br />hith page fault rate - 프로세스에게 할당된 페이지 프레임 수를 늘린다.</li>
<li>resident set 갱신 및 메모리 할당<br />page fault 가 발생시에만 수행<br />오버헤드가 적음</li>
<li>page fault rate 판단 기준<br />IFT 는 page fault 난 시간 간격<br />inter fault time (IFT) 가 기준보다 크면 rate 가 낮다.<br />inter fault time (IFT) 가 기준보다 작으면 rate 가 높다.<br />이 기준값이 알고리즘 성능을 좌우한다.</li>
</ul>
<h2>PFF 알고리즘 구체</h2>
<ol>
<li>page fault 발생 시 IFT 계산</li>
<li>IFT &gt; x<br />low page fault rate<br />residence set 동안 참조된 page 만 유지<br />나머지 page 들은 메모리에서 내림</li>
<li>IFT &lt;= x<br />hith page fault rate<br />기존 page 들은 유지<br />현재 참조된 page 를 추가 적재</li>
</ol>
<h2>PFF 알고리즘 정리</h2>
<ul>
<li>성능 평가<br />page fault 수 외 다른 지표도 함께 봐야 함</li>
<li>특징<br />메모리 상태 변하가 apge fault 발생 시에만 변함<br />적은 오버헤드</li>
</ul>
<h2>Variable MIN (VMIN) 알고리즘</h2>
<ul>
<li>가변 할당 기반 교체 기법 중 최적의 알고리즘<br />평균 메모리 할당량과 page fault 발생 횟수 모두 고려헀을때 최적이다.</li>
<li>실현 불가능한 기법<br />성능 평가의 기준으로 사용한다.</li>
<li>성능 평가<br />page fault 외에도 다른 지표가 필요</li>
</ul>
<h2>가상 메모리 관리 다른 방법들</h2>
<p>다른 요소도 많이 고려해야 됨.</p>
<h2>Page Size</h2>
<ul>
<li>시스템 특성에 따라 다름<br />적당한 것이 좋음<br />최근에는 점점 커진다. - 병목현상 감소 역할을 한다.</li>
<li>일반적인 페이지 사이즈<br />128 byte ~ 4 mb</li>
<li>페이지 사이즈가 작을 때<br />페이지 수가 많다. = page table 이 크다. = 참조에 커널 오버헤드가 크다.<br />내부 단편화 감소<br />page fault 증가<br />I/O 시간 증가<br />지역성 향상</li>
<li>페이지 사이즈가 클 때<br />페이지 수가 적다. = page table 이 작다. = 참조에 커널 오버헤드가 적다.<br />내부 단편화 증가<br />page fault 감소<br />I/O 시간 감소 - 디스크와 CPU 와의 성능 차이가 커지므로 병목현상을 해소하기 위해 사이즈 큰것이 좋다.<br />지역성 저하 (일반적으로)</li>
</ul>
<h2>Program Restructuring</h2>
<ul>
<li>가상 메모리 시스템의 특성에 맞도록 프로그램을 재구성할 수 있다.</li>
<li>사용자가 가상 메모리 관리 기법에 대해 이해하고 있다면 프로그램의 구조를 변경하여 성능을 높일 수 있다.</li>
<li>지역성과 가상메모리, 페이징시스템을 고려하여 코드를 재구성하여 성능을 높인다.</li>
</ul>
<h2>TLB (traslation lookup buffer) Reach</h2>
<ul>
<li>TLB 를 통해 접근할 수 있는 메모리의 양 이라는 뜻<br />엔트리 사이즈(TLB 사이즈) x 페이지 사이즈<br />reach 가 값이 크면 hit ratio 가 커진다.</li>
<li>TLB 의 hit ratio 를 높이려면<br />TLB 크기 증가 - 너무 비싸다.<br />페이지 크기증가 - 능사가 아님. 페이지가 커지는데 오히려 더 fault 가 발생하는 경우가 있어서. 최근 OS 들은 다양한 페이지 사이즈 지원</li>
</ul>