<h1>TCP 계속</h1>
<h2>Flow Control</h2>
<ul>
<li>프로토콜에서 아주 중요함.</li>
<li>하지만 매우 단순함.</li>
<li>sender, receriver 가 존재하고 각자의 소화가능한 속도가 있음.</li>
<li>이 속도를 맞춰주는 것임.</li>
<li>송신 버퍼, 수신 버퍼가 있음.<br>  소켓에서 데이터 read 는 수신 버퍼에서 끌어오는 것임.</li>
<li>receiver 의 수신 버퍼의 잔여 용량에 맞춰서 sender 가 적절히 속도를 조절함.<br>  속도 조절은 sender 가 하지만, 그것은 receriver 의 잔여 버퍼에 좌우됨.<br>  그리고 sender - receiver 사이의 네트워크 상태에 의해 좌우됨.<br>  빈 버퍼의 크기는 헤더에 넣어서 전달한다.</li>
<li>보내는 양을 조절하는 것은 결국 보내는 속도가 조절되는 것임. bps.</li>
</ul>
<h2>Flow Control 작은 이슈</h2>
<ul>
<li>소켓이 버퍼에서 읽지 않거나 프로세스가 블럭되면 결국 버퍼가 비워지지 않는다.</li>
<li>그렇다면 수신할 수 있는 양이 줄어들어 헤더에 잔여 버퍼가 거의 없다고 알린다.</li>
<li>그래서 sender 는 receriver 의 잔여버퍼가 생길때까지 대기한다.</li>
<li>이 상황이 계속되면 통신이 진행되지 않을 수 있다! receiver 도 계속 대기하므로.</li>
<li>대기가 계속되면 sender 가 주기적으로 의미없는 데이터를 넣어서 보내서 반응을 기다린다.<br>  만약 receiver 의 버퍼 상태가 좋아지면 ACK 에 버퍼 상태를 담아서 보내줄 것이다.<br>  이렇게 지속적으로 통신이 지속되도록 한다.</li>
</ul>
<h2>3 way handshaking</h2>
<ul>
<li>이전의 작업들을 모두 수행하기 위해 먼저 연결과정이 필요하다.</li>
<li>이를 일련의 과정에 의해서 수행한다.</li>
<li>최초에 클라이언트가 세그먼트의 SYN 플래그 비트를 설정하고, 시퀀스 번호를 설정하여 서버에 보낸다.<br>  TCP 연결 의사 표시임.<br>  자시의 상태(seq) 전달</li>
<li>서버는 최초 세그먼트를 받으면 SYN, 시퀀스 번호, ACK 를 클라이언트에게 전달한다.</li>
<li>이 것을 받은 클라이언트는 다시 서버에게 ACK 를 보낸다.<br>  이 3 번 째 세그먼트에서는 실질적으로 데이터를 담아서 보낼 수 있다!<br>  즉 2 번째 까지는 TCP SYN, ACK 이지만 3 번째부터는 HTTP req, res 를 할 수 있다.</li>
<li>이렇게 3 번의 통신이 수행된다.</li>
<li>이 이후에야 모든 통신이 진행된다.<br>  flow control, 시퀀스 번호로 피드백, 시퀀스 번호 트래킹 등등<br>  이 이전에는 버퍼를 만들지조차 않고 연결이 되어야 비로소 버퍼를 생성한다.</li>
</ul>
<h2>3 way handshaking 하는 이유</h2>
<ul>
<li>꼭 3 번 수행안해도 연결은 할 수 있다.</li>
<li>하지만 더 확실하고 신뢰성이 있는 연결을 위해 3 번 수행한다.</li>
<li>만약 2 번 수행하고 sender 가 없어지는 경우, 그걸 다 연결하면 오버헤드다.</li>
<li>3 way 는 TCP 뿐 아니라 여타 연결 프로세스에서 광범위하게 사용되는 방식이다.</li>
</ul>
<h2>Closing TCP</h2>
<ul>
<li>데이터를 다 보냈으면 버퍼를 해제하고 통신을 종료해야 함.</li>
<li>클라이언트가 보낼것 다 보내면 FIN 보냄. 그리고 ACK 를 기다림.</li>
<li>서버는 클라이언트의 FIN 에 대한 ACK 보낸 후 자기가 보낼거 다 보내면 서버도 FIN 을 보낸다.</li>
<li>클라이언트는 서버의 FIN 에 대한 ACK 를 보낸다.</li>
<li>양방 모두 종료해도 되는 상황에도 어느정도 더 유예기간을 두어서 버퍼를 유지시킨다.<br>  서버가 마지막 ACK 를 기다리다가 타임아웃이 되면 재전송해야 하는데,<br>  클라이언트가 ACK 보내고 바로 철수하면 서버는 ACK 에 대한 무한 타임아웃이 발생할 수 있으므로<br>  타임아웃 값은 항상 변하는 값임을 유의. (RTT 연관)</li>
</ul>
<h2>Congestion Control 간략 개념</h2>
<ul>
<li>sender 의 전송속도는 receiver 와 그 사이의 네트워크 전체의 상태에 영향을 받는다.</li>
<li>sender 는 이 둘 중 안좋은 상태에 맞춰서 전송해야한다.</li>
<li>receiver 의 버퍼 상태는 Flow control 메커니즘에 의해 정확히 알 수 있지만, 네트워크 전체에 대한 상태는 알기가 어렵다.<br>  이를 알아내는 것이 congestion control 에서 중요한 것.</li>
<li>이 전체 네트워크는 public 이다.<br>  그래서 이 전체 네트워크는 언젠가 막히게 된다.<br>  TCP 는 막히면 재전송 메커니즘이 있어서 더 많은 데이터를 보내게 된다.<br>  결국 점점 더 악화되기 마련이다.<br>  그래서 TCP 는이러한 congestion 현상을 해결하는 것이 매우 중요하다.</li>
<li>네트워크가 막히면 각자 모두를 위해서 전송속도를 늦춘다.<br>  이것이 congestion control 의 핵심에 해당.</li>
<li>그런데 네트워크 상황에 대한 정보는 어떻게 알 수 있나?</li>
</ul>
<h2>네트워크의 상황을 판단할 수 있는 방법</h2>
<ol>
<li>네트워크(라우터) 가 자신의 상태를 알려준다.<br> 사실상 불가능.<br> 라우터가 너무 바쁨.</li>
<li>end 2 end congestion control<br> 네트워크 정보를 말단 장치가 판단함.<br> 결국 sender, receriver 의 TCP ACK 비트로 유추한다.<br> 아주 정확하진 않음<br> 현재 구현되어있는 방식임</li>
</ol>
