<h1>3 강</h1>
<p>해시, 집합</p>
<p>리스트가 너무 일반적이라서 리스트만 쓰는데 리스트로 풀 수 없는 상황에서 다른 자료구조를 도구로 사용할 수 있게 훈련한다.<br>이전 강의의 스택과 큐가 그러했고, 해시(딕셔너리) 가 그러하다.<br>인덱스가 없는 자료구조는 동작이 언제나 빠르다.<br>그 장점을 잘 알고 자유자재로 사용할 수 있어야 한다.<br>또한 응용력을 길러 고난이도의 문제에 창의적으로 적용할 수 있어야 한다.<br>그래서 이러한 문제들을 푼 것 같다.</p>
<h2>SHA-256</h2>
<ul>
<li><p>난이도 - 하</p>
</li>
<li><p>유형 - 해시, 구현</p>
</li>
<li><p>핵심<br>hashlib 임포트<br>문자열을 encode<br>결과를 hexdigest 하면 끝</p>
</li>
<li><p>비고<br>encode, hexdigest 등을 활용할 줄 알게 된다.</p>
<pre><code>import hashlib

S = input()  
S = S.encode()  
hashlib.sha256(S).hexdigest()</code></pre></li>
</ul>
<h2>수 찾기</h2>
<ul>
<li><p>난이도 - 하</p>
</li>
<li><p>유형 - 해시, 구현</p>
</li>
<li><p>핵심 - 등장여부를 체크한다.</p>
</li>
<li><p>비고<br>너무 단순해서 리스트를 사용했는데 시간초과 났다.<br>그래서 이분탐색까지 썼는데 시간초과가 났다.<br>조금 어리둥절해서 문제 유형을 보고 해시를 사용해야함을 깨달았다.<br>일부러 리스트를 사용하지 말라고 만든 문제인듯하다.<br>사실 set 을 이용해도 되는 문제였다.</p>
<p>해시나 집합 모두 잘 알고 있는 자료구조 였지만 이 문제를 보면서 그 응용력이 한참 떨어진다는 것을 깨달았다.<br>언제 쓸 수 있는지 얼머나 빠른지 감이 없다.<br>결과적으로 해시와 집합은 검색에 매우 빠르다. 이는 인덱스가 없기 때문이다.<br>리스트는 느리다.</p>
</li>
</ul>
<pre><code>
n = int(input())  
a = list(map(int, input().split()))  
m = int(input())  
b = list(map(int, input().split()))

dic = {str(i):0 for i in a}  
print(dic)  
for t in b:  
if str(t) in dic:  
print(1)  
else:  
print(0)

n = int(input())  
a = list(map(int, input().split()))  
m = int(input())  
b = list(map(int, input().split()))

a = set(a)  
for t in b:  
if t in a:  
print(1)  
else:  
print(0)
</code></pre><h2>친구 네트워크</h2>
<ul>
<li><p>난이도 - 중</p>
</li>
<li><p>유형 - 해시, 그래프, 집합</p>
</li>
<li><p>핵심<br>해시를 활용한 union-find 를 활용하면 효율적.<br>union - 합집합을 구한다.</p>
</li>
<li><p>비고<br>union find 알고리즘을 개념 자체를 휙 넘겨서 구현할 수 없었다.<br>대략 집합을 사용하고 합집합 개념도 사용해서 풀었긴 한데 왠지 뭔가 알고리즘이 더 필요하단 생각을 했다.<br>왠만한 알고리즘을 다 마스터 해야겠다.<br>그리고 이 문제는 union, find 함수를 단순화/변형했으므로 참조할 필요가 있다.</p>
<p>그래도 나름대로 문제를 이해하고 해결했다.<br>여러개의 집합, 집합 합치기(합집합), 1 연결인지 2 연결인지 나누기 등등.</p>
</li>
</ul>
<pre><code>
# 친구 네트워크

tc = int(input())  
for _ in range(tc):  
F = int(input())  
relations = []
for _ in range(F):  
relations.append((input().split()))

groups = []

for rel in relations:
    f1, f2 = rel#.split()
    gf1, gf2 = None, None
    for idx, group in enumerate(groups):
        if f1 in group:
            gf1 = idx
        if f2 in group:
            gf2 = idx

    if gf1 != None and gf2 != None:
        if gf1 == gf2:
            print(len(groups[gf1]))
        else:
            groups[gf1] = groups[gf1] | groups[gf2]
            print(len(groups[gf1]))
            #groups[gf1].add(groups[gf2])
            del groups[gf2]

    elif gf1 == None and gf2 == None:
        groups.append(set([f1, f2]))
        print(2)

    elif gf1 != None and gf2 == None:
        groups[gf1].add(f2)
        print(len(groups[gf1]))

    elif gf1 == None and gf2 != None:
        groups[gf2].add(f1)
        print(len(groups[gf2]))</code></pre><pre><code># 친구 네트워크 - 유니온 파인드

tc = int(input())

def find(x):  
if x == parent[x]:  
return x  
else:  
p = find(parent[x])  
parent[x] = p  
return parent[x]

def union(x, y):  
x = find(x)  
y = find(y)

if x != y:
    parent[y] = x
    number[x] += number[y]

for _ in range(tc):  
f = int(input())  
parent = {}  
number = {}

for _ in range(f):
    x, y = input().split()

    if x not in parent:
        parent[x] = x
        number[x] = 1
    if y not in parent:
        parent[y] = y
        number[y] = 1

    union(x, y)

    print(number[find(x)])</code></pre>