<h1>메모리 관리</h1>
<h2>메모리 종류</h2>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@rJPD2/btqLNrqyg99/nk9277kD323ETmO6EE14J1/img.png" ><p class="cap1">data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>이러한 계층구조를 가지게 된 이유는 I/O 병목 현상때문임.</p>
<p>레지스터, 캐시는 CPU 안에 있음.</p>
<p>나머지는 외부에 있고 OS 가 관리한다.</p>
<h2>메모리 계층구조</h2>
<ul>
<li><p>block</p>
<p>보조기억장치와 주기억장치 사이의 데이터 전송 단위</p>
<p>블럭 단위로 전송한다.</p>
<p>1 ~ 4 KB</p>
</li>
<li><p>word</p>
</li>
</ul>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@bvM3rq/btqLLGhcoFO/gdiWqamtFg1Zv6RLJ8fMh1/img.png" ><p class="cap1">data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<p>  주기억장치와 레지스터 사이의 데이터 전송 단위</p>
<p>  레지스터는 한 번에 word 사이즈만큼 읽는다.</p>
<p>  레지스터의 사이즈가 word 사이즈에 해당한다고 생각해도 됨?</p>
<p>  16 ~ 64 bit</p>
<h2>Address Binding</h2>
<ul>
<li><p>프로그램의 논리 주소를 실제 메모리의 물리 주소로 매핑하는 작업</p>
</li>
<li><p>바인딩 시점에 따른 구분</p>
</li>
</ul>
<ol>
<li><p>compile 할 때 바인딩</p>
<p>프로세스가 메모리에 적재될 위치를 컴파일러가 알 수 있을 때 가능.</p>
<p>프로그램 전체가 메모리에 올라가야 함.</p>
</li>
<li><p>load 할 때 - 링킹 도중</p>
<p>메모리 적재 위치를 컴파일 시점에서 모르면 대체 가능한 상대 주소 생성.</p>
<p>프로그램 전체가 메모리에 올라가야 함.</p>
</li>
<li><p>run 할 때</p>
<p>바인딩을 수행시간까지 연기.</p>
<p>프로세스 수행 도중 다른 메모리 위치로 이동할 수 있음.</p>
<p>HW 도움이 필요 (memory management unit)</p>
<p>현재 대부분 OS 가 사용.</p>
</li>
</ol>
<h2>Dynamic Loading</h2>
<ul>
<li><p>모든 루틴(함수 등)을 교체 가능한 형태로 디스크에 저장</p>
</li>
<li><p>호출 전 까지는 루틴을 적재하지 않음.</p>
</li>
<li><p>호출할 때 바인딩을 수행.</p>
</li>
<li><p>메모리 공간이 효율적이다.</p>
</li>
</ul>
<h2>swapping</h2>
<ul>
<li><p>프로세서 할당이 끝나고 수행 완료 된 프로세스는 swap device 보내고 - swap out</p>
</li>
<li><p>새롭게 시작하는 프로세스는 메모리에 적재 - swap in</p>
</li>
</ul>
<h2>Memory Allocation</h2>
<ul>
<li><p>continuous memory allocation - 연속 할당</p>
</li>
<li><p>non continuous memory allocation - 비연속 할당</p>
</li>
</ul>
<h2>연속 할당</h2>
<ul>
<li>프로세스를 하나의 연속된 메모리 공간에 할당하는 정책</li>
</ul>
<p>프로그램, 데이터, 스택 등</p>
<ul>
<li>메모리 구성 정책</li>
</ul>
<p>메모리에 동시에 올라갈 수 있는 프로세스 수 필요 - multiprogramming degree</p>
<p>메모리 분할 방법 필요</p>
<p>각 프로세스 할당 메모리 공간 크기 필요</p>
<h2>Uni programming</h2>
<ul>
<li><p>multiprogramming degree = 1</p>
</li>
<li><p>하나의 프로세스만 메모리에 존재</p>
</li>
<li><p>가장 단순한 형태의 메모리 관리법</p>
</li>
</ul>
<h2>Uni programmer 문제점</h2>
<ol>
<li>프로그램의 크기 &gt; 메모리 크기</li>
</ol>
<ul>
<li><p>해결법</p>
<p>overlay structure 방법</p>
<p>메모리에 현재 필요한 영역만 적재</p>
<p>하지만 사용자가 프로그램의 흐름 및 자료구조를 모두 알고 있어야 함.</p>
</li>
</ul>
<ol start="2">
<li>커널 위험성</li>
</ol>
<p>커널 영역의 메모리를 건드릴 수 있다.</p>
<ul>
<li><p>해결법</p>
<p>  경계 레지스터 사용.</p>
</li>
</ul>
<ol start="3">
<li>자원 낭비</li>
</ol>
<p>빈 메모리 공간이 많다.</p>
<ul>
<li><p>해결법</p>
<p>  multi-programming</p>
</li>
</ul>
<h2>Fixed Partition Multiprogramming (FPM)</h2>
<p><div class="imageblock dual" style="text-align: center;"><table cellspacing="5" cellpadding="0" border="0" style="margin: 0 auto;"><tr><td><img src="http://cfs.tistory.com/attach/4204798/kage@bwfWu5/btqLLGhc855/ti1Ip1k3Lj1RTGn8ecXQe1/img.png" ><p class="cap1">data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"</p></td><td><a href="https://weflug.tistory.com/attachment/"><img src="https://t1.daumcdn.net/tistory_admin/assets/blog/20201203185817/blogs/image/extension/unknown.gif?_version_=20201203185817" alt="" style="vertical-align: middle;" /> invalid-file</a></td></tr></table></div></p>
<ul>
<li><p>메모리 공간을 고정된 크기로 미리 분할해놓는다.</p>
</li>
<li><p>각 프로세스는 하나의 파티션에 적재</p>
</li>
<li><p>파티션 수 = 멀티프로그래밍 degree</p>
</li>
<li><p>커널 아래 뿐 아니라 각 침범을 방지하기 위해 파티션 간의 바운더리 레지스터를 두어야 함.</p>
</li>
</ul>
<h2>Fragment (단편화)</h2>
<ul>
<li><p>internal fragmentaion</p>
<p>내부 단편화</p>
<p>파티션 크기 &gt; 프로세스 크기</p>
<p>메모리가 낭비된다.</p>
</li>
<li><p>external fragment</p>
<p>외부 단편화</p>
<p>남은 메모리 크기 &gt; 프로세스 크기 이지만, 연속된 공간이 아니라서 구동을 못함.</p>
<p>역시 메모리가 낭비됨.</p>
</li>
</ul>
<h2>Fixed partition multiprogramming 요약</h2>
<ul>
<li><p>고정된 크기로 메모리 미리 분할.</p>
</li>
<li><p>메모리 관리가 편함</p>
</li>
<li><p>시스템 자원이 낭비된다.</p>
</li>
</ul>
<h2>Variable Partition Multiprogramming (VPM)</h2>
<ul>
<li><p>초기에는 전체가 하나의 영역</p>
</li>
<li><p>프로세스를 처리하는 과정에서 메모리 공간이 동적으로 분할</p>
</li>
<li><p>internal fragmentation 이 발생하지 않음. 필요한 만큼만 그때그때 할당하기 때문</p>
</li>
<li><p>하지만 종료된 프로세스가 빈 공간을 남겨서 다음 들어오는 프로세스의 배치하는데 전략이 필요함.</p>
</li>
</ul>
<h2>배치 전략</h2>
<p>다 장단점이 있으므로 잘 선택하는 것이 좋다.</p>
<ul>
<li><p>first fit (최초 적합)</p>
<p>충분한 크기를 가진 첫 번째 파티션을 선택한다.</p>
<p>단순하고 오버헤드가 적다.</p>
<p>하지만 공간 활용률이 떨어질 수 있다.</p>
</li>
<li><p>best fit (최적 적합)</p>
<p>프로세스가 들어갈 수 있는 파티션 중 가장 작은 곳을 선택</p>
<p>탐색시간이 오래걸림 - 오버헤드가 있다.</p>
<p>큰 여유 통째 파티션을 유지할 수 있지만 작은 크기의 파티션이 많이 생기는 단점이 있다.</p>
</li>
<li><p>worst fit (최악 적합)</p>
<p>프로세스가 들어갈 수 있는 파티션 중 가장 큰 곳을 선택</p>
<p>탐색시간이 오래걸린다.</p>
<p>작은 크기의 자투리 공간이 줄어든다.</p>
<p>대신 큰 크기의 파티션 확보가 어렵다.</p>
</li>
<li><p>next-fit (순차 최초 적합)</p>
<p>최초 적합 전략과 유사</p>
<p>stale table 에서 마지막으로 탐색한 위치부터 탐색</p>
<p>메모리 영역 사용 빈도가 균등화된다.</p>
<p>오버헤드도 적다.</p>
</li>
</ul>
<h2>외부 파편화 이슈 해결 -  Coalescing holes (공간 통합)</h2>
<ul>
<li><p>인접한 빈 영역을 하나의 파티션으로 통합</p>
<p>프로세스가 메모리를 release 하고 나가면 수행.</p>
<p>단순히 테이블의 공간을 통합해주면 되므로 오버헤드가 적다.</p>
</li>
</ul>
<h2>외부 파편화 이슈 해결 - Storage Compaction (메모리 압축)</h2>
<ul>
<li><p>모든 빈 공간을 하나로 통합</p>
</li>
<li><p>프로세스 처리에 필요한 적재공간 확보가 필요할 때 수행.</p>
</li>
<li><p>하지만 모든 프로세스를 중지하고 재배치해야하므로 많은 시스템 자원을 소비한다. 자주해주면 안됨.</p>
</li>
</ul>
<h2>메모리 할당을 알아야 하는 이유</h2>
<ul>
<li><p>어짜피 OS 가 알아서 메모리 관리한다.</p>
</li>
<li><p>하지만 프로그래밍 할 때 메모리 풀링 기법을 적용하여 효율적으로 메모리를 사용할 수 있다.</p>
</li>
<li><p>이 FPM, VPM 개념을 활용할 수 있다.</p>
</li>
</ul>
