<h1>js 문법 계속</h1>
<ul>
<li>js 는 설계상 오류가 좀 있는듯 하다. js 는 ES 6 로 갈라지고 나서 vanilla js 는 오류를 그대로 가지고 있다. 아마 ES 6 를 준수하며 작성하는 것이 좋을 듯 하다.</li>
</ul>
<h2>변수 타입</h2>
<ul>
<li>원시 타입에<br>number<br>string<br>boolean<br>null<br>undefined<br>symbol</li>
<li>객체 타입에<br>  object 라는 것이 있다.<br>확인은 typeof 라는 연산자로<br><code>typeof _var</code>, <code>typeof(_var)</code></li>
</ul>
<h2>변수 선언</h2>
<ul>
<li>파이썬 처럼 타입을 지정하지 않는다.</li>
</ul>
<h2>연산자</h2>
<ul>
<li>기본적인 연산자를 지원한다.</li>
<li>특이하게 등호를 3 개 사용한다.</li>
<li><code>===</code>, <code>!==</code></li>
<li>논리 연산자는 <code>!</code>, <code>&amp;&amp;</code>, <code>||</code> 를 사용한다.</li>
<li>파이썬보다 더 유연한 타입간 연산이 가능하다.</li>
<li>숫자와 문자열을 더하면 문자열로 합쳐진다.</li>
<li>둘을 곱하면 숫자로 된다.</li>
<li>그래서 주의해야 한다.</li>
</ul>
<h2>주석</h2>
<p><code>//</code>, <code>/**/</code> 으로 c 계열의 주석과 동일하다.</p>
<h2>함수</h2>
<ul>
<li>function 으로 정의한다.</li>
<li>js 는 파이썬처럼 함수가 1 급 객체이다.</li>
<li>즉 변수에 할당가능하고, 파라미터로 넘길 수 있고 리턴을 할 수 있다.</li>
<li>파이썬에서는 함수는 보통 함수대로 쓰는데, js 에서는 변수에다가 많이 집어넣는 듯하다.<pre><code>var f = function(s){
  tmp = 10;
  s(10);
  return s;
}</code></pre></li>
</ul>
<h2>객체</h2>
<ul>
<li>js 는 객체 기반의 스크립트 언어.</li>
<li>원시 타입 변수를 제외한 모든 값들이 객체이다.</li>
<li>함수, 배열, 정규표현식 등 모두 객체이다.</li>
<li>{} 안에 세미콜론으로 key:value 형태로 구성된 프로퍼티의 집합이다.</li>
<li>프로퍼티로는 js 에서 사용할 수 있는 모든 값을 사용할 수 있다.</li>
<li>물론 일급 객체인 함수 역시 프로퍼티 값으로 사용할 수 있다.</li>
<li>객체 안의 함수는 밖에 있는 함수와 구분하기 위해 메서드라고 한다. 파이썬처럼</li>
<li>js 의 객체는 상속을 구현하기 위해 프로토타입 이라는 객체의 프로퍼티와 메소드를 상속받을 수 있다.</li>
<li>프로토타입은 다른 언어에서는 흔하지 않은 중요한 개념이다.<pre><code>var obj = {
  func : function(){
      return 1;
  },
  num : 10,
  str : &#39;23&#39;
}</code></pre></li>
</ul>
<h2>원시 타입 변수</h2>
<ul>
<li>변경 불가능한, 값에 의한 전달 방식 데이터</li>
<li>파이썬처럼 2 진수, 8, 16 진수 표현 가능</li>
<li><code>var binary = 0b1010110;</code></li>
<li><code>var oct = 0o73321260;</code></li>
<li><code>var hex = 0xa938;</code></li>
<li>충격적인 것은 number 타입에 사실 정수는 없다는 것.</li>
<li>모든 것은 실수다.</li>
<li><code>console.log(2 === 2.0)</code> 는 <code>true</code> 이다.</li>
<li>더 충격적인것은 division by zero 가 없다.</li>
<li>무한대를 표현한다.</li>
<li><code>console.log(10/0)</code> 는 <code>Infinity</code> 라고 나온다.</li>
<li><code>console.log(-10/0)</code> 는 <code>-Infinity</code> 라고 나온다.</li>
<li>파이썬은 숫자 * 문자열은 문자열의 반복인데, js 는 연산이 불가능하다.</li>
<li>그러니까 숫자로 변환이 불가능한 문자열일 때.</li>
<li>이 때도 충격적이게 에러가 아닌 `NaN 이라는 값을 반환한다.</li>
<li><code>console.log(1 * &#39;ds&#39;)</code> 의 결과는 <code>NaN</code></li>
</ul>
<h2>문자열</h2>
<ul>
<li>파이썬처럼 변경불가.</li>
<li>하지만 변경시도 했을 때 에러는 발생하지 않는다..?</li>
</ul>
<h2>boolean</h2>
<ul>
<li><code>true</code>, <code>false</code> (소문자) 2 개의 값을 가진다.</li>
<li>빈 문자열 <code>&#39;&#39;</code>, <code>null</code>, <code>undefined</code>, <code>0</code> 은 <code>false</code> 로 간주한다. 파이썬처럼</li>
</ul>
<h2>undefined</h2>
<ul>
<li>이 타입은 <code>undefined</code> 이라는 값이 유일하다.</li>
<li>선언하고 값을 할당하지 않은 변수의 값에 해당한다.</li>
<li>js 는 쓰레기값을 가진 상태로 두지 않고 이 값으로 초기화한다.</li>
</ul>
<h2>null</h2>
<ul>
<li>이 타입도 <code>null</code> 값이 유일하다.(전부 소문자)</li>
<li>의도적으로 변수에 값이 없다는 것을 명시하기 위한 목적이다.</li>
<li>파이썬의 <code>None</code> 과 유사함.</li>
<li>변수에 할당된 값을 제거하려고 할 때 사용하거나 null 을 반환하기 위해 쓴다.</li>
<li>해제된 값은 가비지 컬렉터가 수거한다.</li>
<li>중요한 건 <code>typeof</code> 로 null 변수를 체크하면 <code>object</code> 타입이 나온다. 이는 설계상 오류란다.</li>
<li>그래서 null 인지 아닌지 <code>boolean</code> 으로 확인해서 판단해야 한다.</li>
</ul>
<h2>symbol</h2>
<ul>
<li>ES 6 에서 새로 추가된 원시 7 번째 타입</li>
<li><code>Symbol()</code> 함수로 생성한다.</li>
<li>충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용한다고 한다.</li>
<li>프로퍼티의 이름을 위한 것인 듯하다.</li>
</ul>
<h2>객체 타입</h2>
<ul>
<li>객체는 값과 메서드를 포함하는 클래스의 인스턴스 같은 개념이다.</li>
<li>참조에 의한 전달 방식을 취한다.</li>
<li>변수 자체도 객체이다. 모든 변수. 값 말고 변수</li>
</ul>
<h2>변수</h2>
<ul>
<li><code>var</code>, <code>let</code>, <code>const</code> 키워드를 사용하여 생성한다.</li>
<li>값이 할당되지 않은 변수는 <code>undefined</code> 이며</li>
<li>선언조차 하지 않은 변수에 접근할 때 비로소 참조 에러를 발생시킨다.</li>
<li><code>var</code> 키워드는 변수를 중복 선언할 수 있다. 재할당이 아닌 중복선언</li>
<li>이는 안 쓰는것이 좋다. 사실 파이썬은 선언 자체가 생략되다시피 하니까 그것보단 양반이다.</li>
<li>재할당하면 값에 따라서 타입이 변한다.</li>
</ul>
<h2>hoisting</h2>
<ul>
<li>js 의 특이한 변수 생명 주기 메커니즘.</li>
<li>js 에서 변수는 선언 - 초기화 - 할당의 3 단계가 있다.</li>
<li>var 키워드는 선언-초기화가 한꺼번에 진행된다. 일단 생성하면 undefined 되니까.</li>
<li>호이스팅이란 var, function 선언문 등 모든 선언문이 해당 scope 의 선두로 옮겨진 것처럼 동작하는 것을 의미함.</li>
<li>그래서 모든 선언문이 선언되기 이전에 참조가 가능하다.(var, let, const, function, class) 등</li>
<li>변수 선언을 밑에서 해도 위에서 참조, 할당이 가능하다.</li>
</ul>
<h2>스코프</h2>
<ul>
<li>함수레벨 스코프<br>  함수 내에서 선언된 변수는 함수 내에서만 유효한 지역변수이고 함수 밖에서 선언한 변수는 전역변수.</li>
<li>블록레벨 스코프<br>코드 블록 내에 선언된 변수는 코드 블록 내에서만 유효하고 코드 블럭 밖에서 참조 불가.<br>c 계열 등은 if 문 안의 변수는 밖에서 참조 불가능.<br>  js 는 함수레벨 스코프.</li>
<li>함수레벨 스코프는 전역변수 남발을 허용하고 또 호이스팅으로 인한 변수 재할당이 발생할 수 있다.</li>
<li>그래서 ES 6 에서 추가된 let, const 라는 블럭 레벨 스코프 키워드가 추가되었다.</li>
<li>반복문 안의 변수가 전역변수로 사용되기도 하는 등의 문제도 있어서 심각한 문제가 발생할 수 있다.</li>
<li>대부분의 문제는 var 전역변수 때문에 발생한다고 한다.</li>
</ul>
<h2>문</h2>
<ul>
<li>세미콜론은 붙이는 것을 권장한다고 한다..</li>
</ul>
<h2>연산자</h2>
<ul>
<li>기본 4칙 연산과 나머지 연산 % 를 지원한다. 몫 연산자는 따로 없는 듯하다.</li>
<li>++, -- 연산자를 지원하고 후위, 전위 연산이 가능하다.</li>
</ul>
<h2>문자열 연산자</h2>
<ul>
<li><ul>
<li>는 피연산자 둘 중 하나가 문자열인 경우 문자열 연결한다.</li>
</ul>
</li>
<li>이외에는 덧셈 연산이 된다.</li>
<li>주의할 것은 1 + true 는 2 가 된다..</li>
<li>null, false 은 0 으로 형변환이 일어나서 덧셈이 된다.</li>
<li>그리고 undefined 와 + 연산을 하면 NaN 이 된다..</li>
</ul>
<h2>할당 연산자</h2>
<ul>
<li>+=, %=, *= 등</li>
<li>y = x = 10 으로 연속 할당 가능.</li>
</ul>
<h2>동등/일치 비교 연산자</h2>
<ul>
<li>동등/부등 연산자는 ==, != 이다.</li>
<li>다른 언어와 다르게 암묵적 형변환 한 데이터들의 비교결과를 낸다.</li>
<li>타입이 달라도 값이 같아지면 true 를 반환한다.</li>
<li>일치/불일치 연산자는 ===, !== 이다.</li>
<li>이는 타입과 값이 다 같아야 true 를 반환한다.</li>
<li>그래서 동등 연산자는 쓰지말아야 한다.</li>
<li>하지만 NaN 은 언제나 주의해야 하는데, 자기자신과 일치하지 않는 유일한 값이다.</li>
<li><code>NaN === NaN</code> 은 false 다.</li>
<li><code>isNaN()</code> 내장함수를 이용해 NaN 을 확인해야 한다!</li>
<li>또한 당연히 0 === -0 도 true 다.</li>
</ul>
<h2>삼항 연산자</h2>
<ul>
<li>(condition) ? a : b 연산자를 지원한다.</li>
</ul>
<h2>논리 연산자</h2>
<ul>
<li>and, or 은 각각 &amp;&amp;, || 이다.</li>
<li>부정은 !</li>
<li>! 는 항상 boolean 결과이지만 and, or 는 그렇지만은 않다.</li>
<li>이들은 피연산자 중 하나의 값을 반환한다고 한다.</li>
</ul>
<h2>typeof 연산자</h2>
<ul>
<li>연산자의 하나라고 한다.</li>
<li>파이썬같이 내장함수가 아니라 연산자이므로 괄호가 필요없이 연산자처럼 적어주면 된다.</li>
<li>값의 타입을 문자열로 반환한다.</li>
<li>주의할 것은 <code>null</code> 타입을 <code>object</code> 로 반환한다는 것. 일치 연산자로 확인해야 함!</li>
</ul>
