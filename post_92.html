<h1>최단거리</h1>
<p>꽤 난이도 있는 알고리즘이고 고난도 문제에 나타난다.<br>왠만한 테스트에서 나오는 것은 많이 보진 못했다.<br>보통 테스트에서는 기본 구현 능력을 보는 경우가 많기 때문이다.<br>하지만 고난도 문제에서는 최단거리 알고리즘을 알고 있어 응용할 수 있는 수준이 필요하다.<br>방향성에 관계없이 체크 가능하다.<br><code>edge relaxation</code> 이라는 용어가 쓰이는데, 단순히 최단거리를 갱신하는 과정이라고 생각하면 된다.</p>
<h2>Dijkstra</h2>
<ul>
<li><p>개념 - <strong>가중치 그래프</strong>에서 한 노드로부터 나머지 모든 노드까지의 최단거리들을 구한다.<br>heap 을 이용한 버전이 가장 효율적인 편이다.<br>BFS 와 유사하게 작동한다. 단 Queue 가 아니라 heap 을 사용한다.<br>매번 최소 길이를 선택하여 업데이트 하므로 Greedy 전략을 사용한다.</p>
</li>
<li><p>비고<br>시간 복잡도는 heap 이 지배적이여서 $O(ElogV)$ 이다.<br>최단 경로를 뽑아내는 작업은 도착지부터 출발점까지 BFS 를 역으로 돌리면 수행할 수 있다.<br>잔트릭으로 최단경로를 구하기보다 BFS 로 돌리면 모든 최단 경로를 뽑아낼 수 있다.</p>
<p>다익스트라의 한계점은, 그리디 알고리즘이므로 조건에 의해서 최적 부분 구조가 깨질 수 있다.<br>다음 스텝에 음수의 간선이 있을 경우 당장의 최단 경로가 전체 최단 경로라는 보장을 할 수 없다.<br>또한 음수 사이클이 있으면 음의 무한대로 발산한다.<br>음수 간선이 있으면 틀린 결과가 나오므로 아예 음수 간선이 있으면 안된다.</p>
</li>
</ul>
<pre><code>def dijkstra(start):
    dists = {i:1e9 for i in graph_w}            # 각 노드까지 최단거리 초기화
    dists[start] = 0
    heap = []
    heapq.heappush(heap, (0, start))
    while heap:                                    # 힙에 노드가 남아있다면 계속 갱신
        cur_dist, cur_node = heapq.heappop(heap)
        if cur_dist &gt; dists[cur_node]:            # 현재 체크할 노드가 이미 저장된 경로길이보다 길다면 검사할 필요가 없다.
            continue

        for next_node, next_dist in graph_w[cur_node].items():    # 현재 노드에 연결된 노드들에 대해 최단거리 비교 후 갱신.
            new_dist = cur_dist + next_dist
            if new_dist &lt; dists[next_node]:
                dists[next_node] = new_dist
                heapq.heappush(heap, (new_dist, next_node))

    return dists</code></pre><h2>Bellman-Ford</h2>
<ul>
<li><p>개념<br>다익스트라 처럼 한 정점으로부터 나머지 모든 정점까지의 최단거리를 구하는 솔루션이다.<br>정점 수 만큼 반복하며 relaxation 을 진행한다.<br>출발점부터 도착점까지 경로가 총 노드의 갯수보다 커지면 결국 사이클이 있다는 의미이므로 최대 정점 수 만큼만 반복한다.<br>그리디가 아닌 DP 전략을 사용하여 음수 간선을 처리할 수 있다.</p>
</li>
<li><p>비고<br>다익스트라와 차이점은 음수 간선을 처리할 수 있다는 점이고, 음수 간선 사이클을 감지할 수 있다는 점이다.<br>음수 간선이 포함되도 모든 경우를 다 확인할 수 있어 올바른 최단거리를 뽑을 수 있지만, 음수 간선 사이클이 있으면 종료를 해야한다.<br>기능이 추가된만큼 다익스트라보다 비효율적이다. $O(V \times E)$<br>노드 수 만큼 relaxation 을 수행한 후 한 번 더 relaxation 을 시도하다가 수행되면 음수 사이클이 있다는 것이다.</p>
</li>
</ul>
<pre><code>def bellman_ford(graph, start):
    # 그래프 정보에서 edge 정보를 뽑아내는 과정
    # 입력 형태에 따라 불필요할 수도 있다.
    edges = []
    for src in graph:
        for dst in graph[src]:
            edges.append((src, dst, graph[src][dst]))

    # dists 배열 초기화 - relaxation
    dists = {k:1e9 for k in graph}
    dists[start] = 0

    for node in graph[start]:
        dists[node] = graph[start][node]

    # 각 node 횟수 만큼 돌며 relaxation 수행
    for _ in graph:
        for src, dst, w in edges:
            new_dist = dists[src] + w
            if dists[dst] &gt; new_dist:
                dists[dst] = new_dist


    # 음의 사이클 감지
    # relaxation 이 더 일어난다면 음의 사이클이 존재한다.
    for src, dst, w in edges:
        new_dist = dists[src] + w
        if dists[dst] &gt; new_dist:
            print(&#39;negative cycle detected&#39;)
            return False
    return dists

bellman_ford(n_graph, &#39;A&#39;)</code></pre><h2>Floyd-warshall</h2>
<ul>
<li>개념<br>모든 정점에서 모든 정점에서 즉, all pair 최단거리를 구하는 솔루션<br>단순한 3 중 for 문을 도는 DP 개념으로 직관적이며 간단한 알고리즘이다.<br>거쳐가는 노드를 중심으로 최단거리를 갱신하는 아이디어이다.</li>
<li>비고<br>$O(N^3)$ 의 시간 복잡도<br>2 차원 배열을 가지고 있어 DP cache 처럼 쓴다.</li>
</ul>
<pre><code>def floyd_warshall(graph):
    dists = {k:{k2: 1e9 for k2 in graph} for k in graph}

    # 최단거리 배열 초기화 - edge relaxation
    for k, v in graph.items():
        graph[k][k] = 0
        for k2, v2 in graph[k].items():
            dists[k][k2] = v2

    # 거쳐가는 노드
    for node in graph:
        # 출발점
        for src in graph:
            if src == node:
                continue
            # 도착점
            for dst in graph:
                if dst == node:
                    continue
                new_dist = dists[src][node] + dists[node][dst]
                if dists[src][dst] &gt; new_dist:
                    dists[src][dst] = new_dist
    return dists

floyd_warshall(graph_w)</code></pre><h2>최단 경로 뽑아내기</h2>
<ul>
<li><p>개념<br>최단 거리뿐 아니라 최단 경로를 모두 뽑아내는것이다.<br>앞의 알고리즘들은 최단 거리만을 알 수 있고 경로를 뽑아내려면 별도의 작업이 필요하다.</p>
</li>
<li><p>비고<br>각 알고리즘을 수행하면서 추가적인 메모리를 사용하면 간단하게 최단 경로를 추적할 수 있다.<br>하지만 최단 거리인 경로가 여러가지일 때에도 최초 확인한 단 하나의 경로만을 추적할 수 있다.</p>
<p>근본적으로 dfs, bfs 와 같은 완전탐색 알고리즘으로 역추적하여 모든 경로를 뽑아낼 수 있다.</p>
<p>bfs 보다 dfs 로 뽑는 것이 더 쉬울 수 있다.<br>도착점부터 출발점까지 거꾸로 끝까지 가면서 저장한 노드들을 마지막에 다 반환해주면 편리하다.<br>bfs 는 정보를 더 추가해줘야 할 것 같다.<br>마치 위상정렬 문제와 유사하게 다가온다.<br>결국 위상정렬도, 경로 찾기도 모두 bfs, dfs 탐색을 하는 것이다.</p>
</li>
</ul>
<blockquote>
<p>작성중...</p>
</blockquote>
<pre><code>import heapq
from collections import deque

def dijkstra(start):
    dists = {i:1e9 for i in graph_w}
    dists[start] = 0
    heap = []
    heapq.heappush(heap, (0, start))

    while heap:
        cur_dist, cur_node = heapq.heappop(heap)
        if cur_dist &gt; dists[cur_node]:
            continue

        for next_node, next_dist in graph_w[cur_node].items():
            if cur_dist + next_dist &lt; dists[next_node]:
                dists[next_node] = cur_dist + next_dist
                heapq.heappush(heap, (cur_dist + next_dist, next_node))


    # 최단 경로 추적.
    # bfs 를 이용해 역추적하므로 방향성 그래프일 경우 edge 를 뒤집어주는 과정이 필요하다.
    path = {node:[] for node in graph_w}
    for end in graph_w:
        check = {node:False for node in graph_w}
        q = deque(end)
        while q:
            here = q.popleft()
            for there in graph_w[here]:
                if not check[there]:
                    if dists[here] - graph_w[there][here] = dists[there]:

                    check[there] = True

    return dists

dijkstra(&#39;A&#39;)</code></pre>