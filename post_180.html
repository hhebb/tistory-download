<h2>신뢰성 있는 프로토콜</h2>
<ul>
<li>이전의 RDT 3 는 신뢰성이 확보되었지만 단일 패킷에 한정적임.</li>
<li>하나 보내고 하나 확인하고 반복하게 된다.</li>
<li>효율성도 필요하게 되었다.</li>
<li>이를 stop-wait 연산으로 계산할 수 있다.</li>
</ul>
<h2>pipelined protocols</h2>
<ul>
<li>여러개의 패킷을 보낼 때 신뢰성이 있는 프로토콜</li>
<li>어려운 점은, 한번에 보내면 어떤것은 유실되고 어떤것은 에러가 난다는 것을 처리해야한다는 것이다.</li>
</ul>
<h2>Go Back N</h2>
<ul>
<li>여러개의 패킷을 보내는 신뢰성 있는 프로토콜. </li>
<li>도중에 피드백없이 동시에 보내고 타임아웃 켠 후 한 번에 피드백 받는 개념</li>
<li>sender 의 입장에선 다음을 가진다.</li>
<li>윈도우<br>  피드백 없이 한 번에 동시에 보낼 패킷의 갯수</li>
<li>ACK(n)<br>  정상적인 피드백을 받은 갯수. 패킷이 여러개이므로 n 개<br>  n 번까지 다 제대로 받았다는 피드백을 의미한다.<br>  n 은 시퀀스 번호.</li>
<li>timeout(n)<br>  ACK 받기 전에 타임아웃이 터지면 재전송한다.<br>  시퀀스 번호 이상의 윈도우 사이즈 포함해서?</li>
<li>receiver 입장에서는 정말 단순하다.<br>  자신이 받아야할 시퀀스 번호만 마냥 기다린다.<br>  자신이 기다리고 있는 시퀀스 번호를 ACK 와 함께 sender 에게 보낸다.<br>  이 상황에선 계속 중복 전송해야하는 일이 생길 수가 있다.</li>
</ul>
<h2>GBN 정리</h2>
<ul>
<li>만약 에러나 유실이 없으면 차례대로 하나씩 추가로 보내는 효과가 난다.</li>
<li>하나씩 보내다가 Go, 유실되거나 에러나면 윈도우 사이즈만큼 Back N.</li>
<li>윈도우 사이즈만큼의 패킷은 버퍼에 저장하고 있어야 한다.</li>
<li>단점<br>  하나 유실되었다고 통째로 재전송해야한다.<br>  receiver 가 멍청해서 그런것임.</li>
</ul>
<h2>Selective Repeat</h2>
<ul>
<li>통째로 재전송하는 것의 단점을 보완.</li>
<li>ACK 의 의미를 조금 변경한다.<br>  ACK(n) 은 n 까지 받았다는것이 아니라 n 을 잘 받았다라는 의미로 바꾼다.</li>
<li>receiver 의 동작이 강화된다.<br>  receiver 도 윈도우 크기만큼 버퍼를 가진다.<br>  수신자의 윈도우만큼 다 받으면 윈도우 크기만큼 윈도우를 이동시킨다.</li>
<li>유실된 패킷만 재전송하도록 동작한다.</li>
</ul>
<h2>selective repeat 의 딜레마</h2>
<ul>
<li>시퀀스 번호에 대한 문제</li>
<li>윈도우 사이즈만큼 시퀀스 번호를 정하면 된다.<br>  근데 시퀀스 번호보다 윈도우 사이즈가 크면, 재전송 상황 발생시 꼬이게 된다.<br>  시퀀스 번호를 늘리면 해결된다.</li>
<li>그런데 시퀀스 번호는 작아야 좋다.<br>  윈도우 사이즈와의 관계를 고려하여 최적의 시퀀스 번호를 정해야 한다.<br>  둘은 굉장히 긴밀한 관계다.<br>  시퀀스 넘버는 재전송 패킷을 구별하기 위한것임을 기억</li>
<li>또 문제점은 각 패킷마다 타임아웃을 달아야 하는데, 실제로는 매우 많은 패킷을 보내면 오버헤드가 생기는 문제가 있다.<br>  이는 비현실적임.</li>
</ul>
