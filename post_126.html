<h1>disjoint set</h1>
<p>상호 배타적 집합<br>이 개념은 그렇게 범용적이지 않다고 생각했는데 정말 생각보다 꽤 자주 쓰인다.<br>문제에서도 그렇고, 활용도가 꽤나 높은듯하다.<br>그래프 문제에 적용되는만큼 잘 알아둬야 한다.<br>특히 크루스칼 알고리즘에 핵심이다.<br>무엇보다 참신하고 재미있는 구현법을 가진 자료구조라고 생각한다.</p>
<h2>서로소 집합 (disjoint set)</h2>
<ul>
<li>개념<br>서로 중복되지 않는 원소끼리 부분집합을 이루고 있는 구조</li>
<li>비고<br>그래프를 덩어리 지을 때 사용하기도 한다.<br>union-find 알고리즘을 사용하여 서로소 집합을 표현할 수 있다.<br>서로소 집합인지 아닌지 판단할 수도 있다.<br>중복되지 않는다는 것은 그래프에서 사이클이 발생하지 않는다는 것과 동일하다.<br>최적화 기법을 다 사용하면 각 연산의 시간 복잡도는 $O(N)$ 으로 매우 효율적으로 변한다.</li>
</ul>
<pre><code># disjoint set
nodes = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;]
edges = [
    (&#39;A&#39;, &#39;B&#39;),
    (&#39;B&#39;, &#39;C&#39;),
    (&#39;H&#39;, &#39;D&#39;),
    (&#39;D&#39;, &#39;E&#39;),
    (&#39;F&#39;, &#39;G&#39;)
]

def union(src, dst):
    root_1 = find(src)
    root_2 = find(dst)
    # union-by-rank
    if ranks[root_1] &gt; ranks[root_2]:
        parents[root_2] = parents[root_1]
    else:
        parents[root_1] = parents[root_2]
        if ranks[root_1] == ranks[root_2]:
            ranks[root_2] += 1

def find(node):
    parent_node = parents[node]
    if parent_node == node:
        return node
    else:
        parent_node = find(parents[node])
        # path compression
        parents[node] = parent_node

    return parent_node

def disjoint_set(nodes, edges):    

    for i in range(len(nodes)):
        ranks[nodes[i]] = 0
        parents[nodes[i]] = nodes[i]

    for edge in edges:
        src, dst = edge
        if find(src) != find(dst):
            union(src, dst)
</code></pre><pre><code># union 함수를 따로 만들지 않고 축약해서 작성함.
# union-by-rank 기법을 제외했는데, 이 때는 root 를 노드별로 각각 찾아야 서로소 집합을 표현할 수 있다.
def disjoint_set_2(nodes, edges):
    for node in nodes:
        ranks[node] = 0
        parents[node] = node

    for edge in edges:
        src, dst = edge
        root_1, root_2 = find(src), find(dst)
        if root_1 != root_2:
            if root_1 &gt; root_2:
                parents[root_2] = parents[root_1]
            else:
                parents[root_1] = parents[root_2]

# 테스트
ranks = {}
parents = {}    # 서로소 집합을 의미하는 데이터
disjoint_set_2(nodes, edges)
print(parents)</code></pre><pre><code># disjoint set - node 객체 이용
# 확인은 하지 않고 구조만 작성했다.

class Node:
    def __init__(self, data, parent=None, rank=0):
        self.data = data
        self.parent = self
        self.rank = rank

#
class disjoint_set:
    def __init__(self, nodes):
        self.tree = nodes

    def find(self, node):
        parent_node = node.parent
        if parent_node == node.data:
            return node
        else:
            parent_node = self.find(parent_node)
            node.parent = parent_node
        return parent_node

    def union(self, src, dst):
        root_1, root_2 = self.find(src), self.find(dst)

        if root_1 != root_2:
            if root_1.rank &gt; root_2.rank:
                root_2.parent = root_1.parent
            else:
                root_1.parent = root_2.parent
                if root_1.rank == root_2.rank:
                    root_2.rank += 1</code></pre>