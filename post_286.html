<h2>[10 장] - 컴 구조</h2>
<h2>절차적 함수 호출</h2>
<ul>
<li>스택 프레임<ul>
<li>함수 내에서 선언된 지역변수들의 공간.</li>
<li>파라미터도 스택에 저장된다.</li>
</ul>
</li>
<li>SP<ul>
<li>스택에 변수가 선언될 때마다 스택에 쌓이는데 어디까지 쌓았는지 알고있는 것이 레지스터(SP)</li>
</ul>
</li>
<li>프레임 포인터 - frame pointer<ul>
<li>SP 의 백업</li>
<li>함수 반환 시 스택도 반환해야 하는데 SP 혼자 못하므로 필요</li>
<li>함수를 호출할 때 SP 는 FP 에 체크포인트를 저장한다.</li>
</ul>
</li>
<li>반환<ul>
<li>단순하게 SP 를 이전의 값으로 만드는것임.</li>
<li>그래서 스택 프레임에 값을 덮어씌울수 있도록 한것임.</li>
</ul>
</li>
</ul>
<h2>FP 레지스터 문제와 해결</h2>
<ul>
<li>함수 안에서 함수 호출이 계속되면 FP 는 덮어씌워진다.</li>
<li>SP 의 백업이 FP 인데 무용지물이된다.</li>
<li>그래서 FP 도 백업이 필요한데 그 백업은 메모리에 된다.</li>
<li>stack 메모리에 해당한다.<ul>
<li>그러니까 SP 가 가리키는 스택에 호출시점의 주소를 함께 저장하도록 하는것!</li>
</ul>
</li>
</ul>
<h2>함수 호출 결론</h2>
<ul>
<li>스택과 SP, FP 의 콜라보로 동작한다.</li>
</ul>
<h2>PUSH, POP</h2>
<ul>
<li>스택은 매우 바쁘다.</li>
<li>인자와 지역변수의 생성 소멸이 빈번</li>
<li>위에서 배운 스택 동작을 구현하기 위해 명령어를 디자인</li>
<li>SP 를 변화시키는 작업</li>
</ul>
<h2>PUSH</h2>
<ul>
<li>STORE 명령어를 응용</li>
<li>STORE [인자값, SP] - 하려는 것</li>
<li>STORE [레지스터, 목적지] - 기존의 명령</li>
<li>그대로 사용할 수 없다.</li>
<li>인자값을 레지스터에 저장하는 명령어 추가<ul>
<li>ADD 명령어로 단순하게</li>
</ul>
</li>
<li>SP를 목적지(메모리 주소) 에 저장하는 명령어 추가<ul>
<li>STORE 명령어를 바로 쓸 수 있다.</li>
</ul>
</li>
<li>그리고 최종적으로 형식에 맞게 STORE 명령어 추가<ul>
<li>STORE r1 , [주소] - indirect 모드 필수!</li>
</ul>
</li>
<li>SP 의 값을 증가시키면 끝<ul>
<li>ADD 명령어를 그대로 사용</li>
</ul>
</li>
</ul>
<h2>POP</h2>
<ul>
<li>PUSH 에 비해 단순하다.</li>
<li>SP 만 줄이면 되는 메커니즘이라서.<ul>
<li>어짜피 SP 는 덮어쓸거니까</li>
</ul>
</li>
<li>ADD 나 SUB 를 해줘서 SP 를 빼주면 된다.</li>
</ul>
<h2>실행의 이동</h2>
<ul>
<li>PC 는 프로그램 카운터<ul>
<li>메모리의 code 영역에서 명령어 형태로 존재하는 명령어를 가리킨다.</li>
<li>어디까지 실행된것인지 기억한다.</li>
<li>CPU 는 PC 가 가리키는 명령어를 다음번에 수행하게 된다. </li>
<li>실행의 이동은 함수에서 함수로 실행 흐름이 변할 때다.</li>
<li>PC 에 명령어를 새로운 함수의 내용을 집어넣는다?</li>
<li>즉 실행의 이동은 PC 값을 변화시키는 것임.</li>
</ul>
</li>
<li>순차적 실행은 실행의 이동도 감당할 수 있다.<ul>
<li>CPU 는 내부적으로 묵묵히 순차적 작업을 한다.</li>
<li>레지스터들의 콜라보로 위처럼 실행 이동을 구현함.</li>
</ul>
</li>
<li>PC 도 당연히 원래의 함수 실행으로 돌아와야 한다.<ul>
<li>이를 LR(링크 레지스터) 에 백업한다.</li>
<li>SP 와 FP 의 관계와 동일하게 동작함.</li>
<li>LR 도 FP 처럼 백업주소를 결국 스택에 저장한다.</li>
</ul>
</li>
</ul>
<h2>함수 호출 규약</h2>
<ul>
<li>어떻게 함수를 실행한 것인가?</li>
<li>함수의 반환은 호출의 반대.<ul>
<li>레지스터의 동작도 반대로 동작.</li>
<li>레지스터 비우는 등.</li>
</ul>
</li>
<li>이 반환을 호출된 함수에서 할 것인가, 호출한 함수에서 할 것인가?<ul>
<li>컴파일러 결과에서 그 동작 명령어가 둘 중 어디에 추가 될것인가?</li>
<li>둘 중 하나만 가져야한다!</li>
</ul>
</li>
<li>이러한 것을 규약으로 정함.</li>
<li>64 비트 컴퓨터는 함수 호출에 레지스터를 많이 써서 더 빠르다.</li>
</ul>
<h2>OS 마다 호출 규약이 다른 이유는?</h2>
<ul>
<li>OS 마다 메모리 관리 방법이 차이가 있으니까?</li>
<li>프로세스 관리가 다르니까?</li>
<li>실행은 CPU 가 하지만 그것을 제어하는 것은 OS 니까??</li>
<li>레지스터 제어도 코드로 바로하는것이 아니라 OS 를 거치니까?</li>
</ul>
