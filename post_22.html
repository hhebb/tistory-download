<h2>출처</h2>
<p>프로그래머스, 2020 카카오 블라인드 채용 문제</p>
<h2>난이도</h2>
<p>프로그래머스 level 2</p>
<h2>유형</h2>
<p>단순 구현<br>문자열 토큰화?</p>
<h2>특이사항</h2>
<p>문자열을 쪼개고 비교하는 과정.<br>인덱스 처리와 예외 처리가 매우 까다로움.</p>
<h2>총평</h2>
<p>카카오 문제답게 까다롭다고 생각함.<br>아이디어는 쉬운데 너무 오래걸림.<br>실수가 몇 번 반복되어서 디버깅 시간이 배로 길어짐.<br>코드도 더 짧게할 수 있는데 너무 길어짐.</p>
<pre><code>def solution(s):
    answer = 0
    len_compressed = []

    # 1 부터 끝까지 토큰 사이즈를 나눈다 
    for token_size in range(1, len(s) + 1):
        # 조각의 갯수 설정. 나머지가 남으면 조각 갯수 + 1
        if len(s) % token_size == 0:
            pieces = int(len(s) / token_size)
            remain = False
        else:
            pieces = int(len(s) / token_size) + 1
            remain = True

        # 2 조각이면서 나머지가 남을 땐 그냥 그대로 반환해버린다.
        if pieces == 1 or (pieces == 2 and remain):
            compressed_str = s
            len_compressed.append(len(compressed_str))
            continue

        # 최초 기준 문자열 설정
        compare_str = s[0:token_size]
        # 압축 횟수, 압축된 결과 초기화
        compress_count = 1
        compressed_str = &quot;&quot;

        # 조각별로 압축여부 체크
        for piece in range(1, pieces):
            # 평가 문자열 설정
            eval_str = s[piece*token_size : (piece+1)*token_size]

            # 기준 문자열과 평가 문자열이 같아서 압축이 되면 카운트 올려준다.
            if compare_str == eval_str:
                compress_count += 1

                # 평가 문자열이 마지막 조각이었다면 최종 문자열에 추가해준다.
                if piece == pieces - 1:
                    compressed_str += (str(compress_count)+compare_str)
                continue

            # 압축이 끊길 때
            else:
                # 한 번도 압축되지 않으면 공백
                if compress_count == 1:
                    compress_count_str = &quot;&quot;
                else:
                    compress_count_str = str(compress_count)
                compressed_str += (compress_count_str + compare_str)
                compare_str = eval_str
                compress_count = 1

                if piece == pieces - 1:
                    compressed_str += eval_str

        len_compressed.append(len(compressed_str))
    answer = min(len_compressed)
    return answer</code></pre>