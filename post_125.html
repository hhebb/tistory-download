<h1>최소 신장 트리</h1>
<p><code>Mean Spanning Tree</code> 이다.<br>그래프 간선을 연결하는 방법 중 하나이다.</p>
<p>MST 를 구성하는 방법은 크루스칼, 프림 알고리즘이 있는데 둘 다 그리디 전략을 바탕으로 동작한다.</p>
<ol>
<li>모든 노드를 연결해야 한다.</li>
<li>사이클이 생기면 안된다.</li>
<li>최소 가중치를 가지도록 연결한다</li>
</ol>
<h2>Kruskal</h2>
<ul>
<li>개념<br>union-find 알고리즘을 이용하여 MST 를 구한다.<ol>
<li>각 노드별로 집합들을 초기화 한다.</li>
<li>간선들을 가중치 기준으로 오름차순 정렬한다.</li>
<li>간선들을 돌며 사이클이 없다면 MST 에 등록한다.</li>
</ol>
</li>
<li>비고<br>union 연산과 find 연산을 구현할 때 각각 <code>union-by-rank</code>, <code>path-compression</code> 기법을 사용하면 $O(ElogE)$ 에 수행할 수 있다.<br>union-find 알고리즘 자체도 알아두어야 한다.<br>find 알고리즘은 근본적으로 해당 노드의 루트노드를 찾는 연산인데, 크루스칼에서는 사이클을 체크하는 용도로 활용이 된다.</li>
</ul>
<pre><code>edges = []

for src, val in graph_w.items():
    for dst, w in val.items():
        edges.append((src, dst, w))

def make_set(node):
    parent[node] = node
    rank[node] = 0

def find(node):
    # path compression 사용
    # 경로 압축을 하는 동시에 node 의 루트를 반환해준다.
    if parent[node] != node:
        parent[node] = find(parent[node])
    return parent[node]

def union(src, dst):
    root_1 = find(src)
    root_2 = find(dst)

    if rank[root_1] &gt; rank[root_2]:
        parent[root_2] = root_1
    elif rank[root_1] &lt; rank[root_2]:
        parent[root_1] = root_2
    else:
        rank[root_2] += 1
        parent[root_1] = root_2


def kruskal(edges):
    mst = []
    parent = {}
    rank = {}

    # 1. set 초기화
    for node in edges:
        make_set(node[0])

    # 2. edges 정렬
    edges.sort()

    # 3. edge 연결
    for edge in edges:
        src, dst, w = edge
        if find(src) != find(dst):
            union(src, dst)
            mst.append(edge)
    return mst</code></pre><h2>Prim</h2>
<ul>
<li>개념<br>크루스칼 알고리즘과 마찬가지로 MST 를 형성하는 알고리즘이다.<br>연결된 노드를 중심으로 최소 간선을 연결하는 방법이다.</li>
<li>비고<br>힙을 사용하여 다익스트라와 유사한 로직을 수행한다.<br>시간 복잡도는 heap 에 의존적이다. $O(ElogV)$<br>아직 수도코드 정도로만 작성했는데 시간날 때 구체적으로 구현해야겠다.</li>
</ul>
<pre><code># 프림 알고리즘 수도코드
def prim(graph):
    start = graph[0]
    linked = [start]
    heap = [start] # (w, src, dst) edge 정보
    mst = []

    while heap:
        w, src, dst = heappop(heap)
        if dst in linked:
            continue
        else:
            linked.append(dst)
            mst.append()

        for there in dst:
            if there not in linked:
                heappush(heap, (there))

    return mst</code></pre>