<h2>[3 장] - win32, win64</h2>
<h2>64 비트, 32 비트 구분</h2>
<ul>
<li>한 번에 송수신 가능한 데이터 크기<ul>
<li>버스에 의존적.</li>
<li>한번에 명령어, 데이터를 fetch 하는 사이즈</li>
</ul>
</li>
<li>데이터 처리 능력<ul>
<li>CPU 가 한 번에 읽어들일 수 있는 사이즈</li>
<li>한 번에 CPU 가 처리하는 사이즈.</li>
</ul>
</li>
<li>데이터 송수신과 데이터 처리 모두 64 비트여야 완벽한 64 시스템</li>
</ul>
<h2>프로그래머 입장에서 64 비트 컴퓨터</h2>
<ol>
<li>포인터 크기는 클수록 좋다.</li>
<li>버스 fetch 사이즈와 동일한것이 좋다.</li>
</ol>
<ul>
<li>포인터의 크기가 크면 메모리 접근영역이 넓어짐.</li>
<li>64 비트 컴퓨터에서는 포인터의 크기도 크다.<ul>
<li>32 bit 컴퓨터는 32 bit 크기의 포인터<ul>
<li>64 bit 컴퓨터는 64 bit 크기의 포인터</li>
</ul>
</li>
</ul>
</li>
<li>활용 가능한 메모리의 확장<ul>
<li>활용가능한 메모리가 작다면, 데이터를 쪼개서 처리해야함.</li>
</ul>
</li>
</ul>
<h2>64 비트 기반 프로그래밍</h2>
<ul>
<li>64 비트 기반 프로그래밍<ul>
<li>자료형에 대해 고려해야 함.</li>
</ul>
</li>
<li>LLP 64 vs LP 64 - 자료형의 크기 규약?</li>
<li>윈도우는 LLP, 유닉스는 LP</li>
<li>중요한 건 둘 다 포인터는 8 bytes.</li>
<li>역시 전처리기, 매크로를 이용해 미리 작업해 놓는것이 좋은 습관이다.</li>
</ul>
<h2>64, 32 비트 공존의 문제</h2>
<ul>
<li>배열은 포인터이므로 64 bit 에서는 사이즈가 8 byte.</li>
<li>만약 이 포인터를 4byte 인 int 형으로 형변환 한다면 데이터 손실이 우려.</li>
<li>절대 포인터를 기본 자료형으로 캐스팅하지 말것!</li>
</ul>
<h2>에러 확인</h2>
<ul>
<li>GetLastError 함수를 활용하면 에러 확인에 용이하다.</li>
<li>에러 코드를 반환한다.</li>
</ul>
