<h1>트리</h1>
<p>트리와 그래프는 비교적 광범위하고 일반적인 자료구조이다.<br>그만큼 정형화되지가 않고 그 형태도 다양하고 구성법도 다양하다.<br>많은 변형이 존재하므로 정해진 모듈이 없고 상황에 맞게 논리적으로 구성을 하고 사용을 한다.</p>
<p>트리는 그 특성 때문에 이진 트리가 상당히 많이 활용된다.<br>탐색, 순회, 힙, 데이터 저장 등 많은 경우에 효율적인 알고리즘 작동을 위해 활용이 된다.</p>
<h2>트리 구성 1</h2>
<p>주어지는 입력이 <code>노드 - 자식들</code> 의 형태일 때 그래프처럼 인접리스트로 구성할 수가 있다.<br>트리라는 것의 특징과 목적에 대해 생각해보면 정보를 가진 노드 객체를 배열같은 것에 저장해도 무관하다는 것을 알 수 있다.<br>이 때는 완성된 트리의 정보를 주는것과 마찬가지이다.<br>트리는 일반적인 그래프와는 조금 다르게 상하관계가 있으므로, 보통 node 클래스는 다 만든다.<br>그래서 그것을 기반으로 추가, 삭제 등의 조작 연산을 수행할 수 있도록 한다.</p>
<p>물론 node 구조체는 상황에 맞게 부모, 높이, 기타 자료 등을 추가로 담을 수 있다.</p>
<p>링크드 리스트와 유사한 형태의 node 를 가지는데 다른점은 트리는 자식이 여러개라서 비선형이라는 점이다.</p>
<pre><code># 트리 구성
class Node:
    def __init__(self, data, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

tree = []
n = 5

# 노드 - 왼쪽 자식 - 오른쪽 자식 의 이진 트리의 정보가 주어짐
data = [
    &#39;2, 3, 1&#39;,
    &#39;2, 3, 1&#39;,
    &#39;2, 3, 1&#39;,
    &#39;2, 3, 1&#39;,
    &#39;2, 3, 1&#39;,
]
for i in range(n):
    d, l, r = data[i].split()
    tree.append(Node(d, l, r))</code></pre><h2>트리 구성 2</h2>
<p>그 자체로 완성된 트리가 아닌 입력순서대로 트리를 구성해야 하는 경우.<br>BST, heap 또는 기타 특수 트리들을 구성해야 할 때 직접 기능들을 구현해야 한다.<br>insert, delete 등의 함수를 직접 구현해야 한다.<br>대부분 루트를 타고 내려오고, 재귀적으로 루트를 찾고 하는 등의 과정이 포함되므로 다소 복잡할 수 있다.</p>
<h2>트리 순회</h2>
<ul>
<li><p>트리는 그래프와 달리 출발점이 있는데 루트 노드가 그것임.<br>그래서 루트를 찾는 것이 필요하다.<br>물론 아예 주어지는 경우가 있지만 루트를 찾는 것은 트리가 사용되는 많은 경우에 핵심에 해당한다.</p>
</li>
<li><p>이진 트리에서 트리를 순회하는 방법 중 가장 범용적인 방법이다.<br>pre-order, in-order, post-order 이렇게 순회할 수 있는데 왼쪽 자식, 오른쪽 자식 중 어떤것을 먼저 방문할 것인가를 기준으로 구분한다.<br>그래프에서 하는 DFS 와 유사한 과정이다. 그래서 보통 재귀적으로 구현한다.<br>leaf 에서 root 까지 거슬러올라가 갈 때, 반대로 타고 내려갈 때 재귀나 반복문을 이용한다.<br>단 방향으로 움직이므로 재귀 코드 작성이 용이하다.</p>
</li>
<li><p>전위 순회는 부모 노드를 먼저 출력하거나 처리한다.<br>중위 순회는 왼쪽 자식, 부모, 오른쪽 자식 순으로 순회하는데, 특징은 그림으로 보았을 때 왼쪽부터 순서대로 방문한다는 것이다.</p>
</li>
<li><p>아래는 트리 정보가 완성형으로 주어지고 노드 객체를 딕셔너리에 저장하는 방식으로 각각 순회하였다.<br>물론 노드의 데이터를 리스트의 인덱스로 하여 객체를 저장할 수도 있다.</p>
</li>
</ul>
<pre><code># tree traversal
info = [
    (5, 2, 7),
    (2, 6, 11),
    (7, 9, 12),
    (6, 14, 4),
    (11, 8, 10),
    (9, 15, 13),
    (12, 3, 1),
    (14, -1, -1),
    (4, -1, -1),
    (8, -1, -1),
    (10, -1, -1),
    (15, -1, -1),
    (13, -1, -1),
    (3, -1, -1),
    (1, -1, -1),
]

class Node:
    def __init__(self, data, left, right):
        self.data = data
        self.left = left
        self.right = right

tree = {}
for i in info:
    data, left, right = i
    tree[data] = Node(data, left, right)

# 전위 순회
def pre_order(node):
    print(node.data)
    if node.left != -1:
        pre_order(tree[node.left])
    if node.right != -1:
        pre_order(tree[node.right])

# 중위 순회
def in_order(node):
    if node.left != -1:
        in_order(tree[node.left])
    print(node.data)
    if node.right != -1:
        in_order(tree[node.right])

# 후위 순회                
def post_order(node):
    if node.left != -1:
        post_order(tree[node.left])
    if node.right != -1:
        post_order(tree[node.right])
    print(node.data)

# 확인
pre_order(tree[5])
print()
in_order(tree[5])
print()
post_order(tree[5])</code></pre>