<h1>1 강</h1>
<p>전체적으로 몸풀기 수준의 문제들을 풀었다.<br>음계 같은 문제의 경우 깔끔하게 로직을 처리하는 방법을 익혔다.<br>skt 코테에서 유사한 문제가 출제되었는데 필요이상으로 시간이 오래 걸린 기억이 있다.</p>
<h2>음계 - 2920</h2>
<ul>
<li><p>난이도 - 하</p>
</li>
<li><p>유형 - 배열, 시뮬레이션</p>
</li>
<li><p>핵심</p>
<ol>
<li>리스트에서 원소를 차례대로 비교한다.</li>
<li>두 원소를 기준으로 오름차순/내림차순 여부를 체크한다.</li>
</ol>
</li>
<li><p>비고<br>  asc, desc boolean 으로 만든 후 진행 중 둘 다 false 면 mixed.<br>  아니면 둘 중 하나만 True 가 된다.<br>  깔끔하고 간단하게 작성이 가능하다.<br>  처음에는 급하게 푼다고 변수를 몇개 더 선언하고 할당한다고 더 복잡해졌었다.<br>  디버깅 시간이 길어지기도 했다.</p>
</li>
</ul>
<pre><code>nums = list(input().split())
asc = True        # 다른 변 수 없이 이 2 개만 가지고 깔끔하게 로직을 처리한다.
desc = True

for i in range(len(nums[:-1])):
    if nums[i] &lt; nums[i+1]:
        desc = False
    else:
        asc = False

if asc:
    print(&#39;ascending&#39;)
elif desc:
    print(&#39;descending&#39;)
else:
    print(&#39;mixed&#39;)</code></pre><h2>블랙잭 - 2798</h2>
<ul>
<li><p>난이도 - 하</p>
</li>
<li><p>유형 - 배열, 완전탐색</p>
</li>
<li><p>핵심</p>
<ol>
<li>모든 조합의 경우의 수를 구한다. 최대 100 이라도 1,000,000 을 넘지 않는다.</li>
<li>3 중 반복문으로 푼다. </li>
</ol>
</li>
<li><p>비고<br>  3 중 반복문이 아닌 combinations 로 풀었다.</p>
</li>
</ul>
<pre><code>n, m = list(map(int,input().split()))
cards = list(map(int, input().split()))
candid = []

combi = combinations(cards, 3)
for com in combi:
    candid.append(sum(com))

candid.sort(reverse=True)
for cand in candid:
    if cand &lt;= m:
        print(cand)
        break</code></pre>