<h1>프로세스 스케줄링</h1>
<h2>다중 프로그래밍</h2>
<p>여러개의 프로세스가 시스템에 존재함<br>자원을 할당할 프로세스를 선택해야 함. 자원은 한정적이므로<br>이것을 스케줄링이라고 한다.<br>자원관리 방법</p>
<ol>
<li>시간 분할<br>하나의 자원을 여러 스레드들이 번갈아가며 사용<br>예 - 프로세서(프로세스 스케줄링)</li>
<li>공간 분할<br>하나의 자원을 분할하여 동시에 사용<br>예 - 메모리</li>
</ol>
<h2>스케줄링 목적</h2>
<p>시스템의 퍼포먼스를 올리는것임<br>성능의 정의가 필요한데</p>
<ol>
<li>응답시간 response time- 작업 요청으로부터 응답을 받을때까지 시간</li>
<li>작업 처리량 throughput - 단위 시간 동안 완료된 작업의 수</li>
<li>자원 활용도 resource utilazation- 주어진 시간 동안 자원이 활용된 시간<br>시스템의 목적에 맞는 지표를 고려해 스케줄링 기법을 선택한다.<br>응답시간은 인터랙티브, 리얼타임 시스템에서 매우 중요<br>작업 처리량은 배치 시스템에서 중요<br>자원활용도는 고가의 장비 시스템일때</li>
</ol>
<h2>대기시간, 응답시간, 반환시간</h2>
<p>대기 시간 waiting time - 프로세스가 도착하고 실행하기 전까지<br>응답 시간 - 도착부터 최초 응답을 받을 떄까지 시간<br>실행 시간 burst time - 실행 시작부터 실행 종료까지<br>반환 시간 turnaround time - 도착부터 실행종료까지 전부</p>
<h2>스케줄링 기준 criteria</h2>
<p>스케줄링 기법이 고려하는 항목들이다.</p>
<ol>
<li>프로세스 특성 - io bounded, compute bounded</li>
<li>시스템 특성 - 목적에 따라</li>
<li>프로세스 긴급성</li>
<li>프로세스 우선순위</li>
<li>프로세스 총 실행 시간<br>등등</li>
</ol>
<h2>cpu burst vs i/o burst. 프로세스 특성</h2>
<p>프로세스 수행 = CPU 사용 + IO 대기<br>cpu 사용이 지배적이면 cpu burst, cpu bounded 라고 한다.<br>io 대기시간이 지배적이면 io burst, io bounded 라고 한다.</p>
<h2>스케줄링의 단계</h2>
<p>빈도 및 할당 자원에 따른 구분<br>Long term<br>Mid term<br>Short term</p>
<h2>Long-term scheduling</h2>
<ul>
<li>job scheduling - 시스템에 제출할 작업을 결정한다.</li>
<li>다중 프로그래밍 정도를 조절한다.<br>시스템 내에 프로세스 수를 조절한다. 프로세스 선택</li>
<li>io bounded, compute bounded 프로세스들을 잘 섞어서 선택해야한다.<br>cpu, io 모두 균등하게 작업하도록 하여 시스템의 효율을 높이기 위해</li>
<li>시분할 시스템에서는 롱텀 스케쥴이 별로 안중요<br>모든 작업을 시스템에 등록하므로.</li>
</ul>
<h2>Mid-term scheduling</h2>
<p>메모리 할당 결정에 해당한다.<br>제출된 프로세스에 자원을 할당하는 부분이다.<br>suspended 프로세스를 ready 로 올릴 때</p>
<h2>Short-term</h2>
<p>가장 빈번하게 발생한다.<br>ready 상태에 있는 프로세스를 running 상태로 올릴 때.<br>프로세스 스케줄링 = cpu 프로세서를 할당하는 작업이다.<br>이것이 빨라야 전체적으로 빠르다.</p>
<h2>스케줄링 정책 (policy)</h2>
<p>선점 vs 비선점<br>우선순위</p>
<h2>선점, 비선점 (preemptive/ non preemptive)</h2>
<ol>
<li>비선점 스케줄링<br>할당받을 자원을 스스로 반납할 때까지 사용한다.<br>장점은 컨텍스트스위칭은 줄어든다.<br>단점은 우선순위의 역전, 평균 응답시간증가 등이 있다.</li>
<li>선점 스케줄링<br>타의에 의해 자원을 뺏길 수 있다.<br>우선순위가 높은 프로세스 등장, 할당 시간 종료 등에 의해 뺏김<br>응답성은 높지만 스위칭 오버헤드가 크다.</li>
</ol>
<h2>우선순위</h2>
<ol>
<li>정적 우선순위<br>프로세스 생성 시 결정된 우선순위가 유지됨<br>구현이 쉽고 오버헤드 적음<br>시스템 환경 변화에 대한 대응이 어려움</li>
<li>동적 우선순위<br>프로세스의 상태변화에 따라 우선순위 변경<br>구현 복잡하고 오버헤드 있음<br>시스템 환경변화에 유연한 대응이 가능하다.</li>
</ol>
<h2>기본 스케줄링 알고리즘</h2>
<p>여러가지가 있다.</p>
<h2>FCFS 알고리즘 - first come first service</h2>
<p>선착순으로 프로세스에게 프로세서를 할당한다.<br>non preemptive 스케줄링. 작업이 끝날때까지 계속 점유하고 있는다.<br>스케줄링 기준은 도착시간. 먼저 도착한 프로세스를 처리.<br>자원을 효율적을 사용가능하다.<br>불필요한 오버헤드가 없고 cpu 가 계속 일한다.<br>배치 시스템에 적합하고 인터랙티브 시스템에는 부적합함.<br>단점은 긴 평균 응답시간이다.<br>convoy effect - 대기시간이 실행시간보다 길어지는 현상</p>
<h2>Normalized TT</h2>
<p>turnaround time / burst time<br>정규화된 반환시간.<br>이 값이 크면 대기시간이 크다는 의미.</p>
<h2>RR - (round robin) 알고리즘</h2>
<p>preemptive 스케줄링 - 자원을 빼앗길 수 있다.<br>스케줄링 기준은 도착시간 (단, ready 큐 기준).<br>자원 사용 제한 시간(타임 퀀텀)이 있다.<br>제한 시간이 지나면 레디 큐에 맨 뒤로 들어가 줄을 선다.<br>이는 시스템 파라미터로 준다.<br>프로세스는 제한 시간이 지나면 자원을 반납한다.<br>특정 프로세스의 자원 독점을 방지한다.<br>단점은 스위칭 오버헤드가 크다.<br>그러나 대화형, 시분할 시스템 등 응답이 빨라야하는 시스템에 적합하다.<br>타임 퀀텀이 시스템 성능을 결정하는 핵심 요소.<br>이것이 엄청 크면 그냥 FCFS 와 유사.<br>만약 엄청 작다면 모든 프로세스가 각각의 프로세서 위에서 실행되는 것처럼 느낌<br>그러나 체감 프로세서 속도는 1/n<br>그리고 스위칭 오버헤드가 매우 심하다.</p>
<h2>SPN 알고리즘 - shortest process next</h2>
<p>non preemptive, 독점<br>스케줄링 기준은 실행시간이다. burst time<br>이 시간이 가장 짧은 순서로 프로세서 할당<br>장점으로는 평균 대기시간(wt)이 최소화 된다.<br>시스템내 프로세스 수가 최소화된다. 짧은 것은 빨리 끝내니까<br>스케줄링 부하 감소, 메모리 절약 -&gt; 시스템 효율 향상<br>빠른 응답 시간을 제공<br>단점은, starvation - 무한대기 현상이 발생한다.<br>bt 가 길면 자원을 할당 못받을 수 있다.<br>정확한 bt 를 알 수 없다. 즉 예측 기법이 필요하다.<br>프로세스 터미널 상태에서 정보를 수집하여 예측을 하지만 정확하진 않다.</p>
<h2>SRTN 알고리즘 - shortest remaining time next</h2>
<p>SPN 의 변형<br>preemptive 스케줄링. 잔여 실행 시간이 더 적은 프로세스가 ready 가 되면 선점된다.<br>장점 - SPN 의 장점을 극대화한다.<br>단점 - 역시 프로세스 생성 시 bt 예측 필요<br>잔여 실행 시간 계속 추적해야하므로 오버헤드가 크다.<br>예측, 추적이 어려우므로 비현실적인 스케줄링 알고리즘</p>
<h2>HRRN 알고리즘 - high response ratio next</h2>
<p>SPN 의 변형<br>SPN + Aging + non-preemptive<br>Aging 은 대기시간을 고려하여 기회를 제공하는 것임<br>스케줄링 기준은 response ration 가 높은 프로세스.<br>응답률 = (wt + bt) / bt<br>bt 대비 얼마나 많이 기다렸는가를 고려함.<br>SPN 의 장점과 Starvation 을 방지한다.<br>하지만 여전히 bt 를 예측해야 함.</p>
<h2>기본적인 알고리즘</h2>
<p>FCFS, RR 은 공평성<br>SPN 계열은 효율성, 성능을 중점적으로<br>SPN 계열은 bt 예측이 어렵다.<br>이를 해결하는 것이 MLQ, MFQ</p>
<h2>MLQ 알고리즘 - multi level queue</h2>
<p>앞의 알고리즘들과 달리 작업별 별도의 레디 큐를 가진다.<br>최초 배정된 큐를 벗어나지 못한다. - 시스템 변화에 유연하지 못함<br>각각의 큐는 자신만의 스케줄링 기법을 사용한다.<br>큐 사이에는 우선순위 기반의 스케줄링 사용<br>여러 개의 큐 관리 등 스케줄링 오버헤드가 있다.<br>우선순위 낮은 큐는 starvation 현상</p>
<h2>MFQ 알고리즘 - multi level feedback queue</h2>
<p>프로세스의 큐 간 이동이 허용된 MLQ<br>피드백을 통해 우선순위 조정<br>동적인 우선순위.<br>장점은 bt 예측없이 SPN 계열 알고리즘의 효과를 기대할 수 있다.<br>단점은 설계, 구현이 어려움<br>스케줄링 오버헤드가 크다.<br>역시 starvation 현상이 있다.<br>변형을 주어서 향상할 수 있다.</p>
<ol>
<li>각 레디 큐마다 시간 할당량을 다르게 배정</li>
<li>입출력 위주 프로세스들을 상위 단계 큐로 이동하고 우선 순위를 높인다.</li>
<li>대기 시간이 긴 것을 위로 올림 - aging</li>
</ol>
